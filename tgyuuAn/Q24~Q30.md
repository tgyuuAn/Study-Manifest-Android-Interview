### Q24.) 예외를 어떻게 추적하나요?

#### Logcat을 이용한 예외 로깅

- Logcat은 로그를 보고 예외를 추적하는 아주 기본적인 도구. 예외가 발생하면 시스템은 예외 유형, 메시지 및 예외가 발생한 코드 줄을 포함하여 자세한 스택 트레이스를 Logcat에 기록

<br><br><br>

#### try-catch를 이용한 예외 처리

- try-catch 블록을 사용하면 예외를 제어된 방식으로 처리하고 코드의 중요한 부분에서 앱 크래시를 방지할 수 있음

```kotlin
try{
    val result = performRiskyOperation() 
} catch (e: Exception) {
    Log.e("Error", "Exception occurred: ${e.message}", e) // 스택 트레이스 로깅
}
```

<br><br><br>

#### 전역 예외 핸들러 사용하기

- Thread.setDefaultUncaughtExceptionHandler를 사용하여 전역 예외 핸들러를 설정하면 앱 전체에서 처리되지 않은 예외를 포착하는 데 도움이 됨
- 중앙 집중식 오류 보고 또는 로깅에 특히 유용

```kotlin

class MyApplication : Application() { 
    override fun onCreate() {
        super.onCreate()
        val defaultHandler = Thread.getDefaultUncaughtExceptionHandler() 
        Thread.setDefaultUncaughtExceptionHandler { thread, exception ‐>
            Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}: ${exception.message}", exception)
            // 예외 세부 정보 저장 또는 서드 파티 솔루션으로 전송 (Crashlytics 등) 
            // FirebaseCrashlytics.getInstance().recordException(exception)
            // 기존 핸들러 호출 (선택 사항, 시스템 기본 크래시 동작 유지) defaultHandler?.uncaughtException(thread, exception)
        } 
    }
}
```

- 위 방식은 애플리케이션 전체의 런타임 문제를 디버깅하고 모니터링하는 데 매우 효과적. 디버그나 QA 빌드에서만 전역적으로 예외 핸들러를 구현하는 방식을 사용

<br><br><br>

#### Firebase Crashlytics 사용하기

```kotlin
try {
    val data = fetchData()
} catch (e: IOException) {
    FirebaseCrashlytics.getInstance().recordException(e)
}
```

<br><br><br>

#### 브레이크 포인트를 이용한 디버깅

#### 버그 리포트 캡처하기

1. 개발자 옵션 : 개발자 옵션을 활성화하고, 설정 > 개발자 옵션 > 버그 신고로 이동하여 버그 신고 유형을 선택하고 생성된 보고서를 공유
2. Android Emulator에서 버그 신고 캡처 : 확장 컨트롤을 열고 버그 신고를 선택한 다음 관련 세부 정보와 함께 보고서를 저장
3. ADB (Android Debug Bridge)를 사용하여 버그 신고 캡처 : 터미널에서 adb bugreport/path/to/save/bugreport를 실행하거나, adb -s <device_serial_number> bugreport로 특정 기기를 지정. 생성된 ZIP 파일에는 디버깅에 필수적인 dumpsys, dumpstate, logcat과 같은 로그가 포함

#### 실전 질문

Q) Logcat을 사용하여 예외를 디버깅하는 것과 FirebaseCrashlytics와 같은 도구를 사용하여 프로덕션 환경에서 예외를 처리하는 것의 차이점은 무엇인가요? 또한, Logcat과 같은 로컬 환경에서 추적된 예외랑 프로덕션에서 추적된 예외를 각각 어떻게 해결하시나요?
A) Logcat은 로컬 환경에서 발생하는 예외를 실시간으로 추적하여 디버깅 용도로 사용, Firebase Crashlytics는 배포된 앱에서 발생한 예외나 크래시를 수집하여 대시보드로 전송. 실제 유저의 예외를 분석하는데 효과적임.

<br><br><br>

### Q25.) 빌드 변형(build variants)와 플레이버(flavors)란 무엇인가요?

- 빌드 변형과 플레이버는 단일 코드베이스에서 애플리케이션의 다양한 버전을 생성하는 유연한 방법을 제공함.
- 이 시스템을 통해 개발자는 동일한 프로젝트 내에서 개발 및 프로덕션 빌드 또는 무료 및 유료 버전과 같은 여러 구성을 효율적으로 관리할 수 있음

<br><br><br>

#### 빌드 변형

- 빌드 변형은 특정 빌드 타입과 제품 플레이버를 결합한 결과임.
- 안드로이드 Gradle 플러그인은 각 조합에 대해 빌드 변형을 생성하여 다양한 사용사례에 맞는 APK 또는 번들을 생성할 수 있음
- 빌드 타입은 애플리케이션이 어떻게 빌드되는지를 나타내며, 일반적으로 아래 타입을 포함함

- 디버그 : 개발 중에 사용하는 빌드 구성. 종종 디버그 도구, 로그 및 테스트용 디버그 툴을 활용하여 개발자가 개발 향상성을 높이도록 함
- 릴리즈 : 배포에 최적화된 구성으로, 종종 리소스 최적화 및 최소화, 난독화가 적용되고 스토어 게시를 위해 별도의 릴리스 키로 서명되어야 함

<br><br><br>

#### 제품 플레이버

- 제품 플레이버를 통해 개발자는 무료 및 유료 버전이나 us 및 eu와 같은 지역별 버전과 같이 앱의 다양한 변형을 정의할 수 있음.
- 각 플레이버는 애플리케이션 ID, 버전 이름 또는 리소스와 같은 고유한 구성을 가질 수 있음.
- 이를 통해 코드를 복제하지 않고 맞춤형 빌드를 쉽게 만들 수 있음.

```kotlin
android { 
    ...
    flavorDimensions += "version" // 플레이버 차원(dimension) 정의


    productFlavors {
        create("free") {
            dimension = "version"
            applicationIdSuffix = ".free"
            versionNameSuffix = "‐free"
        }
        
        create("paid") {
            dimension = "version"
            applicationIdSuffix = ".paid"
            versionNameSuffix = "‐paid"
        } 
    }
}
```

- 위와 같이 설정하면 안드로이드 Gradle 플러그인은 freeDebug, freeRelease, paidDebug, paidRelease 총 4가지의 조합으로 제품 편형에 따른 빌드를 수행할 수 있음.

<br><br><br>

#### 빌드 타입과 플레이버 결합하기

- 빌드 변형 시스템은 빌드 타입과 제품 플레이버를 결합하여 가능한 빌드의 매트릭스를 만듬

- freeDebug : 디버깅용 무료 버전
- paidRelease : 릴리스에 최적화된 유료 버전

- 각 조합은 변형 조건에 따른 설정, 리소스를 가지거나 코드를 다르게 동작시킬 수 있음.
- 가령 무료 버전에서는 광고를 표시하지만 유료 버전에서는 비홀성화할 수 있음.
- 빌드 타입 및 플레이버에 따라 서로 다른 리소스 디렉토리 및 java/kotlin 코드로 빌드 함으로써 다르게 동작하는 앱을 빌드할 수 있음.

<br><br><br>

#### 빌드 변형 및 플레이버 사용의 이점

1. 효율적인 구성 : 프로젝트를 통째로 복제할 필요가 없으므로, 중복 코드를 줄이고 단일 코드베이스에서 여러 빌드를 처리할 수 있음.
2. 커스텀 동작 : 유료 버전에서 프리미엄 기능을 활성화하거나 디버그와 릴리스 빌드에서 각각 다른 API를 사용하는 등 앱 동작을 맞춤 설정할 수 있음.
3. 자동화 : Gradle은 빌드 변형에 따른 APK 서명, 최적화 및 난독화와 같은 작업을 자동화함.

<br><br><br>

#### 실전 질문

Q) 빌드 타입과 제품 플레이버의 차이점은 무엇이며, 빌드 변형을 생성하기 위해 그 두 가지가 어떤 식으로 함께 작동하나요?
A) 빌드 타입은 debug, qa, release와 같이 사용 사례에 맞는 APK 또는 번들을 생성하는 것이고, 플레이버는 무료/유료 혹은 국가별로 다른 기능을 제공 혹은 리소스를 제공하기 위해 사용하는 것임. 실제로는 빌드 타입과 플레이버가 결합되어 n*m 가지의 가짓수가 생길 수 있음.

<br><br><br>

## Q26.) 접근성(accessibility)을 어떻게 보장하나요?

- 접근성은 시각, 청각 또는 신체 장애가 있는 사람들을 포함하여 모든 사람이 애플리케이션을 사용할 수 있도록 보장하는 것임.
- 접근성 기능을 구현하면 사용자 경험이 향상되고 WCAG와 같은 글로벌 접근성 표준 준수를 보장할 수 있음

<br><br><br>

#### 콘텐츠 설명(Content Descriptions) 활용하기

- 콘텐츠 설명은 UI 컴포넌트에 텍스트 레이블을 제공하여 TalkBack과 같은 스크린 리더가 시각 장애가 있는 사용자에게 해당 컴포넌트를 알릴 수 있도록 함.
- 버튼, 이미지, 아이콘과 같이 상효 작용하거나 정보를 제공하는 컴포넌트에 contentDescription 속성을 사용.
- 컴포넌트의 목적이 단순히 앱을 꾸미는 장식용이라서 스크린 리더가 무시해야 하는 경우는 contentDescriptioin을 null로 설정하거나 View.IMPORTANT_FOR_ACCESSIBILITY_NO를 사용

<br><br><br>

#### 동적 글꼴 크기 지원

- 앱이 기기 설정에서 사용자가 설정한 글꼴 크기 환경 설정을 존중하도록 보장함.
- 접근성 설정에 따라 자동으로 크기가 조정되도록 텍스트 크기에는 sp 단위를 사용함

<br><br><br>

#### 포커스 관리 및 탐색

- 특히 커스텀 뷰, 다이얼로그 및 양식의 경우 포커스 동작을 적절하게 관리.
- 키보드 및 D-패드 사용자를 위한 논리적인 탐색 경로를 정의하려면 nextFocusDown, nextFocusUp 및 관련 속성을 사용함.
- 스크린 리더로 앱을 테스트하여 요소 간 포커스 이동이 자연스러운지 확인함

<br><br><br>

#### 색상 대비 및 시각적 접근성

- 저시력 또는 색맹 사용자의 가독성을 향상시키기 위해 텍스트와 배경색간에 충분한 대비를 제공
- Android Studio의 Accessibility Scanner와 같은 도구는 앱의 색상 대비를 평가하고 최적화하는 데 도움이 될 수 있음.

<br><br><br>

#### 커스텀 뷰 및 접근성

- 커스텀 뷰를 만들 때 AccessibilityDelegate를 구현하여 스크린 리더가 커스텀 UI 컴포넌트와 상호 작용하는 방식을 정의할 수 있음.
- 커스텀 컴포넌트에 의미 있는 설명을 제공하려면 onInitializeAccessibilityNodeInfo() 메서드를 재정의함.

<br><br><br>

#### 잡근성 테스트하기

- Android Studio의 Accessibility Scanner 및 Layout Inspector와 같은 도구를 사용하여 접근성 문제를 식별하고 수정함.
- 이와 같은 도구는 앱이 보조 기술에 의존하는 사용자에게 앱을 사용 가능하도록 보장하는 데 많은 도움이 됨.

<br><br><br>

#### 실전 질문

Q) 동적인 글꼴 사이즈를 지원하기 위한 모범 사례는 무엇이고, 텍스트 크기에 dp 단위보다 sp 단위를 사용하는 것이 선호되는 이유는 무엇인가요?
A) sp단위를 사용하여 사용자 설정의 글꼴 크기를 반영하게 하는 것이 모범사례이고, dp는 화면 밀도에 따라 크기를 보장하지만, 사용자의 글꼴 크기 설정은 반영하지 못하기 떄문에 Sp를 사용하는 것이 바람직하다.

Q) 개발자는 보조 기술에 의존하는 사용자를 위해 적절한 포커스 관리 및 탐색을 어떻게 보장할 수 있으며, 접근성 문제를 테스트하는 데 도움이 되는 안드로이드 도구에는 어떤 것이 있나요?
A) contentDescription을 사용하여 해당 뷰를 클릭했을 떄 보조 설명이 나오도록 하거나, 색맹을 위하여 대비가 높은 색상을 선택하도록 한다. 테스트 할 때에는 Accessibility Scanner나 LayoutInspector를 사용하여 테스트 할 수 있음.

<br><br><br>

## Q27.) 안드로이드 파일 시스템이란 무엇인가요?

- 안드로이드 파일 시스템은 안드로이드 기기에서 데이터 저장을 관리하고 구성하는 구조화된 환경임.
- 애플리케이션과 사용자가 파일을 효율적으로 저장, 검색 및 관리할 수 있도록 함.
- 파일 시스템은 리눅스의 파일 시스템 아키텍처 위에 구축되어 엄격한 보안 및 권한 모델을 준수하면서 애플리케이션을 위한 비공개 및 공유 저장 공간을 모두 제공함.

<br><br><br>

#### 안드로이드 파일 시스템의 주요 구성 요소

- 안드로이드 파일 시스템은 각각 고유한 목적을 가진 다양한 디렉토리와 파티션으로 구성된다.

1. System Partition (/system) 
- 안드로이드 프레임워크 라이버르리, 시스템 앱 및 구성 파일을 포함한 핵심 운영체제 파일이 들어있음.
- 이 파티션은 우발적이거나 악의적인 수정을 방지하기 위해 일반 사용자 및 앱에 대한 읽기 전용임

2. Data Partition (/data)
- 데이터베이스, SharedPreferences 및 사용자가 생성한 파일을 포함한 앱별 데이터가 저장됨.
- 각 앱은 /data/data 내에 해당 앱만 접근할 수 있는 비공개 디렉토리를 가지므로 데이터 보안이 보장됨

3. Cache Partition (/cache)
- 시스템 업데이트나 기기 재시작 시 유지할 필요가 없는 캐시된 파일과 같은 임시 데이터 저장에 사용됨

4. External Storage (/sdcard 또는 /storage)
- 여러 앱에서 접근할 수 있는 공유 저장 공간을 제공하며, 이미지, 비디오, 문서와 같은 미디어 파일에 자주 사용됨.
- 내부 또는 이동식 SD 카드 일 수 있음.

5. Temporary Files (/tmp)
- 앱 실행 중 임시 파일을 저장하는 위치.
- 이러한 파일은 일반적으로 앱이나 시스템이 재시작될 떄 지워짐.

<br><br><br>

#### 안드로이드에서 파일 접근하기

- 애플리케이션은 안드로이드 프레임워크에서 제공하는 API를 사용하여 파일 시스템과 상호 작용함.
- 필요한 파일 가시성 및 수명에 따라 앱은 파일을 다른 위치에 저장할 수 있음.

1. 내부 저장소 : 애플리케이션 샌드박스 내의 비공개 저장 공간으로, 해당 앱만 접근할 수 있음. 민감하거나 앱별 데이터 저장에 이상적임.
2. 외부 저장소 : 여러 앱에서 접근할 수 있는 공유 저장 공간으로, 사용자가 앱 외부에 접근할 것으로 예상하는 사용자 생성 콘텐츠 또는 미디어를 저장하는 데 사용됨.

<br><br><br>

#### 파일 권한 및 보안

- 안드로이드 파일 시스템은 엄격한 권한 모델을 적용함

1. 비공개 앱 데이터 : 앱의 내부 저장소에 저장된 파일은 비공개이며 해당 앱만 접근할 수 있음.
2. 공유 파일 : 앱 간에 파일을 공유하려면 개발자는 외부 저장소나 적절한 권한이 있는 ContentProvider를 사용할 수 있음.
3. 범위 지정 저장소(Scoped Storage) : 안드로이드 10에서 도입되었으며, 공유 저장소에 대한 직접 접근을 제한하여 앱이 MediaStore 또는 SAF(Storage Access FrameWork) API를 사용하도록 요구함

<br><br><br>

#### 실전 질문

Q) 안드로이드는 파일 시스템에서 보안 및 권한을 어떻게 관리하며, 앱이 서로의 비공개 데이터에 접근할 수 없도록 보장하는 메커니즘은 무엇인가요?
A) 앱은 리눅스 운영체제 수준의 샌드박스를 사용하여 각 앱을 고유한 UI로 실행. 이로써 각 앱은 독립된 프로세스 공간에 위치하여 기본적으로 파일 접근이 차단되어 있음.

<br><br><br>

## Q28.) 안드로이드 런타임(ART), Dalvik, Dex 컴파일러란 무엇인가요?

- 안드로이드 애플리케이션은 기기에서 실행되기 위해 고유한 런타임 환경과 컴파일 프로세스에 의존함.
- ART, Dalvik, Dex 컴파일러는 이 프로세스에서 중요한 역할을 하며, 앱이 성능, 메모리 효율성 및 안드로이드 기기와의 호환성을 위해 최적화되도록 보장함.

<br><br><br>

#### ART

- ART는 안드로이드 4.4에서 도입되어 안드로이드 5.0부터 디폴트로 사용하는 관리형 런타임
- ART는 AOT컴파일을 사용하여 애플리케이션을 컴파일하며, 앱 설치 중에 바이트코드를 기계 코드로 변환함.
- 이는 런타임 시 JIT 컴파일의 필요성을 없애 앱 시작 시간을 단축하고 실행 중 CPU 사용량을 줄임

<br><br><br>

- ART의 주요 특징은 다음과 같음

1. 개선된 성능 : AOT 컴파일은 최적화된 기계 코드를 생성하여 런타임 오버헤드를 줄임
2. 가비지 컬렉션 : ART는 더 나은 메모리 관리를 위해 개선된 가비지 컬렉션 기술을 도입하였음.
3. 디버깅 및 프로파일링 지원 : ART는 개발자를 위해 상세한 스택 트레이스 및 메모리 사용량 분석과 같은 향상된 도구를 제공함.

<br><br><br>

#### Dalivk

- ART 이전에 안드로이드에서 사용된 런타임
- 가상 머신 환경에서 애플리케이션을 실행하도록 설계되었으며 제한된 메모리와 처리 능력을 위해 최적화됨
- Dalvik은 JIT 컴파일을 사용하여 런타임에 바이트 코드를 기계 코드로 변환함.
- 앱 설치에 필요한 시간을 줄여지지만 즉석 컴파일로 인해 런타임 오버헤드가 증가함.

<br><br><br>

- Dalvik의 주요 특징은 다음과 같음

1. 컴팩트한 바이트 코드 : Dalvik은 낮은 메모리 사용량과 빠른 실행을 위해 최적화된 .dex 파일을 사용함
2. 레지스터 기반 VM : Dalvik은 스택 기반이 아닌 레지스터 기반이므로 명령어 효율성이 향상됨

- Dalvik의 느린 앱 시작 시간과 높은 CPU 사용량과 같은 한계로 인해 최신 안드로이드 버전에서는 ART로 대체되었음.

<br><br><br>

#### Dex 컴파일러

- Dex 컴파일러는 Java/Kotlin 컴파일러에서 생성된 Java 바이트 코드를 .dex 파일로 변환함.
- 이러한 .dex 파일은 컴팩트하여 Dalvik 및 ART 런타임 환경에 최적화되어 있음.
- Dex 컴파일러는 안드로이드 애플리케이션이 기기에서 효율적으로 실행되도록 하는 데 중요한 역할을 함.

<br><br><br>

- Dex 컴파일러의 주요 측면은 다음과 같음

 1. 멀티덱스 지원 : 64K 메서드 제한을 초과하는 애플리케이션의 경우 Dex 컴파일러는 바이트코드를 여러 .dex 파일로 분할하는 것ㅇ르 지원함.
 2. 바이트코드 최적화 : 컴파일러는 안드로이드 기기에서 더 나은 메모리 사용량과 실행 성능을 위해 바이트코드를 최적화함.

- Dex 컴파일 프로세스는 안드로이드 빌드 시스템에 통합되어 있으며, 앱 개발의 빌드 단계 중에 발생함.

 <br><br><br>

 #### Dalvik에서 ART로의 전환

 - Dalvik에서 ART로의 전환은 안드로이드 런타임 환경을 상당히 개선시켰음.
 - ART의 AOT 컴파일, 개선된 가비지 컬렉션 및 프로파일링 기능은 더 나은 개발자 및 사용자 경험을 제공함.
 - Dalvik용으로 설계된 앱은 .dex 파일을 사용하기 떄문에 ART와 완벽하게 호환되어 갭라자에게 원활한 마이그레이션을 보장함.

 <br><br><br>

 #### 실전 질문

 Q) ART의 AOT 컴파일은 Dalvik의 JIT 컴파일과 어떻게 다르며, 앱 시작 시간과 CPU 사용량에 어떤 영향을 미치나요?
 A) JIT는 바이트 코드 형태로 앱을 다운받으며, 앱을 실행하는 시점에 즉시 컴파일함. AOT는 앱을 설치할 때 컴파일 된 상태로 내려받아서 실행 시간이 빠르며 CPU 사용량을 줄임.

<br><br><br>

## Q29.) APK 파일과 AAB 파일의 차이점은 무엇인가요?

- 안드로이드 애플리케이션은 두 가지 기본 포맷인 APK와 AAB를 사용하여 배포 및 설치할 수 있음.
- 두 포맷 모두 안드로이드 앱을 패키징하는 역할을 하지만, 목적, 구조 및 설치 중 리소스 처리 방식에서 차이가 있음

<br><br><br>

#### APK 

- APK 파일은 안드로이드 애플리케이션을 배포하고 설치하는 전통적인 포맷.
- 이는 앱이 기기에서 작동하는 데 필요한 모든 리소스, 코드 및 메타데이터를 포함하는 완전하고 즉시 설치 가능한 패키지임.
- APK 파일은 과할 정도로 완전함. 모든 기기에 대한 모든 리소스를 포함하여 사용자가 필요하지 않는 리소스 까지 가지고 있음.
- APK 파일은 기기에 직접 설치되며 공식 앱 스토어 외부에서 공유하거나 사이드로딩 할 수 있음.

<br><br><br>

#### AAB

- Google에서 도입한 AAB 형식은 APK와 같은 설치 가능한 형식이 아닌 게시 포맷임.
- 개발자는 AAB를 Google Play에 업로드하면, Google Play는 이를 개별 기기에 맞게 최적화된 APK로 처리함.
- AAB 파일은 모듈식으로, 다른 구성에 대한 리소스와 코드를 별개의 번들로 분리함.
- GooglePlay는 이 모듈식 구조를 사용하여 다운로드 시점에 기기별 APK를 생성하여 APK에 비해서 사용자 기기의 앱 크기를 줄임

<br><br><br>

#### APK와 AAB 주요 차이점

1. 목적 및 구조
- APK : 모든 구성에 대한 모든 리소스와 코드를 포함하는 완전한 패키지
- AAB : 기기별 APK를 생성하는 모듈식 게시 형식임

2. 파일 크기
- APK : 모든 기기에 대한 리소스를 포함하여 크기가 더 큼
- AAB : 더 작고 최적화된 APK를 생성할 수 있께 하여 사용자에게 전달되는 앱 크기를 줄임

3. 배포
- APK : 기기에 직접 공유하고 사이드로딩 할 수 있ㅇ므.
- AAB : GooglePlay에 업로드되며, GooglePlay가 최종 사용자를 위해 최적화된 APK를 생성함

4. 관리
- APK : 개발자가 리소스와 구성을 수동으로 관리해야 함
- AAB : 구성 관리를 GooglePlay에 위임하여 프로세스를 자동화함

5. 도구 및 호환성
- APK : 모든 안드로이드 기기 및 앱 스토어에서 지원됨
- AAB : 설치 가능한 APK를 생성하기 위해 GooglePlay 또는 bundletool이 필요하며, 기본적으로 Google 외 앱 스토어와 호환되지 않음.

<br><br><br>

#### 실전 질문

Q) AAB 포맷은 어떻게 다양한 기기 구성에 대해서 앱을 최적화하며, 이는 기존 APK 포맷에 비해 어떤 장점이 있나요?
A) APK의 경우 모든 기기, 모든 리소스에 대해서 내용을 담고 있지만 AAB는 GooglePlay에서 사용자에 맞는 최적화된 리소스만 설치되게 하여 앱 크기르 줄여주는 역할을 함.

<br><br><br>

## Q30.) R8 최적화란 무엇인가요?

- R8은 안드로이드 빌드 프로세스에서 APK 또는 AAB의 크기를 줄이고 런타임 성능을 향상시키기 위해 사용되는 코드 축소 및 최적화 도구임.
- 안드로이드 빌드 시스템에 통합되어 이전의 프로가드 도구를 대체하고, 코드 축소, 최적화, 난독화 및 리소스 관리를 위한 향상된 기능을 제공함.

<br><br><br>

#### R8 작동 방식

- R8은 빌드 단계 중에 애플리케이션 코드를 수정하여 아래의 목적들을 달성함

1. 코드 축소 : 애플리케이션 코드베이스에서 사용되지 않는 클래스, 메서드, 필드 및 속성을 제거하여 최종적인 APK 또는 AAB 크기를 줄임
2. 최적화 : 런타임 성능을 향상시키기 위해 코드를 단순화하고 재구성함. 여기에는 메서드 인라이닝, 중복 코드 제거, 동일한 코드 블록 병합 등이 포함됨
3. 난독화 : 클래스, 메서드 및 필드의 이름을 변경하여 원래 이름을 모호하게 만들어 리버스 엔지니어링을 더 어렵게 만듬
4. 리소스 최적화 : 사용되지 않는 리소스를 제거하여 앱 사이즈를 더욱 최소화 함.

<br><br><br>

#### R8 최적화의 주요 특징

1. 죽은 코드 제거 : R8은 코드베이스를 분석하여 앱에서 도달할 수 없거나 사용되지 않는 코드를 식별하고 제거함
2. 인라이닝 : 짧은 메서드나 함수를 호출자쪽에 직접 인라인하여 메서드 호출 오버헤드를 줄이고 런타임 성능을 향상시킴
3. 클래스 병합 : 유사한 클래스나 인터페이스를 하나로 결합하여 메모리 공간을 줄이고 효율성을 향상시킴.
4. 도달 불가능한 코드 제거 : 실행되지 않는 코드 경로를 완전히 제거함
5. 상수 폴딩 및 전파 : 표현식을 단순화하고 변수를 가능한 경우 해당 상수 값으로 대체함
6. 난독화 : R8은 코드의 의미 있느 이름을 더 짧고 덜설명적인 이름으로 대체하여 앱 크기를 줄이고 리버스 엔지니어링을 더 어렵게 만듬.

<br><br><br>

#### R8 구성

- R8은 앱 빌드 구성을 위해 Proguard 규칙을 동일하게 사용
- 코드의 어떤 부분을 축소, 난독화 또는 최적화에서 제외할 지 지정할 수 있음.

1. 리플렉션을 위한 코드 보존 : 리플렉션을 통해 접근하는 클래스나 메서드는 런타임에 해당 패키지 이름을 알아야하기 떄문에 Proguard 규칙에 명시적으로 Keep하여 난독화 하지 않도록 해야 함
2. 서드파티 라이브러리 제외 : 일부 라이브러리는 내부적으로 리플렉션을 사용할 수도 있고, 정상적인 기능 동작을 위해 특정 규칙이 필요할 수 있음.

```kotlin
‐keep class com.example.myapp.MyClass { *; }
```

<br><br><br>

#### R8의 장점

1. 긴밀한 통합 : R8은 안드로이드 빌드 시스템에 내장되어 있어 일반적인 Proguard 규칙 외에 추가 설정이 필요하지 않음.
2. 향상된 효율성 : 축소 ,최적화 및 난독화를 단일 패스로 결합하여 Proguard보다 빠르고 효율적임
3. 앱 크기 감소 : 사용되지 않는 코드와 리소스를 제거하여 최종 APK 또는 AAB 크기를 크게 줄임
4. 향상된 보안 : 난독화는 해커 및 크래커가 앱을 리버스 엔지니어링하기 어렵게 만들어 보안을 강화함.

<br><br><br>

#### R8의 한계

1. 과도한 축소 위험 : 제대로 구성하지 않으면 R8이 간접적으로 참조되는 코드나 리소스를 제거하여 런타임 오류를 유발할 수 있음
2. 복잡한 구성 : 복잡한 프로젝트, 특히 리플렉션이나 동적 클래스 로딩을 사용하는 프로젝트의 경우 Proguard 규칙 작성이 복잡하고 까다로울 수 있음.
3. 디버깅 어려움 : 난독화는 스택 트레이스에 난독화된 이름이 로깅되기 때문에 디버깅을 더 어렵게 만들 수 있음.
