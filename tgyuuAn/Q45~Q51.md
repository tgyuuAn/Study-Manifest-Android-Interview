### Q45.) 안드로이드의 Bitmap이란 무엇이며, 큰 Bitmap을 효율적으로 처리하는 방법은 무엇인가요?

- Bitmap은 메모리 내 이미지 표현임
- 픽셀 데이터를 저장하며 리소스, 파일 또는 원격 소스에서 가져온 이미지를 화면에 렌더링하는데 자주 사용됨.
- 비트맵 객체는 특히 고해상도 이미지의 경우 대량의 픽셀 데이터를 보유하므로 부적절하게 처리하면 OOM이 쉽게 발생할 수 있음

#### 큰 Bitmap의 문제점

- 카메라나 인터넷에서 다운로드한 이미지와 같은 많은 이미지는 이를 표시하는 UI 컴포넌트에서 요구하는 크기보다 훨씬 큼
- 이러한 전체 해상도 이미지를 불필요하게 로드하면 과도한 메모리 소비, 성능 오버헤드 유발, 크래시 발생 등의 위험이 있음

<br><br><br>

#### 메모리를 할당하지 않고 Bitmap 크기 읽기

- 비트맵을 로드하기 전에 전체 로드가 정당한지 결정하기 위해 크기를 검사하는 것이 중요
- BitmapFactory.Options 클래스를 사용하면 inJustDecodeBounds = true로 설정하여 픽셀 데이터에 대한 메모리 할당을 피하면서 이미지 메타데이터를 디코딩할 수 있음.

<br><br><br>

#### 샘플리을 사용하여 축소된 Bitmap 로드하기

- 크기를 알게 되면 inSampleSize 옵션을 사용하여 비트맵을 대상 크기에 맞게 축소할 수 있음.
- 이미지를 2, 4 등의 배수로 서브샘플링하여 메모리 사용량을 줄임.
- 예를 들어 inSampleSize = 4로 로드된 2048*1536 이미지는 512*384 비트맵이 됨

<br><br><br>

#### 서브샘플링을 사용한 전체 디코딩 프로세스

- calculateInSampleSize를 사용하여 두 단계로 비트맵을 디코딩할 수 있음
1. 경계만 디코딩한다.
2. 계산된 inSampleSize를 설정하고 축소된 비트맵을 디코딩한다.

<br><br><br>

#### 실전 질문

Q) 큰 Bitmap을 메모리에 로드하는 것은 어떤 위험성이 있으며, 어떻게 효율적으로 처리할 수 있나요?
A) inJustSampleSize를 이용하여 이미지 해상도를 먼저 알아내고, SampleSize를 구한뒤 서브샘플링을 진행 후 비트맵을 로드함.

<br><br><br>

#### LruCache를 사용한 메모리 내 캐싱

- LruCache는 Bitmap을 위한 선호되는 메묄 내 캐싱 솔루션임
- 최근에 사용된 항목에 대한 강력한 참조를 유지하고 메모리가 부족할 때 가장 최근에 사용되지 않은 항목을 자동으로 제거함

<br><br><br>

#### DiskLruCache를 사용한 디스크 캐싱

- 메모리 캐싱은 용량이 제한적이고 휘발성이기 때문에, DiskLruCache를 사용하여 디스크에 저장하는 방법을 사용하는 것이 좋음.

<br><br><br>

### Q46.) 애니메이션을 어떻게 구현하나요?

#### View Property Animations

- API 레벨 11에서 도입된 View Property Animations는 alpha, translationX, transltationY, rotation, scaleX와 같은 View 객체의 속성을 애니메이션화 할 수 있음.

```kotlin
val view: View = findViewById(R.id.my_view)
view.animate()
    .alpha(0.5f)
    .translationX(100f)
    .setDuration(500)
    .setInterpolator(AccelerateDecelerateInterpolator())
    .start()
```

<br><br><br>

#### ObjectAnimator

- ObjectAnimator는 View 객체뿐만 아니라 setter 메서드가 있는 모든 객체의 속성을 애니메이션화 할 수 있음.
- 커스텀 속성을 애니메이션화 하는데 더 큰 유연성을 제공함

```kotlin
val animator = ObjectAnimator.ofFloat(view, "translationY", 0f, 300f)
animator.duration = 500
animator.interpolator = OvershootInterpolator()
animator.start()
```

<br><br><br>

#### AnimatorSet

- AnimatorSet은 여러 애니메이션을 순차적으로 또는 동시에 실행하도록 결합하여 복잡한 애니메이션을 조정하는 데 적합함

```kotlin
val fadeAnimator = ObjectAnimator.ofFloat(view, "alpha", 1f, 0f)
val moveAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 200f)

val animatorSet = AnimatorSet()
// 순차적으로 재생: fadeAnimator 실행 후 moveAnimator 실행
animatorSet.playSequentially(fadeAnimator, moveAnimator)
// 동시에 재생: animatorSet.playTogether(fadeAnimator, moveAnimator)
// 복잡한 순서: animatorSet.play(fadeAnimator).before(moveAnimator) 등
animatorSet.duration = 1000 // 전체 세트 지속 시간 (개별 설정도 가능)
animatorSet.start()
```

<br><br><br>

#### ValueAnimator

- ValueAnimator는 임의의 값 사이를 애니메이션화하는 방법을 제공하여 커스텀 가능하고 유연한 애니메이션을 구현할 수 있음.
- 인터폴레이터로 애니메이션 진행을 제어함으로써 너비, 높이, 알파 또는 기타 속성을 애니메이션화하는 등 광범위한 사용 사례에 적용할 수 있음
- 이는 특정 요구 사항에 맞는 정밀하고 동적인 애니메이션을 구현하는 데 적합함.

```kotlin
val valueAnimator = ValueAnimator.ofInt(0, 100) // 0에서 100까지 정수 값 변경
valueAnimator.duration = 500
valueAniamtor.addUpdateListener { animation -> 
    val animatedValue = animation.animatedValue as Int
    // animatedValu를 사용하여 UI 업데이트
    val params = binding.progressbar.layoutParams
    params.width = ((screenSize / 100f) * animatedValue).toInt()
    binding.progressbar.layoutParams = params
}
valueAnimator.start()
```

<br><br><br>

#### XML 기반 View 애니메이션

- XML 기반 애니메이션은 단순성과 재사용성을 위해 리소스 파일에서 애니메이션 동작을 정의함.
- 이러한 애니메이션은 위치, 크기 조절, 회전 또는 투명도를 조절하는데 사용할 수 있음.

```xml
<translate xmlns:android="http://schemas.android.com/apk/res/android" 
android:fromXDelta="‐100%"
android:toXDelta="0%"
android:duration="500" 
android:interpolator="@android:anim/accelerate_decelerate_interpolator" /> 
```

```kotlin
val animation = AnimationUtils.loadAnimation(this, R.anim.slide_in) 
view.startAnimation(animation)
```

<br><br><br>

#### MotionLayout

- MotionLayout은 복잡한 모션 및 레이아웃 애니메이션을 만들기 위한 안드로이드 전용 컴포넌트
- ConstraintLayout 위에 구축되었으며, XML을 사용하여 상태 간의 애니메이션 및 전환을 정의할 수 있음.

```xml
<MotionScene xmlns:android="http://schemas.android.com/apk/res/android" 
    xmlns:app="http://schemas.android.com/apk/res‐auto">

    <ConstraintSet android:id="@+id/start">
        <!‐‐ 시작 상태 제약 조건 정의 ‐‐> 
        <Constraint android:id="@id/box">
            <Layout
                android:layout_width="100dp" 
                android:layout_height="100dp" 
                app:layout_constraintTop_toTopOf="parent" 
                app:layout_constraintStart_toStartOf="parent"/>
        </Constraint>
    </ConstraintSet>

    <ConstraintSet android:id="@+id/end"> 
    <!‐‐ 종료 상태 제약 조건 정의 ‐‐>
        <Constraint android:id="@id/box"> 
            <Layout
                android:layout_width="100dp" 
                android:layout_height="100dp" 
                app:layout_constraintBottom_toBottomOf="parent" 
                app:layout_constraintEnd_toEndOf="parent" />
        </Constraint>
    </ConstraintSet>

    <Transition
        app:constraintSetStart="@id/start" 
        app:constraintSetEnd="@id/end" 
        app:duration="500">

        <!‐‐ 스와이프 또는 클릭 트리거 추가 ‐‐> 
        <OnSwipe
            app:touchAnchorId="@id/box" 
            app:touchAnchorSide="top" 
            app:dragDirection="dragDown" />
    </Transition>
</MotionScene>
```

<br><br><br>

```xml
<androidx.constraintlayout.motion.widget.MotionLayout
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    app:layoutDescription="@xml/motion_scene"> <!‐‐ 모션 씬 파일 참조 ‐‐>

    <!‐‐ 애니메이션될 뷰 ‐‐>
    <View
        android:id="@+id/box" 
        android:layout_width="100dp" 
        android:layout_height="100dp" 
        android:background="@color/blue" />

</androidx.constraintlayout.motion.widget.MotionLayout>
```

<br><br><br>

#### 물리 기반 Animations

- 실제 역학을 시뮬레이션함.
- 안드로이드는 자연스럽고 동적인 모션 효과를 만들기 위해 SpringAnimation 및 FlingAnimation API를 제공함

```kotlin
val springAnimation = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f) //최종위치설정

springAnimation.spring = SpringForce() // SpringForce 객체 생성
    .setFinalPosition(0f) // 최종 위치 설정 (중복될 수 있음)
    .setStiffness(SpringForce.STIFFNESS_LOW) // 강성 설정
    .setDampingRatio(SpringForce.DAMPING_RATIO_HIGH_BOUNCY) // 감쇠 비율 설정

springAnimation.start()
```

<br><br><br>

### Q47.) Window란 무엇인가요?

- Window는 화면에 표시되는 Activity 또는 다른 UI 컴포넌트의 모든 뷰를 담는 컨테이너를 나타냄
- View 계층 구조의 최상위 요소이며, 애플리케이션 UI와 디스플레이 간의 다리 역할을 함
- 모든 Activity, Dialog, Toast는 Window 객체에 연결되어 있으며, 이는 포함된 뷰의 레이아웃 매개변수, 애니메이션 및 전환 기능 등을 제공함

<br><br><br>

#### Window의 주요 특징

1. DecorView : Window는 계층 구조의 루트 뷰 역할을 하는 DecorView를 포함함. 일반적으로 상태 표시줄(StatusBar), 내비게이션 바(navigation bar) 및 앱의 콘텐츠 영역을 포함함
2. 레이아웃 매개변수 : Window는 크기, 위치, 가시성과 같은 레이아웃 매개변수를 사용하여 뷰가 어떻게 정렬되고 표시되는 지 정의함. 이는 프로그래밍 방식으로 커스텀할 수 있음.
3. 입력 처리 : Window는 입력 이벤트(터치 제스처, 키 누름)을 처리하고 이를 적절한 뷰로 전달함
4. 애니메이션 및 전환 : Window는 화면 열기, 닫기 또는 화면 간 전환을 위한 애니메이션을 지원함
5. 시스템 UI 처리 : Window는 상태 표시줄 및 내비게이션 바와 같은 시스템 UI 요소를 표시하거나 숨길 수 있음.

<br><br><br>

#### Window 관리

- Window는 윈도우 추가, 제거 또는 업데이트를 담당하는 시스템 서비스인 WindowManager에 의해 관리됨.
- 이를 통해 다양한 윈도우(가령, 앱 윈도우, 시스템 다이얼로그, 알림)이 기기에서 올바르게 공존하고 상호 작용할 수 있음.

<br><br><br>

#### Window의 사용 사례

1. Activity Window 커스텀 : getWindow() 메서드를 사용하여 Activity의 윈도우 동작을 수정할 수 있음. 가령, 상태 표시줄을 숨기거나 배경색상을 변경할 수 있음.

```kotlin
// 전체 화면 모드 설정 (상태 표시줄 숨김)
window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_FULLSCREEN

// 배경을 검은색으로 설정
window.setBackgroundDrawable(ColorDrawable(Color.BLACK))
```

2. Dialog 생성 : Dialog는 새로운 윈도우를 사용하여 그 위에 구현되므로 다른 UI 요소 위에 떠 있을 수 있음
3. 오버레이 사용 : TYPE_APPLICATION_OVERLAY를 통해 시스템 수준 기능이나 헤드업 알림과 같은 오버레이를 만드는 데 Window를 사용할 수 있음.
4. 멀티 윈도우 모드 처리 : 안드로이드는 분할 화면이나 PIP 모드와 같은 기능을 활성화하기 위해 멀티 윈도우를 지원함

<br><br><br>


#### 실전 질문

Q) 단순한 레이아웃을 가진 Activity가 화면에 표시될 때 몇 개의 Window가 존재하며, 어느 부분에 필요한가요?
A) 한 개의 Window가 필요. Window는 StatusBar, NavigationBar를 포함하여 Activity의 콘텐츠가 보여지는 영역이므로 최소한 한개는 있어야 함.

<br><br><br>

#### WindowManager란 무엇인가요?

- WindowManager는 화면에서 윈도우의 배치, 크기 및 모양을 관리하는 안드로이드 시스템 서비스임.
- 애플리케이션과 안드로이드 시스템 간의 윈도우 관리 인터페이스 역할을 하며, 앱이 윈도우를 생성, 수정 또는 제거할 수 있도록 함
- 안드로이드의 윈도우는 전체 화면 Activity 부터 플로팅 오버레이까지 무엇이든 할 수 있음.

<br><br><br>

#### WindowManager의 주요 책임

- WindowManager는 시스템의 윈도우 계층 구조를 관리하는 역할을 함
- 윈도우가 z 순서 및 다른 시스템 윈도우와의 상호 작용에 따라 올바르게 표시되도록 보장함
- 예를 들어, 포커스 변경, 터치 이벤트 및 애니메이션을 처리함

<br><br><br>

#### 일반적인 사용 사례

1. 커스텀 View 추가 : 개발자는 WindowManager를 사용하여 플로팅 위젯이나 시스템 오버레이와 같이 앱의 표준 Activity 외부에 커스텀 뷰를 표현할 수 있음.
2. 기존 WIndow 수정 : 애플리케이션은 크기 조절, 위치 변경 또는 투명도 변경과 같이 기존 윈도우의 속성을 업데이트할 수 있음.
3. Window 제거 : RemoveView() 메서드를 사용하여 프로그래밍 방식으로 윈도우를 제거할 수 있음.

<br><br><br>

#### WindowManager 작업하기

- WindowManger 서비스는 Context.getSystemService(Context.WINDOW_SERVICE)를 통해 접근함
- 아래는 WindowManager를 사용하여 플로팅 뷰를 추가하는 예시임

```kotlin
val windowManager = context.getService(Context.WINDOW_SERVICE) as WindowManager

val floationView = LayoutInflater.from(context).inflate(R.layout.floating_view, null)

val params = WindowManager.LayoutParams(
    WindowManager.LayoutParams.WRAP_CONTENT, // 너비
    WindowManager.LayoutParams.WRAP_CONTENT, // 높이
    // Android 8.0 (API 26) 이상에서는 TYPE_APPLICATION_OVERLAY, 이전 버전에서는 TYPE_PHOE 사용

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
    } else {
        WindowManager.LayoutParams.TYPE_PHONE
    },
    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, // 윈도우 플래그 (포커스 안 받음)
    PixelFormat.TRANSLUCENT // 픽셀 형식 (투명 배경 허용)
)

// 초기 위치 설정 (예 : 화면 최상단)
params.gravity = Gravity.TOP or Gravity.START
params.x = 0
params.y = 0

// 윈도우에 뷰 추가
windowManager.addView(floatingView, params)

// ... 추후에 플로팅 뷰가 더 사용되지 않을 때 제거
// windowManager.removeView(floatingView)
```

- 위 예제에서 아래와 같은 WindowManager.LayoutParams 속성들이 사용되었음
- TYPE_APPLICATION_OVERLAY는 뷰가 다른 앱 위에 표시되도록 허용함 (권한 필요)
- FLAG_NOT_FOCUSABLE과 같은 플래그는 달리 지정하지 않는 한 윈도우가 사용자 입력과 상호 작용하지 않도록 함

<br><br><br>

#### 제한 사항 및 권한

- 시스템 오버레이와 같은 특정 유형의 윈도우에는 SYSTEM_ALERT_WINDOW와 같은 특별한 사용자 권한이 필요함
- 안드로이드 8.0부터 시스템은 보안상의 이유로 오버레이 윈도우에 대한 더 엄격한 제한을 부과함

<br><br><br>

### Q48.) 웹 페이지를 어떻게 렌더링하나요?

- WebView는 앱 내에서 직접 웹 콘텐츠를 표시하고 상호 작용할 수 있는 유용한 안드로이드 컴포넌트임
- 어플리케이션에 내장된 미니 브라우저 역할을 하여 개발자가 웹 페이지를 렌더링하고, HTML 콘텐츠를 로드하거나, JavaScript를 직접적으로 실행할 수 있도록 함
- 앱이 실행 중인 기기에서 최신 WebView 기능을 안전하게 활용하려면 Android Webkit 라이브러리를 사용해야 함.
- 이 라이브러리는 이전 버전과 호환되는 API를 제공하여 기기의 안드로이드 버전에 관계없이 최신 기능에 접근할 수 있도록 보장함

<br><br><br>

#### WebView 초기화하기

- WebView를 사용하려면 레이아웃 파일에 포함하거나 코드로 직접 생성할 수 있음.

```xml
<WebView
    android:id="@+id/webView" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" />
```

- 필요한 경우 코드로 직접 생성할 수도 있음.

```kotlin
val webView = WebView(this)
setContentView(webView)
```

<br><br><br>

#### 웹 페이지 로드하기

- 웹 페이지를 로드하려면 WebView 인스턴스에서 loadUrl() 메서드를 사용함.
- 페이지가 인터넷 접근을 요구하는 경우 안드로이드 메니페스트에서 필요한 권한을 활성화 해야함.

<br><br><br>

#### JavaScript 활성화하기

- 웹 콘텐츠가 JavaScript를 요구하는 경우 Webettings를 수정하여 활성화함

<br><br><br>

#### WebView 동작 커스텀하기

- WebView는 이벤트를 처리하고 동작을 커스텀하는 메서드를 제공함

- 페이지 네비게이션 가로채기 : 외부 브라우저에서 열지 않고 WebView 내에서 페이지 네비게이션을 처리하려면 webViewclient를 사용해야 함

```kotlin
webView.webViewClient = object : WebViewClient() {
    // API 24 미만 버전 호환성
    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
        url?.let { view?.loadUrl(it) }
        return true // WebView가 URL 로딩을 처리함을 나타냄
    }

    // API 24 이상 버전
    override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceReq\ uest?): Boolean {
        request?.url?.let { view?.loadUrl(it.toString()) }
        return true
    } 
}
```


- 다운로드 처리하기 : WebView를 통해 다운로드되는 파일을 관리하려면 DownladListener를 활용할 수 있음

```kotlin
webView.setDownloadListener { url, userAgent, contentDisposition, mimeType, contentLength ->
    // 여기서 파일 다운로드 처리 (Ex DownloadManager 사용)
    val request = DownloadManager.Request(Uri.parse(url))
    // ... (DownloadManager 설정) ...
    val downloadManager = getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    downloadManager.enqueue(request)
}
```

- WebView에서 Javascript 실행하기 : evalutateJavaScript 또는 LoadUrl("javascript:...")을 사용하여 JavaScript 코드를 주입함

```kotlin
webView.evaluateJavascript("document.body.style.backgroundColor = 'red';") { result‐>
    Log.d("WebView", "JavaScript 실행 결과: $result")
}

//이전방식(결과받기어려움)
// webView.loadUrl("javascript:document.body.style.backgroundColor = 'blue';")
```

<br><br><br>

#### JavaScript를 안드로이드 코드에 바인딩하기 위한 포괄적인 가이드

- JavaScript와 안드로이드 코드를 통합하면 클라이언트 측 스크립트와 안드로이드 네이티브 기능 간의 원활한 상호 작용을 허용하여 하이브리드 웹 애플리케이션을 향상시킬 수 있음.
- 특히, 안드로이드 앱 내 WebView에서 실행되는 웹 애플리케이션에 유용하며, JavaScrip가 안드로이드 특정 기능을 활용할 수 있도록 함.
- 예를 들어, JavaScript의 alert() 함수에 의존하는 대신 네이티브 안드로이드 다이얼로그나 토스트 메시지를 트리거할 수 있음.
- 이 상호작용을 구현하려면 addJavaScriptInterface() 메서드를 사용해야 함.
- 해당 메서드는 Java 객체를 WebView의 JavaSCript 컨텍스트에 바인딩하여 인터페이스 이름을 지정함으로써 JavaScript를 통해 해당 메서드에 접근할 수 있도록 함.
- JavaScript를 안드로이드에 바인딩하는 예제를 통해서 살펴볼 수 있음.

<br><br><br>

### Q49.) AppCaompat 라이브러리란 무엇인가요?

- AppCompat 라이브러리는 개발자가 하위 버전의 안드로이드와의 호환성을 유지하는 데 도움이 되도록 설계된 Android Jetpack의 일부임.

1. UI 컴포넌트 하위 호환성 : AppCompat 라이브러리는 FragmentActivity를 확장하고 하위 버전의 안드로이드와의 호환성을 보장하는 AppCompatActivity와 같은 최신 UI 컴포넌트를 제공함.

2. Material Design 지원 : AppCompat을 사용하면 개발자는 하위 안드로이드 버전을 실행하는 기기에 Material Design 원칙을 통합할 수 있다.

3. 테마 및 스타일링 지원 : AppCompat을 사용하면 Theme.AppCoompat과 같은 테마를 사용하여 모든 API 레벨에서 일관된 UI를 보장할 수 있다.

4. 동적 기능 지원 : AppCompat 라이브러리는 동적 리소스 로딩 및 벡터 드로어블 지원을 제공하여 하위 호환성을 유지하면서 최신 디자인 요소를 효율적으로 구현하기 쉽게 만든다.

<br><br><br>

#### AppCompat을 사용하는 이유

- AppCompat을 사용하는 주된 이유는 최신 안드로이드 기능과 UI 컴포넌트ㅏ 지원되는 모든 API 레벨에서 일관되게 작동하도록 보장하는 것.
- 개발자가 최신 기능이 풍부한 앱을 구축하는 데 집중할 수 있도록 하면서, 하위 버전의 안드로이드 기기에서의 호환성을 유지하기 위한 복잡성을 줄여줌

<br><br><br>

#### 실전 질문

Q) AppCompat 라이브러리는 하위 안드로이드 버전에서 Material Design 지원을 어떻게 가능하게 하며, 이와 같은 동작을 기반으로 하는 주요 UI 컴포넌트에는 무엇이 있나요?
A) 기기의 API 레벨에 따라 모양과 동작을 자동으로 조정하는 위젯이 제공되며 이에는 AppCompatButton, AppCompatTextView 등이 있음.

<br><br><br>

### Q50.) Material Design Components (MDC)란 무엇인가요?

- Material Design Components (MDC)는 Google의 Material Design 가이드라인을 기반으로 하는 커스텀 가능한 UI 위젯 및 컴포넌트 집합임
- 해당 컴포넌트는 개발자가 앱의 브랜딩 및 디자인 요구사항에 맞게 모양과 동작을 커스텀할 수 있도록 하면서 일관되고 사용자 친화적인 인터페이스를 제공하도록 설계되었음.

<br><br><br>

#### Material Design Components의 주요 특징

1. Material Theming : MDC는 Material Theming을 통해 테마 설정을 지원하여 개발자가 타이포그래피, 모양 및 색상을 전역적으로 또는 컴포넌트 수준에서 커스텀할 수 있도록 함. 이를 통해 앱 전체에서 일관성을 유지하면서 UI를 브랜드 아이덴티티에 쉽게 맞출 수 있음.

2. 미리 빌드된 UI 컴포넌트 : MDC는 버튼, 카드, 앱 바, 네비게이션 드로어, 칩 등과 같이 즉시 사용할 수 있는 광범위한 UI 컴포넌트를 제공함. 이러한 컴포넌트는 접근성, 성능 및 반응성에 최적화 되어있음.

3. 애니메이션 지원 : Material Design은 모션 및 전환을 강조함. MDC에는 공유 요소 전환, 리플 효과 및 시각적 피드백과 같은 애니메이션에 대한 내장 지원이 포함되어 사용자 상호작용을 향상시킴.

4. 다크모드 지원 : 해당 라이브러리에는 다크 모드를 쉽게 구현할 수 있는 API가 포함되어 있어 개발자가 시각적 일관성을 보장하면서 라이트 및 다크 모드에 대한 테마를 정의할 수 있음.

5. 접근성 : MDC는 더 큰 터치 대상, 접근성을 위한 sementic 레이블 및 적절한 포커스 관리와 같은 기능을 제공하여 접근성 표준을 준수하여 모든 사용자를 위한 포괄저긴 UI를 보장함.

<br><br><br>

#### 실전 질문

Q) MDC의 Material Theming은 앱 전체에서 디자인 일관성을 유지하는 데 어떻게 도움이 되나요?
A) MDC는 Material Theming을 통해 테마 설정을 지원하여 개발자가 타이포그래피, 모양 및 색상을 전역적으로 또는 컴포넌트 수준에서 커스텀할 수 있도록 함. 이를 통해 앱 전체에서 일관성을 유지하면서 UI를 브랜드 아이덴티티에 쉽게 맞출 수 있음.

<br><br><br>

### Q51.) ViewBinding을 사용하면 어떤 장점이 있나요?

- ViewBinding은 레이아웃 뷰와 상호 작용하는 프로세스를 단순화하기 위해 안드로이드에서 도입된 기능.
- 수동으로 findViewById()를 호출하지 않아도 되고, 뷰에 접근하는 타입-세이프 방식을 제공하여 보일러 플레이트 코드를 줄이고 잠재적인 런타임 오류를 최소화함.

<br><br><br>

#### ViewBinding 작동 방식

- 프로젝트에서 ViewBinding을 활성화하면 안드로이드는 각 xml 레이아웃 파일에 대한 바인딩 클래스를 생성함.
- 생성된 바인딩 클래스의 이름은 레이아웃 파일 이름에서 파생되며, 각 밑줄은 카멜 케이스로 변환되고 이름 끝에 Binding이 추가됨. 예를 들어, 레이아웃 파일 이름이 activity_main.xml이만 MainActivityBinding이 됨.

<br><br><br>

#### ViewBinding의 장점

- 타입 안정성 : 캐스팅할 필요 없이 뷰에 직접 접근하여 타입 불일치로 인한 런타임 오류를 제거함
- 더 깔끔한 코드 : findViewById()를 호출할 필요가 없어지고 보일러 플레이트 코드가 줄어듬
- Null 안정성 : Nullable 타입의 뷰를 자동으로 처리하여 선택적 UI 컴포넌트와 상호작용할 때 더 안전한 코드를 보장함.
- 성능 : DataBinding과 달리 ViewBinding은 바인딩 표현식이나 추가 XML 파싱을 사용하지 않으므로 런타임 오버헤드가 최소화됨.

<br><br><br>

#### DataBinding과의 비교

- DataBinding은 바인딩 표현식 및 양방향 데이터 바인딩과 같은 더 많은 기능을 제공하지만 더 복잡하고 런타임 오버헤드를 유발함.
- 반면에 ViewBinding은 순수하게 뷰 상호 작용 단순화에 중점을 두며 성능 면에서 더 가벼움.
- LiveData나 Flow등을 바인딩하여 데이터를 직접적으로 결합하는 등과 같은 기능이 필요하지 않는 경우에 이상적임.

<br><br><br>

#### 실전 질문

Q) ViewBInding은 findViewById()와 비교하여 타입 안정성과 null 안정성을 어떻게 개선하며, 해당 접근 방식의 이점은 무엇인가요?
A) 캐스팅할 필요 없이 자동으로 View를 바인딩하여 객체로 제공해서 더 안전한 코드를 작성할 수 있으며, 보일러 플레이트가 없어짐.