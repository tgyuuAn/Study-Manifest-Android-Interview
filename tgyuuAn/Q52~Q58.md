### Q52.) DataBinding의 동작 원리에 대해서 설명해주세요.

- Databinding은 XML 레이아웃의 UI 컴포넌트를 앱의 데이터 소스에 직접 바인딩할 수 있는 안드로이드 라이브러리임.
- findViewById()와 같은 보일러 플레이트 코드를 줄이고 UI 디자인에 선언적 프로그래밍을 부분적으로 가능하게 함.
- 이 개념은 UI 로직과 비즈니스 로직 분리를 위한 디자인 패턴으로 Microsoft에서 시작된 MVVM 아키텍처에서 중심적인 역할을 함

<br><br><br>

#### DataBinding 작동방식

- Databinding은 <layout> 태그를 사용하는 각 xml 레이아웃에 대한 바인딩 클래스를 생성함.
- 이 클래스는 뷰에 대한 직접적인 접근을 제공하고 표현식을 사용하여 xml에서 직접 데이터를 바인딩할 수 있음.

<br><br><br>

#### DataBinding의 특징

- 양방향 데이터 바인딩 : UI와 기본 데이터 모델 간의 데이터 자동 동기화를 가능하게 함. 입력 필드 값을 업데이트 하는 등에 특히 유용함.
- 바인딩 표현식 : 문자열 연결 또는 조건문과 같은 간단한 로직을 xml에서 직접 사용할 수 있음.
- 생명주기 인식 : 생명주기가 적절한 상태일 때만(가령, Activity 또는 Fragment가 활성 상태일 때) UI를 자동으로 업데이트 함. (LiveData 또는 StateFlow와 함께 사용할 때)

<br><br><br>

#### DataBinding의 장점

- 보일러 플레이트 코드 감소 : findViewById() 및 명시적인 UI 업데이트가 필요 없어짐.
- 실시간 UI 업데이트 : 데이터 변경 사항을 UI에 자동으로 반영함.
- 선언적 UI : 로직을 xml로 이동하여 잘 사용하면 복잡한 레이아웃을 단순화할 수 있음.
- 테스트 용이성 향상 : UI와 코드를 분리하여 둘 다 독립적으로 테스트하기 쉽게 만듬.

<br><br><br>

#### DataBinding의 단점

- 성능 오버헤드 : ViewBinding과 같은 더 가벼운 솔루션에 비해 더 많은 런타임 오버헤드가 발생함.
- 복잡성 : 작거나 간단한 프로젝트에는 불필요한 복잡성을 유발할 수 있음.
- 학습 곡선 : 바인딩 표현식 및 생명주기 관리에 대한 러닝 커브가 요구됨.

<br><br><br>

#### 실전 질문

Q) DataBinding과 ViewBinding의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 선택하는 것이 좋을까요?
A) DataBinding은 양방향 연결이 지원되고, xml 상으로 ViewModel의 LiveData나 StateFlow와 직접적으로 연결되기 때문에 ViewBinding에 비해서 Acitivty나 Fragment코드가 간단해짐. 하지만 ViewBinding보다 리소스가 많이 드는 작업이므로 더 무거움. ViewBinding은 간단한 연결 작업에서 용이함.

Q) MVVM 아키텍처에서 DataBinding은 어떤 역할을 하며, 안드로이드 개발에서 UI 로직과 비즈니스 로직을 분리하는 데 어떻게 활용할 수 있나요?
A) 비즈니스 로직(ViewModel)은 UI로직에 대한 의존성이 없으며, Ui로직만이 비즈니스 로직에 대한 의존성으로 이를 해결함. UI로직은 비즈니스 데이터를 옵저빙하여 UI를 갱신하는 방식으로 이를 해결함.

<br><br><br>

#### ViewBinding과 DataBinding의 주요 차이점

1. 목적 : ViewBinding은 뷰 접근을 단순화하는 반면, DataBinding은 고급 데이터 기반 UI 바인딩을 가능하게 함.
2. 컴파일 타임 클래스 생성 : ViewBinding은 뷰에 대한 직접 참조를 생성, DataBinding  은 뷰에 대한 직접 참조뿐만 아니라, 내장 데이터 바인딩 기능이 있는 추가 클래스도 생성함.
3. 표현식 : ViewBinding은 xml에서 표현식을 지원하지 않지만, DataBinding은 표현식과 동적 바인딩을 지원함.
4. 양방향 바인딩 : DataBinding만 양방향 바인딩을 지원함.
5. 성능 : ViewBinding은 데이터 바인딩 로직을 처리하지 않으므로 더 빠르고 오버헤드가 적음.

<br><br><br>

### Q53.) LiveData에 대해서 설명해 주세요.

- LiveData는 안드로이드 Jetpack 아키텍처 컴포넌트에서 제공하는 관찰 가능한 데이터 홀더 클래스임.
- 이는 생명주기를 인식하므로 Activity, Fragment, View와 같이 연관된 안드로이드 컴포넌트의 생명주기에 따라 동작이 달라짐. 따라서, LiveData는 연관된 컴포넌트가 활성 생명주기 상태(Started, Resumed) 일 때만 데이터를 관찰하고 UI를 업데이트하도록 보장함.
- LiveData의 주요 목적은 UI 컴포넌트가 데이터 변경 사항을 관찰하고 해당 데이터가 변경될 때마다 UI를 반응형으로 업데이틓라 수 있도록 하는 것임.

<br><br><br>

#### LiveData의 장점

1. 생명주기 인식 : LiveData는 컴포넌트의 생명주기를 관찰하고 컴포넌트가 활성 상태일 때만 데이터를 업데이트하여 크래시 및 메모리 누수 위험을 줄임.
2. 자동 정리 : 컴포넌트에 연결된 관찰자는 주어진 생명주기가 소멸될 때 자동으로 제거되고 정리됨.
3. 관찰자 패턴 : UI 컴포넌트는 관찰자를 활용하여 LiveData의 데이터가 변경될 때 자동으로 업데이트됨.
4. 스레드 안정성 : LiveData는 스레드 안전하도록 설계되어 백그라운드 스레드에서 업데이트할 수 있음.

<br><br><br>

#### LiveData 사용 사례

1. UI 상태 관리 : LiveData는 네트워크 응답이나 데이터베이스와 같은 소스의 데이터를 담는 컨테이너 역할을 하여 UI 컴포넌트에 원활하게 바인딩될 수 있도록 함., 이를 통해 기본 데이터가 변경될 때마다 UI가 자동으로 업데이트되어 인터페이스가 앱 상태와 동기화되도록 보장함.
2. 관찰자 패턴 구현 : LiveData는 발행자 역할을 하고, Observer 인터페이스 구현이 구독자 역할을 하는 관찰자 패턴을 따름. 이 디자인 패턴은 LiveData 값이 변경될 때마다 구독자에게 실시간 업데이트를 용이하게 하여 동적 UI 업데이트나 데이터 기반 상호 작용과 같은 시나리오에 매우 적합함.
3. 일회성 이벤트 : 토스트를 노출시키거나 다른 화면으로 이동하는 one-off 일회성 이벤트에도 사용될 수 있음. 단, 이러한 경우는 SingleLiveEvent 또는 유사한 구현으로 커스텀하여 처리해야 함.

#### 실전 질문

Q) LiveData는 생명주기 인식을 어떻게 보장하며, RxJava 또는 EventBus와 같은 전통적인 observable한 객체와 비교하여 어떤 이점을 제공하나요?
A) RxJava와 EventBus는 명시적으로 생명주기에 맞춰서 collect를 멈춰야하지만, LiveData는 Observe할 때 LifecycleOwner를 넣어주기 때문에 자동으로 처리해줌,

Q) LiveData에서 setValue()와 postValue()의 차이점은 무엇이며, 각각 언제 사용해야하나요?
A) setValue()는 메인스레드에서만 호출 가능, 순차적으로 값을 업데이트 ,postValue()는 백그라운드 스레드에서 값을 업데이트할 수 있으며, 이 경우 메인 스레드에서의 값 업데이트를 예약하는 것임.

Q) LiveData의 한계는 무엇이며, 구성 변경 시 다시 트리거되지 않고 네비게이션 또는 토스트 메시지 표시와 같은 여러 UI 이벤트를 관찰해야 하는 경우에 어떻게 처리해야 하나요?
A) StateFlow의 역할만 할 수 있으모 단발성 이벤트를 표현하기 위해서는 SingleLiveEvent라는 별도로 커스텀한 래핑 클래스를 사용해야 함.

<br><br><br>

### Q54.) Jetpack ViewModel에 대해 설명해 주세요,

- Jetpack ViewModel은 생명주기를 인식하는 방식으로 UI 관련 데이터를 저장하고 관리하도록 설계된 안드로이드 아키텍처 컴포넌트의 핵심 구성 요소임.
- 화면 회전과 같은 구성 변경 시에도 데이터가 유지되도록 보장하면서 UI 로직과 비즈니스 로직을 분리하여 개발자가 견고하고 유지 관리 가능한 앱을 만드는 데 도움을 줌.
- ViewModel의 주요 목표는 구성 변경 중에 UI 관련 데이터를 보존하는 것임. ex) 기기 회전, Light<-> Dark 등

<br><br><br>

#### ViewModel의 특징

1. 생명주기 인식 : ViewModel은 Activity 또는 Fragment의 생명주기에 범위가 지정됨. 사용자가 화면에서 벗어나는 등 연관된 UI 컴포넌트가 더 이상 사용되지 않을 때 자동으로 소멸됨.
2. 구성 변경 간 지속성 : 구성 변경 중에 소멸되고 다시 생성되는 Activity 또는 Fragment와 달리 ViewModel은 상태를 유지하여 데이터 손실을 방지하고 데이터의 반복적인 재로드를 피함.
3. 관심사 분리 : ViewModel은 UI 관련 로직과 비즈니스 로직을 분리하여 더 깔끔하고 유지 관리하기 쉬운 코드를 설계하는 데 도움이 됨. UI 레이어는 ViewModel에서 업데이트를 관찰하므로 반응형 프로그래밍 원칙을 구현하기가 더 쉬워짐.

<br><br><br>

#### 실전 질문

Q) ViewModel은 구성 변경 시 데이터를 어떻게 유지하며, onSaveInstanceState()를 사용하여 상태를 저장하는 것과 어떻게 다른가요?
A) ViewModel은 Activity, Fragment, NavBackStackEntry와 같은 ViewModelStoreOwner에 의해 ConfigurationChanged에도 살아남는 객체에 저장되며, 다시 onCreate() 되었을 때 ViewModelStore에 저장된 객체 그대로를 들고옴. onSaveInstanceState()는 Bundle형태로만 데이터를 저장할 수 있으며, 객체를 저장하고 가져올 때에는 직렬화/역직렬화를 거쳐야 함.

Q) ViewModelStoreOwner의 목적은 무엇이며, 동일한 Activity 내의 여러 Fragment 간에 ViewModel을 어떻게 공유할 수 있나요?
A) Activity 범위의 ViewModel을 하나 만들고, 각 Fragment에서는 activityViewModels()로 생성하면 동일한 ViewModel에 접근할 수 있음.

Q) UI 상태 관리를 위해 ViewModel 내에서 StateFlow 또는 LiveData를 사용하는 것의 장점과 잠재적인 단점은 무엇인가요?
A) UI <-> 비즈니스 양방향 의존성을 UI -> 비즈니스 단방향 의존성으로 끊어낼 수 있음. StateFlow를 사용하게 되면 생명주기에 맞춰서 구독과 해제를 잘 해주어야 하며, LiveData를 사용할 경우 안드로이드 프레임워크 의존성이 생기게 됨.

<br><br><br>

#### ViewModel의 생명주기는 어떻게 되나요?

- ViewModel의 생명주기는 ViewModelStoreOwner에 연결됨. ViewModel은 ViewModelStoreOwner의 범위 내에서 존재하며, 화면 회전과 같은 구성 변경 시에도 데이터와 상태가 유지되도록 보장함.
- ViewModel은 ViewModelStoreOwner가 영구적으로 소멸될 때 비로소 제거됨. Activitt가 완료되거나 Fragment가 부모에서 제거되고 돌아올 것으로 예상되지 않으면 viewModel의 onCleared() 메서드가 호출됨. 이 떄, 코루틴 작업의 취소나 데이터 베이스 연결을 끊는 등과 같이 리소스를 정리하여 메모리 누수를 방지하기 할 때 유용함.

<br><br><br>

### Q55.) Jetpack Navigation 라이브러리란 무엇인가요?

- Jetpack Navigation 라이브러리는 앱 내 네비게이션을 단순화하고 표준화하기 위해 안드로이드에서 제공하는 프레임워크임.
- 개발자가 선언적으로 다양한 앱 화면 간의 네비게이션 경로와 전환을 정의할 수 있도록 하여 보일러 플레이트 코드를 줄이고 전반적인 사용자 경험을 향상시킴.
- 해당 라이브러리는 Activity, Fragment, Composable에 대한 네비게이션을 관리하는 API를 제공하며, 딥 링크, 백 스택 관리 및 애니메이션과 같은 추가적인 기능도 지원함.

<br><br><br>

#### 네비게이션 그래프 (Navigation graph)

- 네비게이션 그래프는 앱 대상(화면) 간의 네비게이션 흐름과 관계를 정의하는 xml 리소스임.
- 각 대상은 Fragment Activity 또는 커스텀 뷰와 같은 화면을 나타내고 동작의 목적지 등을 정의함.

<br><br><br>

#### NavhostFragment

- NavhostFragment는 네비게이션 그래프의 컨테이너 역할을 하여 대상을 호스팅하고 대상 간의 네비게이션을 관리함.
- 사용자가 탐색할 때 컨테이너 내에서 Fragment를 동적으로 교체함.

<br><br><br>

#### NavController

- NavController는 네비게이션 작업을 처리하고 백 스택을 관리하는 역할을 함.
- 이를 사용하여 직접 코드로 목적지 간에 이동하거나 전반적인 네비게이션 흐름을 컨트롤할 수 있음.
- 이름에서 알 수 있듯이, 말 그대로 네비게이션의 컨트롤러임.

<br><br><br>

#### SafeArgs

- SafeArgs는 타입-세이프(type-safe) 네비게이션 및 인수 전달 코드를 생성하는 Gradle 플러그인임.
- 대상 간 데이터를 전달할 때 수동으로 번들을 만들 필요가 없음.

<br><br><br>

#### Deep Linking

- 이 라이브러리는 딥 링크를 지원하여 사용자가 url이나 알림과 같은 외부 소스에서 특정 화면으로 직접 이동할 수 있도록 함.

<br><br><br>

#### 실전 질문

Q) Jetpack Navigation 라이브러리는 백 스택을 어떻게 처리하고, NavController로 어떻게 백스택을 조작할 수 있나요?
A) NavController가 내부적으로 NavBackStackEntry 리스트를 관리하여 백 스택을 처리함.
```kotlin
// NavController의 백 스택 구조
NavController {
    backStack: ArrayDeque<NavBackStackEntry> = [
        NavBackStackEntry(HomeFragment),
        NavBackStackEntry(DetailFragment),
        NavBackStackEntry(ProfileFragment) // 현재 화면
    ]
}
```

Q) Safe Arguments란 무엇이며, Jetpack Navigation Component에서 목적 내비게이션 간 데이터를 전달할 때 타입 안전성을 어떻게 보장하나요?
A) Navigation Graph에 정의해놓은 Argument들이 있는 클래스를 자동으로 생성하고, 컴파일 시점에 타입을 체크함.

<br><br><br>

### Q56.) Dagger2와 Hilt의 동작원리 및 차이점에 대해서 설명해 주세요.

- 아늗로이드 개발을 위한 의존성 주입 라이브러리에는 다양한 선택지가 있으며, 그중 Dagger2와 Hilt가 가장 대표적인 옵션으로 꼽힘. 두 라이브러리 모두 Google에서 개발하고 공식적으로 지원할 뿐만 아니라, 대규모 프로젝트에서 사용성이 많이 검증되었기 떄문에 신뢰할 수 있는 선택임.

<br><br><br>

#### Dagger2란?

- Dagger2는 안드로이드 및 JVM 환경을 위한 정적 컴파일 타임 기반의 의존성 주입 라이브러리임
- 객체 생성을 관리하고 의존성을 자동으로 제공하여 모듈성을 개선하고 애플리케이션 테스트를 용이하도록 설계되었음.
- Dagger2는 컴파일 타임에 코드를 생성하여, 리플렉션에 기반한 DI 프레임워크에 비해 더 나은 성능을 보장함.
- Dagger2는 @Module, @Provides, @Inject와 같은 어노테이션을 사용하여 의존성을 선언하고 요청함.
- 개발자는 컴포넌트와 모듈을 통해 의존성 그래프를 생성하며, Dagger2는 런타임에 이를 자동으로 해결함.

<br><br><br>

```kotlin
class NetworkModule {
     @Provides
     fun provideRetrofit(): Retrofit { 
        return Retrofit.Builder()
            .baseUrl("https://example.com")
            .build()
     }
}

@Component(modules = [NetworkModule::class]) 
interface AppComponent {
    // MainActivity에 의존성 주입
    fun inject(activity: MainActivity) 
}

class MainActivity : AppCompatActivity() { 
    // Retrofit 의존성 주입 요청
    @Inject
    lateinit var retrofit: Retrofit
    
    override fun onCreate(savedInstanceState: Bundle?) { 
        super.onCreate(savedInstanceState)
        // Dagger 컴포넌트 생성 및 주입 실행 
        DaggerAppComponent.create().inject(this)
        // 이제 retrofit 인스턴스 사용 가능
    } 
}
```

<br><br><br>

#### Hilt란 무엇인가?

- Hilt는 Dagger2 위에 구축된 안드로이드 전용 의존성 주입 라이브러리임.
- Activity, Fragment, ViewModel과 같이 안드로이드 생명주기와 밀접한 관련이 있는 클래스에 스코프가 지정된 사전 정의된 컴포넌트를 제공하여, Dagger를 안드로이드 프로젝트에 통합하는 프로세스에 전체적으로 단순화함.
- Hilt는 @HiltAndroidApp 및 @AndroidEntryPoint와 같은 어노테이션을 제공하여 DI 설정을 간소화함으로써 Dagger2에 필요한 많은 보일러 플레이트 코드를 제거함. 
- @Singleton 및 @ActivityScoped와 같은 범위를 정의하여 의존성 생명주기를 관리함.
- 그렇기에 Hilt로 구현이 가능한 것은 Dagger2로도 모두 구현이 가능함.

<br><br><br>

#### Dagger2 기반의 어노테이션 (Dagger에서 제공하고 Hilt에서도 사용)

1. @Inject : 의존성 주입을 위해 생성자, 필드 또는 메서드에 표시함. 의존성 주입을 실질적으로 요청하는 데 사용
2. @Provides : @Module 내에서 의존성 생성 메서드를 정의함. Hilt와 Dagger 모두 이 어노테이션을 사용하여 객체를 제공함.
3. @Module : 클래스를 의존성 제공자 컨테이너로 선언함. 모듈은 관련된 의존성 생성 로직을 그룹화함.
4. @Binds : @Module 내에서 인터페이스를 구현에 매핑하는 데 사용되어 의존성 정의 시 보일러 플레이트 코드를 줄임.
5. @Qualifier : 커스텀 어노테이션을 사용하여 동일한 타입에 대해 여러 의존성 바인딩을 구별함.
6. @Scope : 특정 의존성의 생명주기를 제어하기 위해 커스텀 스코핑 어노테이션을 정의할 수 있음.
7. @Singleton : 의존성이 해당 범위 (일반적으로 앱 생명주기) 내내 단일 공유 인스턴스를 가져야 함을 지정
8. @Component : 의존성 그래프의 인터페이스를 정의함. @Component는 모듈을 주입 대상에 연결하고 의존성 생명주기를 제어함
9. @SubCompoinent : 지정한 범위 내에서 의존성을 관리하기 위한 케이스를 위해 @Component 내에 더 작은 의존성 그래프를 생성함. 종종 자체 생명주기를 가진 자식 컴포넌트를 만드는 데 사용됨.

<br><br><br>

#### Hilt에 특화된 어노테이션

1. @HiltAndroidApp : Hilt를 부트스트랩하고 전체 앱에 대한 의존성 그래프를 생성하기 위해 사용함. Application 클래스에 사용할 수 있고, Hilt를 초기화 하기 위한 필수 어노테이션임.
2. @AndroidEntryPoint : 안드로이드 컴포넌트(가령, Activity, Fragment, Service)를 주입 대상으로 마크함. 해당 어노테이션을 사용하는 것만으로도 커스텀 Dagger 컴포넌트를 정의할 필요가 없어짐.
3. @InstallIn : @Module이 설치되어야 하는 컴포넌트(가령, SingletonComponent, ActivityComponent)를 지정함
4. @EntryPoint : Hilt에서 관리하는 안드로이드 컴포넌트가 아닌 외부에서 의존성에 접근하기 위한 진입점을 정의하는 데 사용함.
5. @HiltViemodel : Jetpack ViewModel을 Hilt와 통합하기 위한 특수 어노테이션임. ViewModel이 생명주기를 인식하면서 Hilt의 의존성 주입을 사용할 수 있도록 보장함. @HiltViewModel 어노테이션은 생성자에 @Inject와 함께 사용해야 함.
6. Scope Annotation(@ActivityRetainedScoped, @ViewModelScoped) : 사용자가 컴포넌트를 수동으로 정의하고 인스턴스화하는 순수 Dagger와 달리, Hilt는 사전 정의된 컴포넌트를 제공하여 특정 라이프 사이클에 의존성을 바인딩하는 프로세스를 단순화함. Hilt에는 Hilt에 특화된 컴포넌트 뿐만 아니라, 스코프 지정 어노테이션들이 포함되어 있어 의존성 주입을 더 간소화하고 안드로이드 생명주기에 따라 의존성을 관리하기 쉽도록 함.

<br><br><br>

#### 실전 질문

Q) Dagger2와 비교하여 의존성 Hilt는 주입을 어떻게 단순화하고, 안드로이드 애플리케이션에서 Hilt를 사용하는 것의 장점은 무엇인가요?
A) Dagger2를 사용하는 것에 비해 Hilt는 커스텀 Component와 같은 보일러 플레이트 코드들을 작성할 필요가 없고, HiltViewModel과 같이 안드로이드 생명주기에 맞춰서 의존성을 주입할 수 있도록 Dagger2위에 구축되어 있음.

Q) Dagger와 Hilt에서 @Provides와 @Binds의 차이점은 무엇이고, 각각 언제 사용해야 하나요?
A) Binds는 Interface에 한해서만 사용할 수 있으며 Binds의 경우 생성하는 방법을 직접 명시해주지 않아도 됨. 반면, Provides는 외부 모듈과 인터페이스 모두 생성할 수 있으며, Hilt Module에 해당 객체를 생성하는 방법을 명시해주어야 함.

Q) Hilt에서 @Singleton, @ActivityScoepd, @ViewModelScoped를 사용하면 내부적으로 스코핑이 어떻게 작동하는 지 매커니즘을 설명하고, 해당 스코프가 사용되면 애플리케이션 내 의존성의 수명을 어떻게 관리하는 지 설명해주세요.
A) 

<br><br><br>

#### Dagger2 및 Hilt이외에 알고 있는 DI 라이브러리가 있나요?

- Dagger2와 Hilt는 구글에서 권장되기 때문에 안드로이드에서 가장 보편적으로 사용되는 의존성 주입이지만, Kotin, Anvil과 같이 DI 구현을 다른 접근 방식으로 제공하는 라이브러리가 있음.

<br><br><br>

#### Koin : 가볍고 사용하기 쉬운 DI 라이브러리
- 단순성을 염두에 두고 설계된 경량 의존성 주입 라이브러리
- 어노테이션, 컴파일 타임의 코드 생성 또는 무거운 보일러 플레이트 코드의 필요성을 없애고 Kotlin DSL을 사용하여 의존성 모듈을 정의하는 데 중점을 둠

- Koin의 주요 특징은 아래와 같음
- 어노테이션 처리 없음 : 의존성은 Kotlin 코드로 정의되어 어노테이션 처리를 피하고 비륻 시간을 단축함
- Kotlin 우선 접근 방식 : Kotlin DSL을 사용하여 DI 구성을 매우 읽기 쉽고 직관적으로 만듬
- 사용 편의성 : 설정이 빠르고 소규모 프로젝트 또는 빠른 DI 환경 셋업을 추구하는 개발자에게 이상적임
- 동적 해결 : 런타임 시 의존성이 결정되는 시나리오에 유용한 동적 의존성 솔루션을 지원함

<br><br><br>

#### Anvil : Daggeer2에 기반한 컴파일러 플러그인

- Anvil은 Block에서 개발한 Dagger 컴파일러 플러그인임. 
- 특히 Dagger를 많이 사용하는 프로젝트의 경우 모듈 생성을 위한 보일러 플레이트 코드를 단순화하여 Dagger의 사용성을 향상시킴. 
- 내부적으로는 Hilt와 매우 유사하게 작동함.
- Anvil은 팩토리 및 모듈 코드 생성을 간소화하여 초기 Dagger의 셋업 비용을 줄임

<br><br><br>

### Q57.) Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?

- Jetpack Paging 라이브러리는 대규모 데이터 셋을 청크 또는 "페이지" 단위로 로드하고 표시하는 프로세스를 돕도록 설계된 안드로이드 아키텍처 컴포넌트임. 데이터베이스나 API와 같은 소스에서 데이터를 효율적으로 가져와야 하는 애플리케이션에 특히 유용하며, 메모리 사용량을 최소화하고 RecyclerView 기반 UI의 전반적인 성능을 향상시킴.

<br><br><br>

#### Paging 라이브러리의 구성 요소

1. PagingData : 점진적으로 로드되는 데이터 스트림을 나타냄. RecyclerView와 같은 UI 컴포넌트에 의해 관찰되고 사용될 수 있음.
2. PagingSource : 데이터 소스에서 데이터가 로드되는 방식을 정의하는 역할을 함. 위치 또는 ID와 같은 키값을 기반으로 데이터 페이지를 로드하는 메서드를 제공함.
3. Pager : PagingSource와 PagingData 간의 중개자 역할을 함. PagingData 스트림의 생명주기를 관리함.
4. RemoteMediator : 로컬 캐싱과 원격 API 데이터를 결합할 때 경계 조건을 구현하는 데 사용함.

<br><br><br>

#### Paging 라이브러리 작동 방식

- Paging 라이브러리는 데이터를 페이지로 분할하여 효율적인 데이터 로딩을 가능하게 함.
- 사용자가 RecyclerView를 스크롤하면 필요에 따라 새 데이터 페이지를 가져와 최소한의 메모리 사용량을 보장함.
- 이 라이브러리는 Flow 또는 LiveData를 기본적으로 지원하여 데이터 변경 사항을 관찰하고 그에 따라 UI를 업데이트할 수 있도록 함

1. PagingSource를 정의하여 데이터 가져오는 방법을 지정함
2. Pager를 사용하여 PagingData의 Flow를 생성함.
3. ViewModel에서 PagingData를 관찰하고 RecyclerView에서 렌더링하기 위해 PagingDataAdapter에 전달함.

<br><br><br>

#### 실전 질문

Q) Paging 라이브러리는 데이터 로딩 중 오류를 어떻게 처리하며, 페이지네이션된 데이터 흐름에서 오류 처리 및 재시도 메커니즘을 구현하기 위해 사용해 본 전략은 무엇인가요?

<br><br><br>

### Q58.) Baseline Profile은 앱의 성능에 어떤 이점을 가져다주나요?

- BaselineProfiles는 앱 시작 시간과 런타임 실행을 최적화하기 위한 안드로이드 앱의 성능 향상을 위한 플러그인.
- BaselineProfiles는 미리 컴파일된 코드 정보를 제공함으로써 코드 해석 및 JIT 컴파일 단계를 우회하고 더 빠른 앱 실행을 가능하게 함.
- 앱의 첫 실행에 대해서 20~30%의 속도 향상을 기대할 수 있고, 결국 더 부드럽고 효율적인 사용자 경험을 제공할 수 있음.
- ART는 이러한 프로파일을 사용하여 앱 설치 중에 중요한 코드 경로를 식별하고 미리 컴파일하여 응답성을 개선하고 앱 시작 지연 시간을 줄임.
- BaselineProfiles는 제공된 프로파일에 정확한 코드 경로를 정의하기 위해 AOT컴파일을 활용함. 생성된 프로파일에는 ART가 설치 단계 중에 컴파일하는 클래스 및 메서드 정보가 포함되어 있음.

<br><br><br>

#### Baseline Profiles 작동 방식

1. 중요한 코드 경로 정의 : 개발자는 주요 실행 경로를 프로파일링하거나 애플리케이션 시작 순간부터 가장 일반적인 사용자의 앱 사용 패턴을 기반으로 성능에 중요한 메서드 및 클래스를 미리 정의할 수 있음.
2. 프로파일 생성 : 프로파일은 Jetpack Macrobenchmark 라이브러리와 같은 도구를 사용하여 생성됨. 이를 통해 앱 동작을 기록하고 테스트하여 중요한 코드 경로를 식별할 수 있음.
3. 프로파일 전파 : 생성된 BaselineProfile은 APK 또는 AAB와 함께 번들로 제공되어 최종 사용자에게 전파되어 배포됨.
4. 설치 중 최적화 : 앱이 사용자 기기에 설치될 때 ART는 프로파일을 사용하여 미리 정의해두었던 메서드 및 클래스를 네이티브 코드로 미리 컴파일함.

<br><br><br>

#### 실전 질문
Q) BaselineProfiles를 활용하면 ART이 앱 성능을 어떻게 개선시키고, 해당 접근 방식이 기존 JIT 컴파일과 비교하여 가지는 성능적인 이점은 무엇인가요?
A) JIT는 앱을 설치하는 시점에 모든 것이 컴파일 되어있고, ART는 앱을 설치한 이후 컴파일 하는 방식임.
그렇기 떄문에 JIT는 설치하는 데 시간이 오래걸리고, ART는 설치 시간은 빠르지만 실행 시간이 느릴 수 있음. 이를 보완하는 것이 ART에 BaselineProfile을 두는 것이고, 이로 하여금 유저가 자주 가는 경로는 JIT 방식 처럼 미리 컴파일 해둘 수 있어서 최적화를 할 수 있는 것임.
