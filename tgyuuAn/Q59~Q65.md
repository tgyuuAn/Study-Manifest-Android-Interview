### Q59.) 장기적으로 실행되는 백그라운드 작업을 어떻게 관리하나요?

- 안드로이드는 최적의 리소스와 OS 제한 사항 준수를 보장하면서 장기적으로 실행 가능한 백그라운드 작업을 처리하기 위한 여러 메커니즘을 제공함.
- 각 솔루션은 작업의 성격, 콜 사이트와 상호작용을 해야 하는지 혹은 앱 생명주기와의 상호 작용 여부에 따라 달라짐

<br><br><br>

#### 조건부 작업에 적합한 WorkManager

- 앱이 닫히거나 기기 재부팅 후에도 실행되어야 한느 작업의 경우 WorkManager가 공식적으로 권장되는 솔루션임.
- 백그라운드 작업을 관리하고 네트워크 가용성 또는 충전 상태와 같은 제약 조건하에서 작업이 실행되도록 보장함.
- 예를 들어 로그 업로드, 데이터 동기화, 비디오와 같이 영상 파일 업로드 등이 일반적인 사용 사례임.

<br><br><br>

#### 오랜 작업에 적합한 Service

- 음악 재생이나 위치 추적과 같이 지속적이고 오랜 실행이 필요한 작업에는 서비스가 이상적임.
- 서비스는 UI와 독립적으로 실행되며 앱이 백그라운드에 있을 때도 계속 실행될 수 있음.
- 작업이 노티피케이션과 함께 사용자가 인지할 수 있는 상황에서 실행되어야 하는 경우 Foreground Services를 사용함.

<br><br><br>

#### Kotlin Coroutines 및 Dispatchers 사용하기

- 앱 생명주기에 연결된 작업의 경우 Kotlin Coroutines는 Kotlin 언어 수준에서 깔끔하고 구조화된 접근 방식을 제공함
- 무거운 작업을 오프로드 하려면 Dispatchers.IO를 사용하고 CPU 집약적인 계산에는 Dispatchers.Default를 사용함.
- CPU 집약적이란, 실제로 I/O 작업보다 무겁고 CPU를 많이 사용하는 작업이 아닌, 많은 스레드를 사용할 때 스레드 경합을 야기하는 작업. 주로 암호화, 이미지 처리, 비디오 인코딩 및 데이터 분석 등
- IO 작업은 많은 스레드를 사용하더라도 CPU 경합을 일으키지 않고, 동시에 실행될 수 있도록 하는 것.

<br><br><br>

#### 시스템 수준 작업에 적합한 JobScheduler

- 작업이 기기 전체 작업과 관련되고 특정 조건(가령, 충전 중에만 실행)이 필요한 경우 JobScheduler를 사용
- 즉시 실행이 필요하지 않은 작업에 적합
- WorkManager는 어차피 내부적으로 JobScheduler를 사용하므로 WorkManager 사용을 권장

<br><br><br>

#### 실전 질문

Q) 안드로이드 앱에서 백엔드 서버로부터 대용량 파일(수백MB)을 다운로드하는 기능을 구현해야 한다. 다운로드는 앱이 닫혀도 계속 되어야 하며, 성능 및 네트워크 조건 측면에서 효율적이어야 한다. WorkManager, ForegroundService, JobScheduler 중 어떤 것을 선택하여 구현하시겠나요?
A) WorkManager를 선택할 것. 앱이 닫혀도 계속 실행되어야 하므로 ForegroundService는 제외하고, 대용량 파일을 다운받으므로 중간에 실패하거나 취소되어도 Retry할 수 있는 WorkManager를 사용할 것임.

### Q60.) Json 형식을 객체로 어떻게 직렬화 하나요?

#### 직렬화와 역직렬화란?

직렬화
- 객체나 데이터 구조를 나중에 쉽게 저장, 전송 또는 재구성할 수 있는 형식으로 변환하는 프로세스
- 안드로이드와 백엔드 통신에서는 종종 객체를 Json 문자열이나 유사한 구조화된 형식으로 변환하는 것을 의미

역직렬화
- 직렬화된 데이터를 가져와 애플리케이션에서 작업할 수 있는 메모리 내 객체로 다시 재구성하는 역 프로세스

<br><br><Br>

#### 수동 직렬화 및 역직렬화

- 외부의 솔루션을 사용하지 않고도 직접 수동적으로 문자열 조작 및 파싱 기술을 통해 객체를 Json 문자열로 변환하고, 그 반대로 변환하여 수동으로 Json을 직렬화하고 역직렬화할 수 있음.
- 수동 직렬화는 객체의 속성을 Json 문자열로 바꾸는 것을 동반함.

<br><br><br>

#### KotlinXSerialization

- Jetbrains에서 개발한 KotlinXSerialization은 Kotlin과 직접적으로 통합되어 Kotlin의 언어적 기능을 활용하도록 설계
- Kotlin 컴파일러 플러그인을 사용하여 Kotlin 객체를 Json 문자열로 변환(직렬화)하고 Json 문자열을 다시 Kotlin 객체로 파싱(역직렬화)하는 타입 안정성을 보장
- 내부적으로 리플렉션을 사용하지 않는 메커니즘을 제공하므로 최신 안드로이드 및 Kotlin 개발에서 가장 선호되는 방법 중 하나

<br><br><br>

#### Moshi

- Square에서 개발한 Moshi는 타입 안정성과 kotlin 지원을 강조하는 최신 json 라이브러리
- Gson과 달리 Moshi는 Kotlin의 Null 가능성 및 기본 매개변수를 기본적으로 지원
- Moshi는 리플렉션에 기반한 동작과 컴파일 타임 코드젠 방식 두 가지를 사용가능함.
- 리플렉션 기반 : Java 리플렉션을 사용하여 런타임에 동적으로 Json 어댑터를 생성하므로 추가 설정 없이 사용법이 간단, 런타임 오버헤드 존재
- 코드 생성 기반 : 어노테이션 프로세스 기법을 통해 컴파일 타임에 Json 어댑터를 생성하여, 더 빠른 런타임 성능과 컴파일 타임 오류 검사를 제공

<br><br><br>

#### Gsonn

- Google에서 개발한 Gson은 널리 사용되는 Json라이브러리
- Java 객체를 Json으로 직렬화하고 Json을 다시 Java 객체로 역직렬화 할 수 있음
- 간단한 API와 통합 용이성 덕분에 인기 있는 라이브러리

<br><br><br>

### Q61.) 원격 데이터를 가져오기 위해 네트워크 요청을 어떻게 처리하며, 효율성과 신뢰성을 위해 어떤 라이브러리나 기술을 사용하나요?

- 일반적으로 Retrofit과 OkHttp는 안드로이드 개발에서 백엔드로부터 네트워크 요청을 하는 데 흔히 사용되는 라이브러리
- Retrofit은 선언적 인터페이스를 제공하여 API 상호 작용을 단순화하는 반면, OkHttp는 기본적인 Http 클라이언트 역할을 하여 연결 풀링, 캐싱 및 효율적인 통신을 제공함

<br><br><br>

#### 실전 질문

Q) 앱에서 동시에 여러 API 요청을 수행하고 UI를 업데이트하기 전에 결과를 결합해야 한다고 가정해봅시다. Retrofit과 코루틴을 사용하여 이를 효율적으로 구현하려면 어떻게 해야하나요?
A) ViewModel에서 ViewModelScope를 열어서 Retrofit을 호출. 결과가 suspend Fun에 의해 반환되면 해당 결과를 UI에 업데이트

Q) API 응답 실패시 어떻게 처리하고, 재시도 메커니즘은 어떻게 구현하나요?
A) 401과 같은 Unauthorized 에러의 경우 Authenticator를 사용하여 Header정보를 이용하여 Max Retry 수를 설정할 수 있음. Retry간에 Exception Backoff나 Random BackOff, 거기에 Jitter까지 추가하는 방식으로 커스텀할 수 있으며 그 외의 에러는 기획에 따라 바로 에러 처리를 해도되고, 재시도 처리를 해도 됨.

Q) UI 상태 관리를 위해 ViewModel 내에서 StateFlow 또는 LiveData를 사용하는 것의 장점과 잠재적인 단점은 무엇인가요?
A) UI <-> 비즈니스 양방향 의존성을 UI -> 비즈니스 단방향 의존성으로 끊어낼 수 있음. StateFlow를 사용하게 되면 생명주기에 맞춰서 구독과 해제를 잘 해주어야 하며, LiveData를 사용할 경우 안드로이드 프레임워크 의존성이 생기게 됨.

<br><br><br>

### Q62.) 대규모 데이터 셋을 효율적으로 로드하는 데 페이징 기법이 필요하고, RecyclerView로 구현해본 경험이 있나요?

- 페이징 시스템은 대규모 데이터 셋을 처리할 때 데이터 로드 및 화면에 렌더링 하는 방식을 최적화함.
- 데이터를 더 작고 쉽게 관리 가능한 청크로 가져옴으로써 원활한 앱 성능과 더 나은 사용자 경험을 보장함
- 데이터를 더 작은 페이지로 로드하면 메모리 사용량이 크게 줄어들어 잠재적인 메모리 부족 문제를 방지할 수 있음.

<br><br><br>

### Q63.) 네트워크에서 이미지를 어떻게 가져오고 렌더링하나요?

- 이미지 로딩은 사용자 플푈이나 네트워크에서 가져온 콘텐츠를 표시하는 작업과 같이 최신 애플리케이션 개발에 있어서 흔히 요구되는 기능임
- 개발자가 직접 이미지 로딩 시스템을 만드는 것도 가능하지만, 네트워크 요청, 이미지 크기 조절, 캐싱, 렌더링 및 효율적인 메모리 관리와 같은 복잡한 기능을 구현해야 함
- 직접 이미지 로딩 술루션을 구축하는 대신, 이미 대규모 프로젝트에서 사용되어 안정성이 입증되었으며, 풍부한 API를 제공하는 Glide, Coil, Fresc와 같은 라이브러리를 활용할 수 있음.

<br><br><br>

#### Glide

- Glide는 안드로이드 개발 생태계에서 오랫동안 인기를 끌어 온 빠르고 효율적인 이미지 로딩 라이브러리임.
- 캐싱, 플레이스홀더 이미지 및 이미지 변환과 같은 복잡한 시나리오를 처리하는 데 이상적임.
- Google의 공식 오픈 소스 프로젝트를 포함하여 많은 글로벌 제품 및 오픈 소스 프로젝트에서 사용되고 있음

```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg") // 이미지 URL
    .placeHolder(R.drawable.placeholder) // 로딩 중 표시할 이미지
    .error(R.drawable.error_image) // 오류 시 표시할 이미지
    .circleCrop() // 원형 자르기 변환 (선택 사항)
    .transtition(DrawableTransitionOptionis.withCrossFade()) // 페이드 효과
    .into(imageView) // 대상 ImageView
```

- Glide는 자동으로 이미지를 캐시하여 네트워크 호출을 최적화하고 성능을 향상시킴.
- 애니메이션 Gif 지원, 플레이스홀더, 변환, 캐싱, 리소스 재사용과 같은 유용한 기능을 제공함

<br><br><br>

#### Coil

- Coil은 Kotlin Multiplatform으로 설계된 100% Kotlin 기반의 이미지 로딩 라이브러리임
- 내부적으로 Coroutines를 활용하고 Jetpack Compose와 같은 최신 기능을 지원함
- 특히 Coil은 내부적으로 OkHttp 및 Coroutines와 같이 안드로이드 프로젝트에서 이미 널리 사용되는 라이브러리를 사용하기 때문에 기존 프로젝트에 원활하게 통합될 수 있음.
- Coil은 Kotlin 및 JetpackCompose와 원활하게 통합되며, 이미지 변환, 애니메이션 Gif 지원, svg 렌더링, 비디오 프레임 추출과 같은 유용한 기능을 제공함.

<br><br><br>

#### Fresco

- Fresco는 Meta에서 개발한 이미지 로딩 라이브러리로, 조금 더 복잡한 사용 사례를 위해 설계되었음.
- 이미지를 디코딩하고 표시하기 위해 자체 파이프라인을 사용하는 접근 방식을 사용함.
- 안드로이드 4.x 이하에서 이미지를 특수 메모리 영역에 할당하여 성능을 비약적으로 높였지만, 4.x 이하의 디바이스는 현대 사회에서 거의 찾아보기 힘들정도로 사용률이 감소해서 이점이 거의 사라짐
- 그래도 이미지 파이프라인, Drawees, 최적화된 메모리 관리, 고급 로딩 메커니즘, 스트리밍 및 애니메이션과 같은 괜찮은 기능을 제공.
- 프로젝트에 복잡한 이미지 처리 시나리오가 포함된 경우 여전히 Fresco를 활용하는 사례가 있음.

### Q64.) 로컬 디바이스에 데이터를 저장하고 복원하는 방법에 대해서 설명해 주세요.

- 안드로이드는 경량화된 키-값 기반의 데이터 저장, 구조화된 데이터 베이스 구축 및 쿼리 또는 로컬 파일 처리 등 각 시나리오에 적합한 데이터 저장 메커니즘을 제공함.

<br><br><br>

#### SharedPreferences

- SharedPreferences는 앱 내 설정이나 사용자 환경 설정과 같은 가벼운 값 가장 적합한 키-값 쌍 형태의 데이터 저장 메커니즘임
- Boolean, Int, String, Float와 같은 원시타입을 저장하고 앱 재시작 시에도 유지할 수 있음.
- SharedPreferences는 동기적으로 작동하여 메인 스레드를 차단하는 문제가 있고, 최근 비동기 처리 함수 등을 제공하는 DataStore의 등장으로 인해 최신 애플리케이션에서는 덜 선호되고 있음.

<br><br><br>

#### DataStore

- Jetpack DataStore는 SharedPreferences를 대체하는 더 모던하고 효율적인 방법임.
- 키-값 저장을 위한 PreferencesDataStore와 구조화된 객체 값 데이터를 위한 ProtoDataStore의 두 가지 유형을 제공함.
- SharedPreferences와 달리 DataStore는 비동기식이므로 메인 스레드를 차단하는 잠재적인 문제를 방지함.

<br><br><br>

#### Room Database

- Room Database는 구조화되고 관계형 데이터를 처리하도록 설계된 SQLite를 수준 높게 추상화한 솔루션
- 어노테이션, 컴파일 타임 검사, 반응형 및 프로그래밍을 위한 LiveData 또는 Flow 지원을 통해 데이터베이스 관리를 매우 단순화함.
- 개발자가 데이터베이스 쿼리를 위해서 쿼리문을 공부해야 할 필요가 전혀 없음.
- Room은 복잡한 쿼리나 대량의 구조화된 데이터 저장이 필요한 앱에 이상적임.

<br><br><br>

#### File Storage

- 바이너리 또는 커스텀 데이터의 경우 안드로이드는 내부 또는 외부 저장소에 파일을 저장할 수 있도록 함
- 내부 저장소는 앱 간 접근할 수 없으며, 외부 저장소는 다른 앱과 공유할 수 있음.
- 파일 I/O 작업은 이미지, 비디오 또는 커스텀 직렬화된 데이터 저장과 같은 작업에 사용할 수 있음

#### 실전 질문

Q) 오프라인 접근을 위해 네트워크 API에서 받은 대용량 Json 응답을 저장해야 하는 시나리오에서 어떤 로컬 저장 메커니즘을 사용할 것이고, 그 이유는 무엇인가요?
A) 대용량 Json 응답의 경우 파일 형태로 디스크에 저장할 것. 별도의 쿼리가 필요하지 않으며 캐싱하는 용도라면 파일로 저장해도 문제없을 것임. 불필요하게 Room 데이터 베이스를 만드는 것도 오버엔지니어링이라고 판단하였음.

<br><br><br>

### Q65.) 오프라인 우선 아키텍처를 어떻게 설계하실 건가요?

- 오프라인 우선 디자인은 애플리케이션이 로컬에 캐시되거나 저장된 데이터에 의존하여 활성 네트워크 연결 없이도 앱이 원활하게 작동하도록 보장
- 이러한 접근 방식은 특히 인터넷 연결이 좋지 않거나 간헐적으로 인터넷이 끊기는 시나리오에서 사용자 경험을 향상시킴.
- 데이터를 로컬에 캐시하거나 저장하고 연결이 복원되면 원격 서버와 동기화하여 매끄러운 경험을 제공함.
- 오프라인 우선 앱 설계에 대한 모범 사례는 오프라인 우선에 대한 안드로이드 공식 문서에서 제공함.


<br><br><br>

#### 오프라인 우선 아키텍처의 핵심 개념

1. 로컬 데이터 지속성
- 신뢰할 수 있는 오프라인 우선 전략은 로컬 데이터 저장소에서 시작됨.
- Jetpack의 일부인 Room Database는 구조화된 로컬 데이터를 관리하기 위한 솔루션임.
- 앱이 오프라인 상태에서도 데이터에 접근하고 업데이트할 수 있도록 보장학 ㅣ때문

2. 데이터 동기화
- 로컬 데이터와 원격 데이터 간의 동기화는 일관성을 보장함
- WorkManager는 이를 위한 훌륭한 선택 중 하나로, 네트워크 연결과 같은 조건이 충족될 때 지연된 동기화 작업이 실행되도록 함.
- WorkManager는 실패한 작업을 자동으로 재시도하여 데이터 무결성을 보장함.

3. 캐시 및 가져오기 정책
- 아래와 같이 데이터 캐싱(쓰기) 및 가져오기(읽기)에 대한 명확한 정책을 정의해야 함
- 캐싱 데이터 읽기 : 앱이 먼저 로컬 저장소에서 데이터를 가져오고 필요할 때만 네트워크에 새로운 데이터를 요청함
- 캐싱 데이터 쓰기 : 업데이트가 로컬에 기록되고 백그라운드에서 서버와 동기화됨

4. 충돌 해결
- 로컬 소스와 원격 소스 간에 데이터를 동기화할 때 충돌 해결 전략을 구현해야 함.
- 최신 데이터 우선 : 가장 최근 변경 사항을 우선시함
- 사용자 정의 : 사용자가 수동으로 충돌을 해결하거나 도메인별 규칙을 적용하도록 허용함

<br><br><br>

#### 실전 질문
Q) 네트워크가 자주 끊기는 국가 및 지역에서도 원활한 사용자 경험을 보장하기 위해 오프라인 우선 기능을 어떻게 설계하시겠습니까?
A) 서버에서 내려받는 데이터는 항상 Room에 저장, 데이터를 가져올 때 서버를 먼저 호출하고 fallback으로 로컬을 호출. Room에 저장할때 updatedAt, isDelete와 같은 Column을 추가적으로 둠으로써 로컬-서버간의 데이터 싱크를 맞춤