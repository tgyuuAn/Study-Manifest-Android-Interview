### Q38.) View의 시스템 무효화(invalidation)이란 무엇인가요?

- Inavalidation은 View를 다시 그려야 함을 표시하는 프로세스를 의미.
- 이는 변경 사항이 발생할 때 UI를 업데이트하기 위해 안드로이드 View 시스템에서 사용되는 기본 메커니즘임
- View가 무효화되면 시스템은 다음 드로잉 주기 동안 화면의 해당 부분을 새로 고쳐야 함을 인지하고 새롭게 그림

#### 무효화 작동 방식

- View에서 invalidate() 또는 postInvalidate()와 같은 메서드를 호출하면 무효화 프로세스가 트리거됨.
- 시스템은 View를 더티(dirty)로 플래그 지정하며, 이는 다시 그려야 함을 의미함.
- 다음 프레임 동안 시스템은 무효화된 View를 드로잉 패스에 포함시켜 시각적 표현을 업데이트 함.

- 무효화 프로세스가 필요한 이유는 View에 변화가 필요할 때마다, 새롭게 View를 다시 렌더링 하는 것이 아니라, 개발자나 시스템에 의해 시기적절한 순간에 업데이트 되도록 제한함으로써 더 나은 성능을 만들 수 있음.
- 그렇지 않고 자동적으로 View가 업데이트 된다면, 무분별한 렌더링으로 앱의 전반적인 성능이 크게 떨어질 수 있음.

<br><br><br>

#### 무효화를 위한 주요 메서드

1. invalidate() : 이 메서드는 단일 View르 무효화하는 데 사용됨. View를 더티로 표시하여 시스템이 다음 레이아웃 패스 중에 다시 그리도록 신호를 보냄. View를 즉시 다시 그리는 것이 아니라 다음 프레임을 위해 예약함
2. invalidate(Rect dirty) : 이는 invalidate()의 오버로드된 버전으로, 다시 그려야 하는 View 내의 특정 직사각형 영역을 지정할 수 있음. 더 작은 부분으로 다시 그리기를 제한하여 성능을 최적화함.
3. postInvalidate() : 이 메서드는 UI 스레드가 아닌 스레드에서 View를 무효화하는 데 사용됨. 무효화 요청을 메인 스레드에 게시하여 스레드 안정성을 보장함.

_(requestLayout은 측정부터 다시, invalidate는 draw단계부터 다시)_

<br><br><br>

#### invalidate()를 사용하여 커스텀 View 업데이트 하기

- 상태가 변경될 때 UI를 다시 그리기 위해 invalidate() 메서드가 사용되는 커스텀 View의 예시임

```kotlin
class CustonView(context: Context) : View(context) {
    private var circleRadius = 50f
    private val paint = Paint().apply { color = Color.RED } // Painter 객체 미리 생성
    
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        // 현재 반지름으로 원 그리기
        canvas.drawCircle(width / 2f, height / 2f, circleRadius, paint)
    }
    
    fun increaseRadius() {
        circleRadius += 20f
        invalidate() // View를 다시 그려야 함으로 표시
    }
}
```

<br><br><br>

#### 무효화 모범 사례

- View의 특정 영역만 다시 그려야 할 때 부분 업데이트를 위해 invalidate(Rect dirty)를 사용. 이는 변경되지 않은 영역의 불필요한 다시 그리기를 피하여 성능을 향상시킴.
- 특히 애니메이션이나 복잡한 레이아웃에서 성능 병목 현상을 방지하기 위해 invalidate()를 자주 또는 불필요하게 호출하지 않음.
- 백그라운드 스레드에서의 무효화 요청에는 postInvalidate()를 사용하여 업데이트가 메인 스레드에서 안전하게 발생하도록 보장함.

<br><br><br>

#### 실전 질문

Q) invalidate() 메서드는 어떻게 작동하며 postInvalidate()와 어떻게 다른가요? 각각이 적합한 실제 사용 사례를 제시해주세요.
A) invalidate()는 requestLayout()과는 다르게 Measure를 다시 하지않고, draw부터 다시 수행됨. postInvalidate()는 백그라운드에서 View를 다시 그려야 할 때 수행되며 서버에서 데이터를 받아오면서 Progress를 표시하는 등에서 사용

<br><br><br>

Q) 백그라운드 스레드에서 UI 요소를 업데이트해야 하는 경우, 다시 그리기 작업이 메인 스레드에서 안전하게 수행되도록 어떻게 보장할 수 있나요?
A) postInvalidate()를 사용하여 메인 스레드에서의 UI 변경을 보장할 수 있음.

<br><br><br>

### Q39.) ConstraintLayout이란 무엇인가요?

- ConstraintLayout은 여러 레리아웃을 중첩하지 않고 복잡하고 반응성이 뛰어난 사용자 인터페이스를 만들기 위해 안드로이드에 도입된 유연하고 여러모로 유용한 레이아웃임.
- 다른 뷰나 부모 컨테이너에 상대적인 제약 조건을 사용하여 뷰의 위치와 크기를 정의할 수 있음. 이를 통해 깊게 중첩된 뷰 계층 구조가 필요 없어 성능과 코드 가독성이 향상됨.

#### ConstraintLayout의 주요 특징

1. 제약 조건을 이용한 위치 지정
2. 유연한 크기 제어
3. 체인 및 가이드라인 지원
4. 배리어 및 그룹핑
5. 성능 향상

<br><br><br>

#### ConstraintLayout 사용 사례

1. 반응형 UI : 다양한 화면 크기에서 정밀한 정렬과 적응성이 필요한 디자인에 이상적임
2. 복잡한 레이아웃 : 여러 겹치는 요소나 복잡한 위치 지정 요구 사항이 있는 UI에 적합함
3. 성능 최적화 : 중첩된 뷰 계층 구조를 단일 플랫 구조로 대체하여 레이아웃을 최적화하는 데 도움이 됨.

<br><br><br>

### Q40.) SurfaceView 대신 TextureViw는 언제 사용해야 하나요?

- SurfaceView는 별도의 스레드에서 렌더링이 처리되는 시나리오를 위해 설계된 특수한 View로, 전용 드로잉 표면을 제공함.
- 이는 일반적으로 성능이 중요한 비디오 재생, 커스텀 그래픽 렌더링 또는 게임과 같은 작업에 사용됨.
- SurfaceView의 주요 특징은 메인 UI 스레드 외부에 별도의 표면을 생성하여 다른 UI 작업을 차단하지 않고 효율적인 렌더링을 가능하게 한다는 것
- 표면은 SurfaceHolder 콜백 메서드를 통해 생성 및 관리되며, 필요에 따라 렌더링을 시작하고 중지할 수 있음.
- 가령 저수준 API를 사용하여 비디오를 재생하거나 게임 루프에서 그래픽을 계속해서 그리는 데 SurfaceView를 사용할 수 있음.

<br><br><br>

- SurfaceView는 연속적인 렌더링(비디오 재생 등)에 효율적이라 크기 조절이나 회전과 같은 변환에는 제한이 있어 고성능 사용 사례에는 적합하지만, 동적인 상호 작용이 요구되는 UI에는 덜 유연하고 적합하지 않음
- 반면에 TextureView는 콘텐츠를 오픈스크린으로 렌더링하는 또 다른 방법을 제공하면서도 SurfaceView와 달리 UI계층 구조에 원활하게 통합됨.
- 즉, TextureView는 회전, 크기, 조절, 알파 블렌딩과 같은 기능을 허용하여 변환하거나 애니메이션화 할 수 있음.
- 라이브 카메라 피드를 표시하거나 커스텀 변환으로 비디오를 렌더링하는 등의 작업에 자주 사용됨
- SurfaceView와 달리 TextureView는 메인 스레드에서 작동함. 이로 인해 연속 렌더링에는 성능적인 측면에서 덜 효율적이지만, 다른 UI 컴포넌트와의 더 나은 상호작용을 가능하게 하고 실시간 변환을 지원함.

<br><br><br>
#### SurfaceView와 TextureView의 차이점

- 주요 차이점은 각 컴포넌트가 렌더링 및 UI 통합을 처리하는 방식에 있음.
- SurfaceView는 별도의 스레드에서 작동하여 비디오 재생이나 게임과 같은 연속 렌더링 작업에 효율적임
- 또한 렌더링을 위한 별도의 Window를 생성하여 성능을 보장하지만, 변환되거나 애니메이션화되는 능력은 제한됨.
- 반면 TextureView는 다른 UI 컴포넌트와 동일한 Window를 공유하여 크기 조절, 회전 또는 애니메이션이 가능하므로 UI 관련 사용 사례에 더 유연함.
- 그러나 메인 스레드에서 작동하므로 고성능 렌더링이 필요한 작업에는 효율적이지 않을 수 있음.

#### 실전 질문

Q) 효율적인 리소스 관리 및 메모리 누수 방지를 위해 SurfaceView의 생명주기를 어떻게 적절하게 관리해야 하나요?
A) 콜백을 기준으로 자원 열고 닫기, Activity/Fragment 생명주기와 맞물리기, 스레드/동기화, 참조 누수 주의 등

Q) 카메라 미리보기를 회전 및 크기 조절과 같은 UI 변환과 함께 표시해야 하는 요구 사항이 주어졌을 때, SurfaceView와 TextureView 중 어떤 컴포넌트를 선택하는 것이 적합한가요?
A) 회전 및 크기 조절과 같은 동작을 하기 위해서는 메인스레드의 window를 사용하는 TextureView가 더 적절함. SurfaceView는 개별 Window를 만들어 다른 스레드에서 동작하므로 동적인 UI 변환에 적절치 않을 수 있음.

### Q41.) RecyclerView는 내부적으로 어떻게 작동하나요?

- RecyclerView는 새로운 아이템 뷰를 반복적으로 인플레이션하는 대신 재활용하여 대규모 데이터 셋을 효율적으로 표시하도록 설계된 유용하고 유연한 안드로이드 컴포넌트입니다.
- ViewHolder 패턴으로 알려진 뷰 관리를 위한 객체 풀과 유사한 메커니즘을 사용하여 이러한 효율성을 달성함

<br><br><br>

#### RecyclerView 내부 메커니즘의 핵심 개념

1. 뷰 재활용 
- RecyclerView는 데이터 셋의 모든 항목에 대해 새 뷰를 생성하는 대신 기존 뷰를 재사용함.
- 뷰가 보이는 영역 밖으로 스크롤되면 소멸되는 대신 뷰 풀에 추가됨.
- 새 항목이 뷰에 들어오면 RecyclerView는 가능한 이 풀에서 기존 뷰를 검색하여 인플레이션 오버헤드를 피함.

2. ViewHodler 패턴
- RecyclerView는 항목 레이아웃 내 뷰에 대한 참조를 저장하기 위해 ViewHolder를 사용함. 
- 이는 바인딩 중 반복적인 findViewById() 호출을 방지하여 레이아웃 순회 및 뷰 조회를 줄여 성능을 향상시킴

3. Adapter의 역할
- RecyclerView.Adapter는 데이터 소스와 RecyclerView를 연결하는 다리 역할을 함.
- 어댑터의 onBindViewHolder() 메서드는 뷰가 재사용될 때 데이터를 뷰에 바인딩하여 보이는 항목만 업데이트되도록 보장함.

4. RecyclerViewPool
- RecyclerViewPool은 사용되지 않는 뷰가 저장되는 객체 풀 역할을 함.
- 이를 통해 RecyclerView는 유사한 뷰 유형을 가진 여러 목록 또는 섹션에서 뷰를 재사용하여 메모리 사용량을 더욱 최적화할 수 있음.

<br><br><br>

#### 재활용 메커니즘

1. 스크롤 및 항목 가시성 : 사용자가 스크롤하면 뷰 밖으로 나가는 항목은 RecyclerView에서 분리되지만 소멸되지 않음. 대신 RecylerViewPool에 추가됨
2. 재활용된 뷰에 데이터 리바인딩 : 새 항목이 뷰에 들어오면 RecyclerView는 먼저 RecyclerViewPool에서 필요한 유형의 사용 가능한 뷰를 확인함. 일치하는 항목이 발견되면 onBindViewholder()를 사용하여 새 데이터로 리바인딩하여 뷰를 재사용함.
3. 사용 가능한 뷰가 없는 경우 인플레이션 : 풀에 적합한 뷰가 없는 경우 RecyclerView는 onCreateViewHolder()를 사용하여 새 뷰를 인플레이션 함.
4. 효율적인 메모리 사용 : 뷰를 재활용함으로써 RecyclerView는 메모리 할당 및 가비지  컬렉션을 최소화하여 대규모 데이터 셋이나 빈번한 스크롤이 포함된 시나리오에서 발생할 수 있는 성능 문제를 줄임.
<br><br><br>

#### 실전 질문

Q) RecyclerView의 ViewHolder 패턴은 ListView와 비교하여 성능 향상 측면에서 어떤 이점이 있나요?
A) ListView에서는 ViewHodler를 사용하지 않아 보이지 않다가 다시 보이면 binding을 다시 시도. View의 경우 성능이 괜찮을 수 있으나, ViewGroup의 경우 완전 탐색을 진행하므로 성능이 좋지 못함.

Q) RecyclerView에서 ViewHolder의 생성부터 재활용까지의 생명주기를 설명해주세요.
A)
1. Cache를 확인하여 이미 바인딩된 viewholder가 있으면 바로 반환.
2. 없을 경우 ViewHolderPool을 확인하여 있을 경우 데이터를 바인딩하여 반환
3. 그 마저도 없다면 onCreateViewHolder()를 통해 ViewHolder를 생성하고 데이터를 바인딩해서 반환

<br><br><br>

### Q42.) Dp와 Sp의 차이점은 무엇인가요?

- 안드로이드 사용자 인터페이스를 디자인할 때 UI 컴포넌트가 다양한 화면 크기와 해상도에 어떻게 적응하는 지 고려햐여 함.
- 이를 위해 사용되는 필수적인 개념에는 Dp와 Sp가 있음.
- 둘 다 기기 간 일관성을 보장하는 데 도움이 되지만 다른 목적을 가지고 있음.

#### Dp란 무엇인가?

- Dp는 패딩, 마진, 너비와 같은 UI 요소의 측정 단위
- 다양한 화면 밀도를 가진 기기에서 UI컴포넌트와 일관된 물리적 크기를 제공하도록 설계되어있음.
- Dp는 160Dpi 화면의 물리적 픽셀 1개와 같으며, 안드로이드는 기기 밀도에 맞게 Dp를 자동으로 조절함.
- 예를 들어, Button 너비를 100dp로 지정하면 저밀도 및 고밀도 화면 모두에서 대략 동일한 크기로 표시되지만 이를 렌더링하는 데 필요한 픽셀 수는 다름.

<br><br><br>

#### Sp란 무엇인가?

- Sp는 텍스트 크기에만 사용됨. Dp와 유사하게 작동하지만 사용자의 글꼴 크기와 환경 설정을 추가로 고려함.
- 즉, Sp는 화면 밀도와 기기의 접근성 설정 모두를 기반으로 텍스트 크기를 조정하므로 읽기 쉽고 접근 가능한 텍스트를 보장하는 데 이상적임.
- 예를 들어, TextView를 16sp로 설정하면 화면 밀도에 맞게 적절하게 크기가 조절되고 사용자가 시스템 글꼴 크기를 늘린 경우에도 조정됨.

<br><br><br>

#### Dp와 Sp의 주요 차이점

1. 목적 : Dp는 크기에 사용하고 Sp는 텍스트 크기에 사용
2. 사용자 정의 환경 : Sp는 사용자가 정의한 글꼴 크기 환경 설정을 존중하지만 Dp는 그렇지 않음.
3. 밀도 보장성 : 둘 다 화면 밀도에 따라 크기가 조절되지만 Sp는 모든 사용자가 텍스트를 접근 가능하고 읽을 수 있도록 보장

<br><br><br>

#### Sp 단위를 사용할 때 화면 깨짐을 어떻게 처리하나요?

- Sp를 사용하는 것은 화면 밀도와 사용자 글꼴 환경 설정에 따라 크기가 조절되므로 안드로이드 텍스트 접근성을 보장하는 데 중요함.
- 그러나 사용자가 정의한 큰 글꼴 크기로 인한 과도한 크기 조절은 UI 컴포넌트가 겹치거나 화면을 벗어나는 레이아웃 깨짐 문제로 이어질 수 있음.
- 사용자 친호적인 경험을 유지하려면 이러한 시나리오를 적절하게 처리하는 것이 필수적임.

<br><br><br>

#### 화면 깨짐 방지 전략

1. 콘텐츠를 적절하게 감싸기
2. TextView에 minLines 또는 maxLines 사용하기
3. 중요한 UI 컴포넌트에 고정 크기 사용하기
4. 극단적인 글꼴 크기로 테스트하기
5. 제약 조건을 사용한 동적 크기 조절 고려하기
6. Sp 대신 Dp 크기 사용하기

<br><br><br>

### Q43.) 나인패치 이미지의 용도는 무엇인가요?

- 나인패치 이미지는 시각적 품질을 잃지 않고 늘리거나 크기를 조절할 수 있는 특수 형식의 PNG 이미지로, 안드로이드에서 유연하고 적응 가능한 UI 컴포넌트를 만드는 데 필수적임.
- 주로 버튼, 배경, 컨테이너와 같이 다양한 화면 크기 및 콘텐츠 크기에 맞게 동적으로 크기를 조절해야 하는 요소에 사용됨.

<br><br><br>

#### 나인패치 이미지의 주요 특징

1. 늘어나는 영역
- 나인패치 이미지는 이미지의 나머지 부분의 무결성을 유지하면서 늘릴 수 있는 영역을 정의함.
- 이는 이미지의 가장 바깥쪽 1픽셀 테두리에 있는 검은색 선을 사용하여 정의할 수 있음.

2. 콘텐츠 영역 정의
- 검은색 선은 이미지 내부에서 늘어날 수 있는 콘텐츠 영역을 지정하여 이미지 내 텍스트 또는 기타 UI 요소의 적절한 정렬을 보장함.

3. 동적 크기 조절
- 비례적으로 크기가 조절되어 다양한 화면 크기를 가진 기기에서도 UI 컴포넌트가 깨지지 않고 모양을 유지하도록 보장함.

<br><br><br>

#### XML에서의 사용 예제

```xml
<Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" 
    android:background="@drawable/button_background.9.png"
    android:text="Click Me" /> <!‐‐ 파일 이름에 .9 포함 ‐‐> 
```

<br><br><br>

#### 나인패치 이미지의 한계
1. 수동 생성 : 적절한 크기 조절 및 정렬을 보장하기 
2. 제한된 사용 사례 : 직사각형 또는 정사각형 형태의 요소(가령, 채팅 말풍선 등)에 가장 적합하며, 복잡하거나 불규칙한 모양에는 덜 효과적임.

<br><br><br>

- https://oscarstory.tistory.com/51
- https://developer.android.com/studio/write/draw9patch?hl=ko

### Q44.) Drawable이란 무엇이며, UI 개발에서 어떻게 사용되나요?

- Drawable은 화면에 그릴 수 있는 모든 것에 대한 추상화 개념임.
- 이미지, 벡터 그래픽, 특정 모양 기반의 요소와 같은 다양한 유형의 그래픽 콘텐츠의 기본 클래스 역할을 함.
- Drawable은 배경, 버튼, 아이콘, 커스텀 뷰를 포함한 UI 컴포넌트에 널리 사용됨.

<br><br><br>

1. BitmapDrawable (레스터 이미지)
- BitmapDrawable은 PNG, JPG 또는 GIF와 같은 래스터 이미지를 표시하는 데 사용됨.
- 비트맵 이미지의 크기 조절, 타일링 및 필터링을 허용함.

2. VectorDrawable (확장 가능한 벡터 그래픽)
- VectorDrawable은 XML 경로를 사용하여 확장 가능ㅇ한 벡터 그래픽(Svg 유사)을 나타냄
- 비트맵과 달리 벡터는 어떤 해상도에서도 품질을 유지.

3. NinePatchDrawable (패딩이 있는 크기 조절 가능 이미지)
- NinePatchDrawable은 모서리나 패딩과 같은 특정 영역을 보존하면서 크기를 조절할 수 있는 특수 유형의 비트맵임.
- 채팅 말풍선 및 버튼과 같이 특정 영역에 있어서 늘어나는 UI 컴포넌트를 만드는 데 유용함.

4. ShapeDrawable (커스텀 모양)
- ShapeDrawable은 XML에서 정의되며 이미지를 사용핮지 않고 둥근 사각형, 타원 또는 기타 단순한 모양을 만드는 데 사용할 수 있음

5. LayerDrawable (여러 Drawable 쌓기)
- LayerDrawable은 여러 Drawable을 단일 계층 구조로 결합하는 데 사용되며 복잡한 UI 배경에 유용함.

<br><br><br>

#### 실전 질문

Q) Drawable만 사용하여 사용자 상호 작용에 따라 모양과 색상이 변경된느 동적배경을 가진 버튼을 어떻게 만들 수 있나요?
A) 나인 패치를 사용하거나 벡터 드로어블 혹은 shape Drawable을 사용하여 정의할 수 있음
