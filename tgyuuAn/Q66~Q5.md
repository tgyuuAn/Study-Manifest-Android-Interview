### Q66.) 초기 데이터 로딩을 위한 작업을 Compose의 LaunchedEffect와 ViewModel.init()중 어디에서 하는 것이 가장 이상적인가요?

- 공식 안드로이드 문서 및 Architecture-samples Github의 예제는 일반적으로 구성 변경시 더 나은 생명주기 관리 및 데이터 지속성을 위해 viewModel.init()내에서 데이터를 로드할 것을 예씨로 보여주고 있음.
- 개발자를 대상으로 어느 시점에 데이터를 로드하는 지 설문조사를 진행했는데, ViewModel.init()에서 초기 데이터를 로드하는 경우가 62.6%로 더 많았음.

A : "JetpackCompose UI"를 어플리케이션의 상태 또는 데이터 시각적 표현으로 간주한다면, 앱에 무엇을 해야 할 지 지시하기 위해 UI에 의존한다는 것은 사실 설계 결함이라고 볼 수 있음.
이러한 관점에서 ViewModel.init()을 사용하는 것이 LaunchedEffect() 내에서 직접 데이터를 가져오는 것보다 더 나은 관심사 분리를 제공하여 비즈니스 로직과 UI 상태 관리가 구분되도록 보장함.

B : "ViewModel.init()"에만 의존하면 특정 동작이 트리거되는 시점에 대한 제어가 어려워지고 유닛 테스트가 복잡해질 수 있다는 것을 명심해야함. 대신 ViewModel 내에서 이벤트 기반 흐름을 관찰하여 트리거되고 지연 초기화될 수 있는 독립적인 함수를 정의하는 것을 선호함. 해당 접근 방식은 더 큰 유연성과 제어권을 제공하여 LaunchedEffect 또는 이벤트 트리거 작업과 같은 메서드가 데이터 로딩을 더 효과적으로 관리할 수 있도록 함. 추가적인 이점은 ViewModel.init 블록에 전적으로 의존하는 대신 사용자 상호작용이나 특정 이벤트를 기반으로 데이터를 다시 가져올 때 효율성이 향상됨.

<br><br><br>

#### 둘 다 안티패턴. 지연 관찰 사용하기

- 두 솔루션 모두 주목할만한 단점이 있음. 흥미롭게도 Google의 Android Toolkit 팀의 Ian Lake는 두 접근 방식 모두 안드로이드 개발에서 안티패턴으로 간주된다고 짖거하며, 초기 데이터 로딩 관리에 다른 대안이 필요함을 시사했음.
- ViewModel.init()에서 초기 데이터를 로드하면 ViewModel 생성 중에 의도하지 않은 사이드 이펙트가 발생하고, UI 상태 관리라는 의도된 역할에서 벗어나 생명주기 처리를 복잡하게 만들 수 있음.
- 마찬가지로 Jetpack Compose의 LaunchedEffect 내에서 데이터를 초기화하면 매 첫 컴포지션마다 반복적으로 트리거 될 위험이 있음.
- 이는 ViewModel의 생명주기가 일반적으로 Composable의 함수의 생명주기보다 길기 때문에, Composable 함수가 새로 컴포지션에 진입할 때마다 동일한 ViewModel 인스턴스에 대해서 동일한 비즈니스 로직을 반복적으로 트리거할 가능성이 있음. 따라서 생명주기 불일치로 예기치 않은 동작이 발생하고 의도된 데이터 흐름을 방해할 수 있음.
- 이러한 우려를 해결하기 위해 Ian Lake는 지연 초기화를 위해 cold Flows 사용을 권장함. 이 접근 방식에서 Flow는 수집되기 시작할 때만 네트워크 요청이나 데이터베이스 쿼리와 같은 비즈니스 로직을 실행함.
- UI 레이어에서 구독자가 있을 때까지 Flow는 비활성화 상태로 유지되어 불필요한 작업이 수행되지 않음.

<br><br><br>

#### 지연 관찰 모범 사례

- 해당 접근 방식의 예시를 Github의 Pokedex-Compose 프로젝트에서 일부 가져와 아래에서 보여주고 있음.

```kotlin
val pokemoon: StateFlow<Pokemon?> = savedStateHandle.getStateFlow("pokemon", null)

val pokemonInfo: StateFlow<PokemonInfo?> = pokemon.filterNotNull().flateMapLatest { pokemon ->
    detailsRepository.fetchPokemonInfo(
        name = pokemon.name,
        onCompolete = { isLoading = false }, // 로딩 상태 업데이트
        onError = { errorMessage = it }, // 오류 메시지 업데이트
    )
}.stateIn(
    scope = viewModelScope, // ViewModel 스코프 사용
    started = SharingStarted.WhileSubscribed(5_000), // 구독자 있을 때만 Flow 구독 시작, 구독자가 없다면 5초 후 데이터 발행 중지
    initialValue = null, // 초기값 설정
)
```

- 위 코드에서 업스트림 호출은 첫번째 구독자가 Flow 수집을 시작할 때만 트리거 됨.
- 그런 다음 결과는 캐시되어 stateIn 메서드를 사용하여 상태로 변환되어 효율적인 데이터 관리와 중복 작업 최소화를 보장함.
- stateIn 메서드는 콜드 플로우를 핫 플로우인 StateFlow로 변환하여, 일부 상태 값에 대한 업데이트를 제공하고, 생성 또는 유지 관리가 비싼 편이지만 가장 최근 값을 수집해야 하고 여러 구독자가 생길 수 있는 상황에서 유용.
- 궁극적으로 pokemonInfo 속성이 핫 플로우로 정의되더라도 가장 최근에 방출된 값은 업스트림 플로우의 단일 실행 인스턴스에서 나옴.
- 해당 인스턴스는 여러 다운스트림 구독자 간에 공유되며 지연 초기화되어 효율적인 데이터 관리와 중복 실행을 방지함.

### Q0.) JetpackCompose의 동작 구조는 어떻게 이루어져 있나요?

- Jetpack Compose는 선언적 접근 방식을 사용하여 네이티브 안드로이드 애플리케이션을 구축하기 위한 가장 최신의 UI 툴킷임.
- Compose는 Compose Compiler, Compose Runtime, Compose UI의 세 가지 주요 계층으로 이루어져 있음.
- 각 계층은 UI 코드를 상호 작용 가능한 애플리케이션으로 변환하는데 중요한 역할을 함.

<br><br><Br>

#### Compose Compiler

- Compose Compiler는 Kotlin으로 작성된 선언적 UI 코드를 Jetpack Compose가 실행할 수 있는 최적화된 코드로 변환하는 역할을 함.
- 컴파일 타임에 @Composable 함수를 처리하고, 필요한 UI 업데이트 및 recomposition 로직을 생성함.
- 컴파일러는 Kotlin 컴파일러로 구현되어 효율적인 코드 생성을 보장하고 상태 관리, 코드 최적화, 더 나은 성능을 위한 람다 리프팅과 같은 기능을 지원함
- Kapt 및 Ksp와 같은 기존 어노테이션 처리 도구와 달리 Compose Compiler 플러그인은 FIR에서 직접 작동함
- 이러한 특성으로 컴파일러는 컴파일 타임에 정적 코드에 대해 더 자세하게 접근할 수 있으며, 개발자가 작성한 Kotlin 소스 코드를 동적으로 변환하고 최적화된 Java 바이트 코드를 생성할 수 있음.
- @Composable과 같은 Compose 라이브러리의 어노테이션은 코드 생성, recomposition 관리 및 성능 최적화와 같은 작업을 조율하는 Compose Compoiler의 내부 메커니즘을 통해 작동함.

<br><br><br>

#### Compose Runtime

- Compose Runtime은 recomposition 및 상태 관리를 지원하는 데 필요한 핵심 기능을 제공함.
- 변경 가능한 상태를 처리하고, 스냅샷을 관리하며, 애플리케이션 상태가 변경될 때 마다 UI 업데이트를 트리거함.
- 또한 Compose의 반응형 UI 시스템을 구동하는 핵심 역할을 하여, 상태 변경에 따라 올바른 UI 컴포넌트가 동적으로 업데이트되도록 보장함.
- Compose Runtime은 갭 버퍼(Gap Buffer) 자료 구조에서 영감을 받은 슬롯 테이블(Slot Table)을 사용하여 컴포지션 상태를 메모이징하는 방식으로 작동함.
- 내부적으로는 반응형 UI구축에 필수적인 몇 가지 중요한 작업을 수행함. 여기에는 사이드 이펙트 관리, remember를 사용한 상태 보존, 상태 변경 시 recomposition 트리거, CompositionLocal을 사용한 컨텍스트별 데이터 저장, UI 계층 구조를 효율적으로 생성하기 위한 Compose 레이아웃 노드 구축 등이 포함됨.

<br><br><br>

#### 갭 버퍼에서 링크 테이블로 마이그레이션

- AOSP 코드를 살펴보면, 안드로이드 팀은 갭 버퍼에서 링크 테이블 자료 구조로 마이그레이션 하고 있다.
- 링크 테이블은 연결된 노드를 사용하여 데이터를 구성하므로 요소의 효율적인 삽입, 삭제 및 재배열이 가능함.
- 해당 변경 사항은 SlotTable의 편집 성능을 향상시키면서, 동시에 현재 구현된 동작 방식의 효율성을 유지하는 것을 목표로 함.

<br><br><br>

#### Compose UI

- Compose UI 계층은 애플리케이션 구축을 위한 고수준 컴포넌트 및 UI 위젯을 제공.
- 텍스트, 버튼, 레이아웃 컨테이너와 같은 기본 요소와 커스텀 UI 컴포넌트 구축을 위한 더 상위호환의 API를 포함.
- 내부적으로 들어가면 Compose UI 모듈은 근본적으로 안드로이드의 전통적인 UI 시스템 위에서 동작하는 한편으로, 그 위에서 동작하는 Compose의 메커니즘이 따로 있기 때문에 생각보다 복잡한 과계를 이루고 있기에, 기존의 안드로이드 UI 시스템과 완전히 분리된 개념이라고 생각하기는 어려움.
- Compose UI 라이브러리는 Compose Runtime에 의해 처리되는 Compose 레이아웃 트리 구축을 단순화하도록 설계된 광범위한 컴포넌트를 제공함.

<br><br><br>

### Q1.) Compose 페이즈(phase)에 대해 설명해 주세요.

- Jetpack Compose는 UI를 화면에 그릴 때 Composition, Layout, Drawing의 세 가지 주요 단계로 나누어진 렌더링 파이프라인을 따름.

![alt text](assets/Compose%20Phase.png)

<br><br><br>

#### Composition의 주요 작업

- @Composable 함수 실행
- UI 트리 생성 및 업데이트
- Recomposition을 위한 변경사항 추적

<br><br><br>

#### Layout의 주요 작업

- Layout 단계는 Composition 단계 바로 직후에 수행됨.
- 제공된 제약 조건에 따라 각 UI 컴포넌트의 크기와 위치를 결정함.
- 각 컴포저블은 자식 요소를 측정하고, 크기를 결정하며, 부모에 대한 상대적 위치를 비치함.

<br><br><br>

#### Drawing

- Drawing 단계는 앞선 Composition, Layout 단계를 마친 UI 컴포넌트가 화면에 렌더링 되는 절차.
- Compose는 안드로이드에서 해당 UI들을 렌더링하기 위해 Skia 그래픽 엔진을 사용하여 부드럽고 하드웨어 가속 기반의 렌더링을 제공함.
- 커스텀 드로잉 로직은 Compose의 Canvas API를 사용하여 구현할 수 있음.

<br><br><br>

### Q2.) Jetpack Compose가 선언적 UI 프레임워크라고 불리는 이유는 무엇인가요?

- Jetpack Compose는 개발자가 상태 변경 시 UI를 어떻게 업데이트할지를 나타내는 것이 아닌, 특정 상태에서 UI가 어떻게 보여야 하는지를 설명하는 선언적 UI 프레임워크의 특성을 갖고 있음.
- 이는 개발자가 뷰를 업데이트하고 UI 일관성을 유지하기 위해 수동으로 UI 일관성을 유지하기 위해 수동으로 UI를 업데이트하는 전통적인 명령형 UI 접근 방식과 비교됨.

<br><br><br>

#### Jetpack Compose에서 선언적 UI의 주요 특징

상태 주도 UI
- 선언적 UI 프레임워크에서는 상태 관리 시스템이 라이브러리 자체에 내장되어 내장되어 있음.
- 시스템은 각 컴포넌트의 상태를 추적하고 상태가 변경될 때 UI를 자동으로 업데이트함.
- 개발자는 특정 상태에 대해 UI가 어떻게 보여야 하는지만 정의하면 되고, 프레임워크가 렌더링 업데이트를 처리함.

컴포넌트 함수 또는 클래스로 정의
- 선언적 UI 프레임워크의 특성 중 하나로는 UI 컴포넌트를 함수 또는 클래스로 표현되는 모듈식 컴포넌트로 정의하도록 함.
- 이러한 컴포넌트는 UI 레이아웃과 동작을 모두 설명하여 xml과 같은 마크업 언어와 kotlin 또는 Java와 같은 네이티브 프로그래밍 언어 간의 간극을 줄임.

직접적인 데이터 바인딩
- 선언적 UI 프레임워크를 사용하면 개발자가 모델 데이터를 UI 컴포넌트에 직접 바인딩하여 수동적으로 데이터를 동기화해야 하는 수고를 덜 수 있음.
- 해당 접근 방식은 더 깔끔하고 유지 관리하기 쉬운 코드를 만듬.
- Jetpack Compose에서 개발자는 함수 매개변수를 통해 데이터를 바인딩하여 기존의 xml처럼 추가적으로 요구되는 데이터 바인딩 계층이나 복잡한 어댑터 패턴을 사용하지 않고도 UI 개발을 크게 단순화함.

컴포넌트 멱등성
- 선언적 프레임워크의 핵심적인 특징은 멱등성임.
- 즉, 컴포넌트는 호출 횟수에 관게없이 동일한 입력에 대해 동일한 출력을 생성함.
- 해당 속성은 컴포넌트의 일관된 동작과 재사용성을 보장함.
- Jetpack Compose에서 모든 @Composable 함수는 본질적으로 멱등성의 성질을 가지므로, 동일한 입력 매개변수에 대하여 반드시 동일한 UI 결과를 생성하여 예측 가능하고 안정적인 UI 렌더링을 가능하도록 함.

<br><br><br>

### Q3.) Recomposition이란 무엇이며 언제 발생하나요? 또한 앱 성능과 어떤 관련이 있나요?

- Jetpack Compose는 이미 렌더링된 UI 레이아웃을 업데이트하기 위해 세 가지 주요 단계를 통하여 상태 변경이 발생할 때마다 UI를 다시 그리는 메커니즘을 사용함.
- 이러한 프로세스를 리컴포지션이라고 하고, 리컴포지션이 발생하면 Composition 단계부터 새롭게 시작하여, 여기서 컴포저블 노드는 UI 변경사항을 Compose RUntime에 알리고, 업데이트된 UI가 최신 상태를 반영하도록 보장함.

<br><br><br>

#### Recomposition이 발생하는 조건

- 대부분의 모바일 애플리케이션에서는 앱 내 데이터 모델을 메모리에 담아 표현하는 상태를 유지함.
- 상태 변경됨에 따라 UI도 함께 동기화되도록 하기 위해 Jetpack Compose는 두 가지 메인 메커니즘을 통해 recomposition을 트리거함.

1. 매개변수에 변경이 발생했을 때
- 컴포저블 함순는 입력 매개변수가 변경될 때 recomposition을 트리거함.
- Compose 런타임은 equals() 함수를 사용하여 새 매개변수 값을 이전 매개변수 값과 비교함.
- 비교 결과가 false이면 런타임은 변경 사항을 인지하고 recomposition을 트리거하여 동기화가 필요한 부분에 한해서만 UI를 업데이트함.

2. 상태 변경이 관찰되었을 때
- Jetpack Compose는 일반적으로 remember 함수와 State API를 함께 사용하여 상태 변경을 모니터링함.
- 이러한 접근 방식은 상태 객체를 메모리에 보존하고 recomposition이 발생했을 때에도 메모리에 저장된 값을 복원하여 UI에 최신 상태를 일관되게 반영하도록 보장함.

<br><br><br>

#### Recomposition과 성능

- Jetpack Compose에서 Recomposition은 UI가 상태 변화를 자동으로 감지하고 동기화 될 수 있도록 하는 반응형 특성을 담당하는 핵심 기능.
- 과도하거나 불필요한 Recomposition은 앱 성능을 저하시킬 수 있음. 따라서, Recomposition 작동 방식과 이를 효과적으로 추적하는 방법을 이해하는 것은 Compose 애플리케이션 최적화에 필수적임.

<br><br><br>

### Q4.) Composable 함수는 내부적으로 어떻게 작동하나요?

- Jetpack Compose는 일반적인 함수를 선언적 UI로 동작시키기 위해 @Composable 어노테이션을 사용함.
- 해당 어노테이션이 붙은 함수는 컴파일 타임 시 Compose Compiler Plugin에 의해 개발자가 작성한 Kotlin 함수를 Jetpack Compose의 내부 메커니즘에 맞는 상태 기반 UI 코드로 변환됨.

<br><br><br>

#### 컴파일러 변환

- 함수에 @Composable 어노테이션을 추가하면 Compose Compiler Plugin이 Kotlin 컴파일 프로세스를 가로챔.
- 컴파일러는 컴포저블 함수를 표준적인 Kotlin 함수로 취급하지 않고, Compose의 반응형 시스템을 추가하기 위해 기존의 함수에 추가적인 매개변수와 각종 ㅗㄹ직을 주입함.
- 가장 중요한 매개변수 중 하나는 컴포지션 상태를 추적하고 UI 상태가 변경될 때 recomposition을 처리하는 Composer 매개변수임.
- Composert 매개변수는 컴파일 타임에 컴파일러가 주입하는 객체이기 때문에 개발자는 해당 존재의 유무 자체를 알지 못해도 되고, 최종적으로 사용되는 API의 형태는 굉장히 심플해짐.

<br><br><br>

#### 컴포지션 및 리컴포지션

- Compose Runtime은 @Composable 함수의 생명주기를 관리함.
- 앞서 다루었던 Compose Phase의 3단계 중 첫 번째 단계인 Composition 단계에서 런타임은 컴포저블 함수를 실행하고 UI 트리를 구축함.
- 해당 트리는 Slot Table이라는 데이터 구조에 저장되어 Compose가 UI를 효율적으로 관리하고 업데이트하는 역할을 담당함.

- 만약, 상태가 변경되면 Recomposition이 트리거됨.
- 업데이트 해야 하는 UI 트리를 다시 빌드하는 대신 Compose는 슬롯 테이블을 사용하여 UI의 어떤 부분을 업데이트해야 하는 지 결정하고, 해당 컴포저블 함수만 선택적으로 다시 실행함.
- 이는 추후에 살펴볼 Smart Recomposition이라는 동작과 관련있음.

<br><br><br>

#### Remember 및 상태 관리

- 상태를 관리하기 위해 Compose는 Remember 및 State와 같은 API를 제공함.
- 이러한 메커니즘은 런타임 및 컴파일러와 긴밀하게 작용하여, recomposition으로부터 상태를 보존하여 UI가 앱의 데이터 모델과 일관성을 유지하도록 보장함.

<br><br><br>

### Q5.) Jetpack Compose의 안정성이란 무엇이며, 성능과 어떤 관련이 있나요?

- Jetpack Compose의 안정성은 클래스나 타입이 동일한 매겨변수 입력값에 대해 일관된 결과를 생성하도록 보장하는 속성을 나타냄.
- 안정적인 클래스나 함수는 Recomposition이 여러 번 발생하더라도 개발자의 의도와는 다르게 동작이 변경되지 않도록 보장함.
- 이러한 특성은 Jetpack Compose가 중복된 recomposition 없이 UI 업데이트를 효율적으로 처리하도록 하는 데 중요함.
- Recomposition은 이미 렌더링된 UI를 업데이트하기 위해 다양한 메커니즘을 통해 트리거됨.
- 이 중 컴포저블 함수의 매개변수 안정성은 Compose의 런타임과 컴파일러가 recomposition이 필요한 시기를 결정하는 방식에 있어서 중추적인 역할을 함.
- Compose는 컴파일러는 컴포저블 함수의 매개변수를 검사하고 stable 또는 Unstable로 분류함.
- 이러한 분류는 Compose 런타임이 매개변수의 입력값 변경에 따라 컴포저블 함수를 다시 렌더링해야 하는지 여부를 결정하는 데 사용되므로 효율적으로 Recomposition을 관리하고 앱 성능을 향상시키는 데 매우 중요함.

<br><br><br>

#### Stable vs Unstable

- String을 포함한 원시타입(Primitive Type)이 읽기 전용인 val로 정의된다면, 고유한 값은 변경되지 않으므로 Stable임.
- 값을 캡처하지 않는 람다 표현식과 같은 함수 타입도 동작이 예측 가능하므로 stable로 간주됨
- 클래스, 특히 읽기 전용이거나 변경 불가능하다고 stable한 Public 속성을 가진 데이터 클래스는 Stable로 간주됨. 또한 @Stable, @Immutable과 같은 안정성 어노테이션이 명시적으로 붙어있는 클래스는 stable로 간주됨.

<br><br><br>

#### Compose 함수 추론하기

- Compose 컴파일러가 컴포저블 함수의 유형을 추론하고 최적화하는 원리를 잘 이해하는 것도 중요함.
- Compose 컴파일러는 Kotlin 컴파일러 플러그인 기반으로, 컴파일 타임에 개발자가 작성한 소스 코드를 분석함.
- 분석 외에도 효율적인 실행을 위해 컴포접르 함수의 고유한 요구 사항에 맞게 개발자가 작성한 원본 소스 코드를 수정함.
- 성능을 최적화하기 위해 컴파일러는 컴포저블 함수를 Restartable, Skippable, Moveable, Replaceable과 같은 유형으로 분류함.

<br><br><br>

재실행 가능
- Compose 컴파일러에 의해 결정되는 컴포접르 유형으로, Restartable로 분류된 함수는 Recomposition 프로세스의 기반을 형성함.
- 즉, 매개변수 입력값 또는 상태가 변경되면 Compose 런타임은 UI를 업데이트하기 위해 recomposition을 위해 함수를 재호출함.
- 대부분의 컴포저블 함수는 기본적으로 Restartable로 간주되므로 런타임이 필요할 때마다 Recomposition을 트리거할 수 있음.

생략 가능
- Skippable 함수는 스마트 recomposition에 의해 활성화된 특정 조건 하에서 recomposition을 건너뛸 수 있음.
- 이러한 Recomposition 최적화는 복잡한 컴포저블 계층 구조의 최상위 노드에 있는 루트 컴포저블의 성능 향상에 중요한데, Recomposition을 건너뛰면 하위 함수를 재호출 하지 않아도 되기 떄문임.
- 특히, 컴포저블 함수는 restartable이면서 동시에 skippable일 수 있음.
- 이는 필요할 때 Recomposition을 수행할 수 있지만, 조건이 허용되면 건너뛸 수 있음을 의미함.
