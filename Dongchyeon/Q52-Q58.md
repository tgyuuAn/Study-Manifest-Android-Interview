### 52. DataBinding의 동작 원리에 대해서 설명해주세요.

- XML 레이아웃의 UI 컴포넌트를 앱의 데이터 소스에 직접 바인딩할 수 있는 안드로이드 라이브러리
- findViewById와 같은 보일러 플레이트 코드를 줄이고, UI와 데이터 모델 간의 실시간 업데이트를 허용
- UI 디자인에 선언적 프로그래밍을 부분적으로 가능하게 함

#### DataBinding 활성화하기

```kotlin
// build.gradle (app 수준)
android {
    ...
    buildFeatures {
        dataBinding true
    }
}
```

#### DataBinding 작동 방식

- DataBinding은 <layout> 태그를 사용하는 각 XML 레이아웃에 대한 바인딩 클래스를 생성

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <data>
        <variable
            name="vm"
            type="com.example.myapp.ui.UserViewModel" />
    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:padding="16dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{vm.user.name}" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text='@{String.valueOf(user.age)}' />
        
        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Enter name"
            android:text="@={vm.input}" /> <!-- 양방향 바인딩 -->
        
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Update User"
            android:onClick="@{() -> vm.updateUser(vm.user)}" />
    </LinearLayout>
    
</layout>
```

#### 코드에서 데이터 바인딩하기

```kotlin
class MainActivity : AppCompatActivity() {
    // ViewModel 인스턴스 (예: Hilt 또는 ViewModelProvider 사용)
    private val viewModel: UserViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // DataBindingUtil을 사용하여 레이아웃 설정 및 바인딩 객체 가져오기
        val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        
        // 바인딩 변수에 ViewModel 및 데이터 모델 설정
        binding.vm = viewModel
        
        // LifecycleOwner 설정 (LiveData 바인딩 등에 필요)
        binding.lifecycleOwner = this
    }
}

// 예시 User 및 ViewModel
data class User(val name: String, val age: Int)

class UserViewModel : ViewModel() {
    private val _user = MutableLiveData<User>(User("Alice", 25))
    val user: LiveData<User> = _user
    
    // input MutableLiveData가 EditText와 양방향 바인딩되어 있으므로
    // EditText 내용이 변경되면 input 값이 자동으로 업데이트됩니다.
    val input = MutableLiveData<String>()   // 양방향 바인딩용
    
    fun updateUser(user: User?) {
        // 사용자 업데이트 로직 (예시)
        Log.d("DataBinding", "Updating user clicked for: ${user?.name}")
        _user.value?.let { currentUser ->
            val updatedUser = currentUser.copy(name = input.value.orEmpty())
            _user.value = updatedUser
        }
    }
}
```

- user 객체는 레이아웃의 데이터 소스로 설정되고, 데이터가 변경되면 UI에 자동으로 업데이트

#### DataBinding의 특징

1. 양방향 데이터 바인딩(Two-way Data Binding)
    - UI와 기본 데이터 모델 간의 데이터 자동 동기화를 가능하게 함
    ```xml
    <EditText
        android:layout_width="match_parent" 
        android:layout_height="wrap_content"
        android:hint="Enter name"
        android:text="@={vm.input}" /> <!-- 양방향 바인딩 -->
    ```

2. 바인딩 표현식(Binding Expressions)
    - 문자열 연결 또는 조건문과 같은 간단한 로직을 XMl에서 직접 사용 가능
    ```xml
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@{user.age > 18 ? `성인` : `미성년자`}"
        android:visibility="@{user.isAdmin ? View.VISIBLE : View.GONE}"/>
    ```

3. 생명주기 인식(Lifecycle Awareness)
    - Activity 또는 Fragment가 활성화 상태일 때 UI를 자동으로 업데이트

#### DataBinding의 장점

- 보일러 플레이트 코드 감소: findViewById() 및 명시적인 UI 업데이트가 필요 없어짐
- 실시간 UI 업데이트: 데이터 변경 사항을 UI에 자동으로 반영
- 선언적 UI: 로직을 XML로 이동하여 잘 사용하면 복잡한 레이아웃 단순화 가능
- 테스트 용이성 향상: UI와 코드를 분리하여 둘 다 독립적으로 테스트하기 쉽게 만듦

#### DataBinding의 단점

- 성능 오버헤드: ViewBinding과 같은 더 가벼운 솔루션에 비해 더 많은 런타임 오버헤드가 발생
- 복잡성: 작거나 간단한 프로젝트에는 불필요한 복잡성을 유발
- 학습 곡선: 바인딩 표현식 및 생명주기 관리에 대한 러닝 커브가 요구

#### 실전 질문

Q) DataBinding과 ViewBinding의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 선택하는 것이 좋을까요?

A) DataBinding은 UI 컴포넌트를 데이터 소스에 직접 바인딩할 수 있는 반면, ViewBinding은 단순히 레이아웃의 뷰에 대한 타입 안전한 참조를 제공하는 데 중점을 둡니다. DataBinding은 양방향 바인딩과 복잡한 UI 로직을 XML에서 처리할 수 있는 기능을 제공하지만, ViewBinding은 더 가볍고 성능 오버헤드가 적습니다.

Q) MVVM 아키텍처에서 DataBinding은 어떤 역할을 하며, 안드로이드 개발에서 UI 로직과 비즈니스 로직을 분리하는 데 어떻게 활용할 수 있나요?

A) MVVM 아키텍처에서 DataBinding은 ViewModel과 UI(View) 간의 연결 고리 역할을 합니다. ViewModel의 데이터를 XML 레이아웃에 바인딩하여 UI가 데이터 변경 사항을 자동으로 반영하도록 합니다. 이를 통해 UI 로직과 비즈니스 로직을 분리할 수 있으며, ViewModel은 UI 상태를 관리하고 비즈니스 로직을 처리하는 데 집중할 수 있습니다. DataBinding을 사용하면 UI 업데이트 코드가 줄어들고, 테스트 가능성이 향상됩니다.

#### Pro Tips for Mastery: ViewBinding과 DataBinding의 차이점은 무엇인가요?

- ViewBinding과 DataBinding은 모두 앱에서 뷰 작업을 할 때 null 안정성 및 효율적으로 레이아웃 요소에 접근하기 위해 안드로이드에서 제공하는 라이브러리
- ViewBinding은 findViewById 없이 레이아웃의 뷰에 접근하는 것은 단순화하기 위한 목적
- ViewBinding의 주요 특징
  - XML 레이아웃 파일에 대한 바인딩 클래스 생성
  - 레이아웃의 뷰에 대한 직접 참조를 제공하여 findViewById 없이 안전하게 레이아웃 요소에 접근
  - nullable 및 뷰 유형에 대한 컴파일 타임 검사를 제공하여 타입 안정성을 보장
  - 바인딩 표현식이나 데이터 기반 업데이트와 같은 고급 기능은 지원하지 않음
- DataBinding은 UI 컴포넌트를 데이터 소스에 직접 바인딩할 수 있는 더 복잡하고 유연한 라이브러리
- DataBinding의 주요 특징
  - XML에서 UI 요소를 데이터 소스에 바인딩 가능
  - UI 컴포넌트를 동적으로 업데이트하기 위한 바인딩 표현식을 지원
  - UI와 데이터 간의 실시간 동기화를 위한 양방향 데이터 바인딩을 제공
  - LiveData 및 StateFlow와 같이 생명주기에 따라 관찰 가능한 타입의 데이터 통합을 제공

#### 주요 차이점

1. 목적
   - ViewBinding은 뷰 접근을 단순화하는 반면, DataBinding은 고급 데이터 기반 UI 바인딩을 가능하게 함
2. 컴파일 타임 클래스 생성
   - ViewBinding은 뷰에 대한 직접 참조를 생성
   - DataBinding은 뷰에 대한 직접 참조 뿐만 아니라 내장 데이터 바인딩 기능이 있는 추가 클래스도 생성
3. 표현식
   - ViewBinding은 XML에서 표현식을 지원하지 않음
   - DataBinding은 바인딩 표현식과 동적 데이터 바인딩을 지원
4. 양방향 바인딩
   - DataBinding만 양방향 바인딩을 지원
5. 성능
   - ViewBinding은 데이터 바인딩 로직을 처리하지 않으므로 더 빠르게 오버헤드가 적음

### 53. LiveData에 대해서 설명해 주세요.

- LiveData는 연관된 컴포넌트가 활성 생명주기 상태(예를 들어, started 또는 resumed 상태)일 때만 데이터를 관찰하고 UI를 업데이트하도록 보장
- LiveData의 주요 목적은 UI 컴포넌트가 데이터 변경 사항을 관찰하고 해당 데이터가 변경될 때마다 UI를 반응형으로 업데이트할 수 있도록 하는 것
- LiveData가 제공하는 이점은 다음과 같음.
  1. 생명주기 인식(Lifecycle Awareness)
     - LiveData는 생명주기를 관찰하고 컴포넌트가 활성화 상태일 때만 데이터를 업데이트하여 크래시 및 메모리 누수 위험을 줄임
  2. 자동 정리(Automatic Cleanup)
     - 컴포넌트에 연결된 관찰자는 주어진 생명주기가 소멸될 때 자동으로 제거되고 정리
  3. 관찰자 패턴(Observer Pattern)
     - UI 컴포넌트는 관찰자를 활용하여 LiveData의 데이터가 변경될 때 자동으로 업데이트
  4. 스레드 안전성(Thread Safety)
     - LiveData는 스레드 안전하도록 설계되어 백그라운드 스레드에서 업데이트할 수 있음

```kotlin
// ViewModel
class MyViewModel : ViewModel() {
    // 내부 수정을 위한 MutableLiveData
    private val _data = MutableLiveData<String>()
    // 외부 수정을 방지하기 위해 LiveData로 노출
    val data: LiveData<String> get() = _data
    
    fun updateData(newValue: String) {
        // LiveData 값 업데이트
        _data.value = newValue
    }
}

// Fragment 또는 Activity
class MyFragment : Fragment() {
    private val viewModel: MyViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // LiveData 관찰
        viewModel.data.observe(viewLifecycleOwner) { newValue ->
            // 새 데이터로 UI 업데이트
            textView.text = newValue
        }
    }
}
```

#### MutableLiveData와 LiveData의 차이점

- MutableLiveData
  - setValue() 또는 postValue()를 통해 데이터 수정을 허용
  - 외부에서의 직접적인 수정을 방지하기 위해 ViewModel 내에서 비공개로 유지
- LiveData
  - 외부 컴포넌트가 데이터를 수정하는 것을 방지하는 읽기 전용 버전의 LiveData로, 더 나은 캡슐화를 보장

#### LiveData의 사용 사례

1. UI 상태 관리
   - LiveData는 네트워크 응답이나 데이터베이스와 같은 소스의 데이터를 담는 역할을 하여 UI 컴포넌트에 원활하게 바인딩될 수 있도록 함
   - 이를 통해 기본 데이터가 변경될 때마다 UI가 자동으로 업데이트
2. 관찰자 패턴 구현
   - LiveData는 발행자(publisher) 역할을 하고 Observer 인터페이스 구현이 구독자(subscriber) 역할을 하는 관찰자 패턴을 따름
   - LiveData가 변경될 때마다 구독자에게 실시간 업데이트를 용이하게 하여 동적 UI 업데이트나 데이터 기반 상호 작용과 같은 시나리오에 적합
3. 일회성 이벤트
   - 토스트를 노출시키거나 다른 화면으로 이동하는 one-off 일회성 이벤트에서 사용 가능
   - 단, 이러한 경우는 SingleLiveEvent 또는 유사한 구현으로 커스텀하여 처리해야 함

#### Additional Tips: LiveData vs. StateFlow

- Flow는 안드로이드와 완전히 독립적인 API이고 안드로이드 컴포넌트에 대한 수명주기를 전형 알지 못함
- 따라서, Flow는 구독 (collect) 및 구독 해지를 안드로이드 라이프사이클에 따라 올바르게 하지 않으면, 메모리 누수로 이어짐
- 반면, LiveData는 구독 시점부터 애초에 lifecycle 인스턴스를 결합하도록 하여, 개발자가 구독 해지를 신경쓰지 않아도 됨
- "안드로이드 의존성을 제거하기 위해 LiveData를 Flow로 마이그레이션 한다" 라는 의견 또한 특별히 설득력이 없는 문장
    - 일반적으로 LiveData 타입이 네트워크 모듈의 응답 타입으로 정의되어 ViewModel까지 이어짐
    - Hilt를 비롯한 모든 Jetpack 관련 라이브러리를 모두 제거하면서까지 JVM 타입의 멀티모듈 설계를 통해 얻어갈 수 있는 성능적 & 구조적인 이점은 없음
    - 따라서, 다수의 선택을 단순히 따라가기 보다는 데이터에 대해 복잡한 가공처리가 필요하거나 Flow를 레버리지할 수 있는 명백한 상황에서 Flow를 채택하는 것이 올바른 선택

#### 실전 질문

Q) LiveData는 생명주기 인식을 어떻게 보장하며, RxJava 또는 EventBus와 같은 전통적인 observable한 객체와 비교하여 어떤 이점을 제공하나요?

A) LiveData는 안드로이드 컴포넌트의 생명주기를 인식하여, 컴포넌트가 활성 상태일 때만 데이터를 업데이트하고 관찰자를 알림으로써 크래시 및 메모리 누수 위험을 줄입니다. 반면, RxJava나 EventBus는 생명주기 관리를 자동으로 처리하지 않으므로, 개발자가 직접 구독 해지를 관리해야 하며, 이로 인해 메모리 누수나 크래시가 발생할 수 있습니다. LiveData는 이러한 생명주기 관리를 자동으로 처리하여 더 안전하고 간편한 데이터 관찰을 제공합니다.

Q) LiveData에서 setValue()와 postValue()의 차이점은 무엇이며, 각각 언제 사용해야 하나요?

A) setValue()는 메인 스레드에서 호출되어야 하며, 즉시 LiveData의 값을 업데이트합니다. 반면, postValue()는 백그라운드 스레드에서 호출할 수 있으며, 내부적으로 메인 스레드에서 값을 업데이트하도록 예약합니다. 따라서, UI 스레드에서 값을 즉시 변경해야 할 때는 setValue()를 사용하고, 백그라운드 작업 중에 값을 변경해야 할 때는 postValue()를 사용하는 것이 적절합니다.

Q) LiveData의 한계는 무엇이며, 구성 변경 시 다시 트리거되지 않고 내비게이션 또는 토스트 메시지 표시와 같은 여러 UI 이벤트를 관찰해야 하는 경우에 어떻게 처리해야 하나요?

A) LiveData는 구성 변경 시 다시 트리거 된다는 한계가 있습니다. 이를 해결하기 위해 SingleLiveEvent와 같은 커스텀 구현을 사용하여 일회성 이벤트를 처리할 수 있습니다. SingleLiveEvent는 이벤트가 한 번만 소비되도록 보장하여, 내비게이션이나 토스트 메시지와 같은 UI 이벤트를 안전하게 처리할 수 있습니다. 또는 EventWrapper와 같은 패턴을 사용하여 이벤트가 한 번만 처리되도록 할 수도 있습니다.

#### Pro Tips for Mastery: LiveData에서 setValue()와 postValue()의 차이점은 무엇인가요?

##### 1. setValue()

- setValue() 메소드는 데이터를 동기적으로 업데이트하며 메인 스레드(UI 스레드)에서만 호출
- 값을 즉시 업데이트하고 변경 사항이 동일한 프레임 동안 관찰자에게 반영되도록 해야 할 때 사용

```kotlin
val liveData = MutableLiveData<String>()

fun updateOnMainThread() {
    if (Looper.myLooper() == Looper.getMainLooper()) {
        liveData.setValue("Updated Value")// 메인 스레드에서 호출
    } else {
        Log.e("LiveData", "setValue() must be called on the main thread")
    }
}
```

##### 2. postValue()

- postValue() 메소드는 데이터를 비동기적으로 업데이트하며 백그라운드 스레드에서 UI를 업데이트해야 하는 경우에 적합
- 호출되면 메인 스레드에서 업데이트가 발생하도록 예약하여 현재 스레드를 차단하지 않고 스레드 안전성을 보장

```kotlin
val liveData = MutableLiveData<String>()

fun updateInBackground() {
    Thread {
        // 백그라운드 스레드에서 값 전달
        liveData.postValue("Updated Value") // 모든 스레드에서 호출 가능
    }.start()
}
```

- postValue()는 네트워크 요청이나 데이터베이스 쿼리와 같은 백그라운드 작업과 관련된 시나리오에서 특히 유용
- postValue() 메소드의 내부 구현을 살펴보면 백그라운드 실행자를 활용하여 값을 메인 스레드에 전달

```java
protected void postValue(T value) {
    boolean postTask;
    synchronized (mDataLock) {
        postTask = mPendingData == NOT_SET; // 이전에 전달된 작업이 없는지 확인
        mPendingData = value;   // 보류 중인 데이터 업데이트
    }
    if (!postTask) {
        return; // 이미 전달된 작업이 있으면 반환
    }
    // 메인 스레드 실행자에 Runnable 실행
    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
}
```

- 이 메소드는 먼저 mDataLock에서 동기화하고 mPendingData를 업데이트하여 작업을 실행해야 하는지 확인
- 값이 이미 보류 중이면 중복 실행을 피함
- 그렇지 않으면 mPostValueRunnable을 ArchTaskExecutor를 메인 스레드에에서 실행되도록 예약하여 스레드 안전 업데이트를 보장

```kotlin
liveData.postValue("a")
liveData.setValue("b")
```

- 위의 코드가 실행되면 값 "b"가 즉시 반영되고, 나중에 메인 스레드가 전달 받은 작업을 처리할 때 "b"를 "a"로 덮어씀
- postValue()가 업데이트를 비동기적으로 예약하는 반면 setValue()는 메인 스레드에서 동기적으로 값을 업데이트하기 때문에 발생
- 또한 postValue()를 여러 번 호출하면 mPendingData에 가장 최근 값만 유지하므로 마지막 값만 전달

##### 주요 차이점

| 구분     | setValue() | postValue() |
|--------|-------------|-------------|
| 스레드    | 메인 스레드에서 호출해야 함 | 모든 스레드에서 호출 가능 |
| 동기/비동기 | 값을 즉시 동기적으로 업데이트함 | 메인 스레드에서 업데이트를 비동기적으로 예약함 |
| 사용 사례  | UI 업데이트 또는 메인 스레드에서 시작된 변경 | 백그라운드 스레드 업데이트 또는 비동기 작업 |
| 관찰자 패턴 | 동일한 프레임 동안 관찰자를 즉시 트리거함 | 메인 스레드 처리 후 다음 프레임에서 관찰자를 트리거함 |

##### 일반적인 사용 패턴

- setValue() 사용
  - 사용자 상호 작용이나 생명주기 기반 이벤트와 같이 업데이트가 메인 스레드에서 직접 트리거될 때 적합
- postValue() 사용
  - 데이터베이스에서 데이터를 쿼리하거나, 네트워크 호출 수행 또는 그 외 장기적으로 실행되는 작업과 같은 백그라운드 스레드로 작업 중이면서 값을 업데이트해야할 때 적합

### 54. Jetpack ViewModel에 대해 설명해 주세요.

- JetPack ViewModel은 생명주기를 인식하는 방식으로 UI 관련 데이터를 저장하고 관리하도록 만들어진 안드로이드 아키텍처 컴포넌트의 핵심 구성 요소
- ViewModel의 주요 목표는 구성 변경 중에 UI 관련 데이터를 보존하는 것
  - 예를 들어, 사용자가 기기를 회전하면 Activity 또는 Fragment가 소멸되고 다시 생성되지만 ViewModel은 파괴되지 않아 데이터가 그대로 유지되도록 보장

```kotlin
data class DiceUiState(
    val firstDieValue: Int? = null,
    val secondDieValue: Int? = null,
    val numberOfRolls: Int = 0,
)

class DiceRollViewModel : ViewModel() {
    
    // 화면 UI 상태 노출
    private val _uiState = MutableStateFlow(DiceUiState())
    val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()
    
    // 비즈니스 로직 처리
    fun rollDice() {
        val firstDieValue = (1..6).random()
        val secondDieValue = (1..6).random()
        val numberOfRolls = _uiState.value.numberOfRolls + 1
        
        _uiState.value = DiceUiState(
            firstDieValue = firstDieValue,
            secondDieValue = secondDieValue,
            numberOfRolls = numberOfRolls
        )
    }
}
```

#### ViewModel의 특징

1. 생명주기 인식(Lifecycle Awareness)
   - ViewModel은 Activity 또는 Fragment의 생명주기에 범위가 지정
   - 사용자가 화면에서 벗어나는 등 UI 컴포넌트가 더 이상 사용되지 않을 때 자동으로 소멸
2. 구성 변경 간 지속성(Persistence Across Configuration Changes)
   - 구성 변경 중에 소멸되고 다시 생성되는 Activity 또는 Fragment와 달리 ViewModel은 유지되어 UI 관련 데이터를 보존
3. 관심사 분리(Separation of Concerns)
   - ViewModel은 UI 관련 로직과 비즈니스 로직을 분리하여 더 깔끔하고 유지 관리하기 쉬운 코드를 설계하는 데 도움이 됨
   - UI 레이어는 ViewModel에서 업데이트를 관찰하므로 반응형 프로그래밍 원칙을 구현하기가 더 쉬워짐

#### ViewModel 생성 및 사용

- Jetpack activity-ktx 라이브러리에서 제공하는 ComponentActivity의 확장 함수인 viewModels() delegate를 사용하여 ViewModel을 보다 쉽게 생성

```kotlin
class DiceRollActivity : AppCompatActivity() {
    
    // activity-ktx 아티팩트의 'viewModels()' Delegate 함수 사용
    private val viewModel: DiceRollViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 시스템이 액티비티의 onCreate() 메소드를 처음 호출할 때 ViewModel 생성
        // 다시 생성된 액티비티는 첫 번째 액티비티에서 생성된 동일한 DiceRollViewModel 인스턴스를 사용
        
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { uiState ->
                    // UI 요소 업데이트 (예: 텍스트뷰 업데이트)
                    // updateUi(uiState)
                }
            }
        }
    }
}
```

- ViewModel 인스턴스는 ViewModel 인스턴스의 생명주기를 관리하기 위한 메커니즘 역할을 하는 ViewModelStoreOwner에 스코프가 지정됨
- Activity, Fragment, Navigation 그래프 내 대상 등이 ViewModelStoreOwner가 될 수 있음

#### 실전 질문

Q) ViewModel은 구성 변경 시 데이터를 어떻게 유지하며, onSaveInstanceState()를 사용하여 상태를 저장하는 것과 어떻게 다른가요?

A) ViewModel은 구성 변경 시에도 데이터를 유지하는 반면, onSaveInstanceState()는 일시적인 상태 저장에 사용됩니다. ViewModel은 Activity 또는 Fragment가 소멸되고 다시 생성될 때도 데이터를 유지하지만, onSaveInstanceState()는 프로세스가 종료되거나 시스템에 의해 앱이 강제 종료될 때 데이터를 복원하는 데 사용됩니다.

Q) ViewModelStoreOwner의 목적은 무엇이며, 동일한 Activity 내의 여러 Fragment 간에 ViewModel을 어떻게 공유할 수 있나요?

A) ViewModelStoreOwner는 ViewModel 인스턴스의 생명주기를 관리하는 역할을 합니다. 동일한 Activity 내의 여러 Fragment 간에 ViewModel을 공유하려면, Fragment에서 Activity의 ViewModelStoreOwner를 사용하여 ViewModel을 생성하면 됩니다. 이렇게 하면 모든 Fragment가 동일한 ViewModel 인스턴스를 참조하게 되어 데이터를 공유할 수 있습니다.

Q) UI 상태 관리를 위해 ViewModel 내에서 StateFlow 또는 LiveData를 사용하는 것의 장점과 잠재적인 단점은 무엇인가요?

A) ViewModel 내에서 StateFlow 또는 LiveData를 사용하면 UI 상태를 관찰하고 자동으로 업데이트할 수 있어 반응형 프로그래밍이 가능해집니다. 이는 코드의 가독성과 유지보수성을 향상시키고, 생명주기 인식을 통해 메모리 누수를 방지합니다. 그러나 이러한 접근 방식은 추가적인 학습 곡선과 약간의 성능 오버헤드를 초래할 수 있으며, 복잡한 상태 관리가 필요한 경우에는 적절한 설계가 필요합니다.

#### Pro Tips for Mastery: ViewModel의 생명주기는 어떻게 되나요?

- ViewModel의 생명주기는 ViewModelStoreOwnwer(Activity, Fragment 또는 기타 생명주기 인식 컴포넌트)에 연결
- ViewModel은 ViewModelStoreOwner의 범위 내에서 존재하며, 화면 회전과 같은 구성 변경 시에도 데이터와 상태가 유지되도록 보장

![뷰모델_생명주기.png](assets/%EB%B7%B0%EB%AA%A8%EB%8D%B8_%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0.png)

- ViewModelStoreOwner가 처음 생성될 때 ViewModel 인스턴스가 초기화됨
- 소유자가 메모리에 남아 있는 한 동일한 ViewModel 인스턴스가 유지
- ViewModel은 ViewModelStoreOwner가 영구적으로 소멸될 때 비로소 제거
- 예를 들어, Activity가 완료되거나 Fragment가 부모에서 제거되고 돌아올 것으로 예상되지 않으면 ViewModel의 onCleared() 메소드가 호출

#### Pro Tips for Mastery: 구성 변경 후에도 ViewModel이 어떻게 유지될 수 있나요?

- ViewModel이 UI 컴포넌트를 위해 생성될 때 컴포넌트의 생명주기 소유자(lifecycle owner)에 연결
- Jetpack 라이브러리의 내부 구현을 살펴보면 ComponentActivity, Fragment가 모두 ViewModelStoreOwner 인터페이스를 구현
- ViewModelStore는 String과 ViewModel이 1:1 쌍을 이루도록 Map 형태로서 ViewModel 인스턴스를 관리

```kotlin
public open class ViewModelStore {
    
    private val map = mutableMapOf<String, ViewModel>()
    
    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public fun put(key: String, viewModel: ViewModel) {
        val oldViewModel = map.put(key, viewModel)
        oldViewModel?.clear() // 이전 ViewModel 정리
    }
    
    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public operator fun get(key: String): ViewModel? {
        return map[key]
    }
    
    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public fun keys(): Set<String> {
        return HashSet(map.keys)
    }

    /**
     * ViewModelStore에서 모든 ViewModel을 지움
     * 이후에 저장된 ViewModel은 clear()가 호출될 때까지 유지됨
     */
    public fun clear() {
        for (vm in map.values) {
            vm.clear() // 각 ViewModel의 리소스 정리
        }
        map.clear() // 맵 비우기
    }
}
```

- ComponentActivity는 자체 생명주기 상태를 관찰하는 능력을 가지고 있음
- Activity가 생성될 때, onDestroy()가 구성 변경으로 트리거 되지 않은 경우 생명주기 상태가 ON_DESTROY로 전환되면 유지된 모든 ViewModel 인스턴스를 지우는 메커니즘으로 동작

```java
getLifecycle().addObserver(new LifecycleEventObserver() {
    @Override
    public void onStateChanged(@NonNull Lifecycle source, @NonNull Lifecycle.Event event) {
        if (event == Lifecycle.Event.ON_DESTROY) {
            // 사용 가능한 컨텍스트 지우기
            mContextAwareHelper.clearAvailableContext();
            // Activity가 구성 변경 없이 파괴될 때 ViewModelStore 정리
            if (!mChangingConfigurations) {
                getViewModelStore().clear();
            }
            mReportFullyDrawnListener.activityDestroyed();
        }
    }
});
```

#### Pro Tips for Mastery: Jetpack ViewModel과 Microsoft에서 제시한 MVVM 아키텍처 ViewModel의 차이점에 대해서 설명해 주세요.

- 공식 문서에 따르면 Jetpack ViewModel은 비즈니스 로직 또는 UI 상태 홀더 역할을 하도록 설계된 생명주기를 인식하는 컴포넌트
- 반면, Microsoft에서 도입한 MVVM (Model-View-ViewModel) 아키텍처는 ViewModel을 View와 Model 간의 다리 역할을 한다고 설명
- MVVM의 ViewModel은 View와 Model 간의 상호 작용을 조정하고 UI에 필요한 비즈니스 로직을 추상화하거나 호출을 중개하는 역할을 함
- 상태 관리 및 안드로이드 컴포넌트 생명주기를 인지하는 것에 중점을 둔 Jetpack ViewModel과 달리
- MVVM ViewModel은 View가 상태 변경에 반응할 수 있도록 하는 바인딩 메커니즘(Data Binding)을 강조하여 더 선언적이고 모듈화된 설계를 용이하게 함

![MVVM_패턴.png](assets/MVVM_%ED%8C%A8%ED%84%B4.png)

##### Jetpack ViewModel과 MVVM ViewModel의 차이점

- Jetpack ViewModel은 구성 변경 시 UI 관련 상태를 유지하는 데 의의를 두어, 생명주기를 인식하는 UI 상태 관리에 초점을 둠.
- 반면에, MVVM ViewModel은 View와 Model 간의 중개자 역할을 하며 바인딩을 처리하고 UI가 ViewModel에서 제공하는 데이터를 표시하는 데만 관련되도록 보장
- MVVM의 원래 의도를 충족하려면 개발자는 UI가 ViewModel에서 제공하는 데이터에 수동적으로 반응하도록 보장하는 추가 바인딩 메커니즘을 구현해야 함

### 55. Jetpack Navigation 라이브러리란 무엇인가요?

- Jetpack Navigation 라이브러리는 앱 내 네비게이션을 단순화하고 표준화하기 위해 안드로이드에서 제공하는 프레임워크
- Activity, Fragment, Composable에 대한 네비게이션을 관리하는 API를 제공하며, 딥 링크, 백 스택 관리 및 애니메이션과 같은 추가 기능도 제공

#### 네비게이션 그래프 (Navigation Graph)

- 네비게이션 그래프는 앱 대상(화면) 간의 네비게이션 흐름과 관계를 정의하는 XML 리소스

```xml
<?xml version="1.0" encoding="utf-8" ?>
<navigaiton xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/nav_graph"
    app:startDestination="@id/homeFragment">

    <fragment
        android:id="@+id/homeFragment"
        android:name="com.example.app.HomeFragment"
        android:label="Home"
        tools:layout="@layout/fragment_home" >
        <action
            android:id="@+id/action_home_to_detail"
            app:destination="@id/detailFragment" />
    </fragment>

    <fragment
        android:id="@+id/detailFragment"
        android:name="com.example.app.DetailFragment"
        android:label="Detail"
        tools:layout="@layout/fragment_detail">
        <argument
            android:name="itemId"
            app:argType="integer" />
    <fragment/>
</navigaiton>
```

#### NavHostFragment

- NavHostFragment는 네비게이션 그래프의 컨테이너 역할을 하여 대상을 호스팅하고 대상 간의 네비게이션을 관리
- 사용자가 탐색할 때 컨테이너 내에서 Fragment를 동적으로 교체

```xml
<androidx.fragment.app.FragmentContainerView
    android:id="@+id/nav_host_fragment"
    android:name="androidx.navigation.fragment.NavHostFragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:navGraph="@navigation/nav_graph"
    app:defaultNavHost="true" />
```

#### NavController

- NavController는 네비게이션 작업을 처리하고 백 스택을 관리하는 역할을 함
- 이를 사용하여 직접 코드로 목적지 간에 이동하거나 전반적인 네비게이션 흐름을 컨트롤할 수 있음

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val navHostFragment = supportFragmentManager
            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment
        navController = navHostFragment.navController
        
        findViewById<Button>(R.id.navigateButton).setOnClickListener {
            navController.navigate(R.id.action_home_to_detail)
        }
    }
}
```

#### Safe Args

- Safe Args는 Type-safe 네비게이션 및 인수 전달 코드를 생성하는 Gralde 플러그인
- 대상 간 데이터를 전달할 때 수동으로 번들을 만들 필요가 없음

```kotlin
// HomeFragmentDirections 클래스는 Safe Args 플러그인이 생성
val action = HomeFragmentDirections.actionHomeToDetail(itemId = 42)
findNavController().navigate(action)
```

#### Deep Linking

- 딥 링크를 지원하여 사용자가 URL이나 알림과 같은 외부 소스에서 특정 화면으로 직접 이동할 수 있도록 함

```xml
<fragment
    android:id="@+id/detailFragment"
    android:name="com.example.app.DetailFragment"
    android:label="Detail"
    tools:layout="@layout/fragment_detail">
    <deepLink
        app:uri="https://www.example.com/item/{itemId}" /> <!-- itemId 인수를 받는 딥 링크 -->
</fragment>
```

#### Jetpack Navigation 라이브러리의 이점

1. 중앙 집중식 네비게이션
   - 명확하고 유지 관리 가능한 구조를 위해 모든 네비게이션 흐름을 하나의 XML 파일에서 관리 
2. Type-safe 인수
   - 생성된 Safe Args 클래스를 사용하여 대상 간에 데이터를 안전하게 전달
3. 백 스택 관리
   - 일관된 네비게이션을 위해 백 스택 동작을 자동으로 처리
4. 딥 링크 지원
   - 외부 네비게이션 동작을 원활하게 처리하여 사용자 경험을 향상
5. Jetpack 컴포넌트와의 통합
   - Fragment, ViewModel, LiveData와 같은 다른 Jetpack 컴포넌트와 원활하게 통합하여 생명주기를 고려한 네비게이션 보장

#### 실전 질문

Q) Jetpack Navigation 라이브러리는 어떻게 백 스택을 처리하고, NavController로 어떻게 백 스택을 조작할 수 있나요?

A) Jetpack Navigation 라이브러리는 NavController를 사용하여 백 스택을 자동으로 관리합니다. NavController는 네비게이션 작업을 처리하고, 사용자가 뒤로 가기 버튼을 눌렀을 때 올바른 대상으로 돌아가도록 보장합니다. 개발자는 NavController의 navigate() 메소드를 사용하여 대상 간에 이동할 수 있으며, popBackStack() 메소드를 사용하여 백 스택에서 특정 대상까지 되돌아갈 수 있습니다.

Q) Safe Arguments란 무엇이며, Jetpack Navigation Component에서 목적 네비게이션 간 데이터를 전달할 때 타입 안정성을 어떻게 보장하나요?

A) Safe Arguments는 Jetpack Navigation Component에서 제공하는 Gradle 플러그인으로, 네비게이션 그래프에 정의된 인수를 기반으로 타입 안전한 네비게이션 및 인수 전달 코드를 생성합니다. 이를 통해 개발자는 번들을 수동으로 생성할 필요 없이, 컴파일 타임에 타입 검사를 받을 수 있어 런타임 오류를 줄일 수 있습니다. Safe Args는 각 대상에 대한 Directions 클래스를 생성하여, 해당 클래스의 메소드를 사용하여 안전하게 인수를 전달할 수 있도록 합니다.

### 56. Dagger 2와 Hilt의 동작원리 및 차이점에 대해서 설명해 주세요.

#### Dagger 2란?

- Dagger 2는 안드로이드 및 JVM 환경을 위한 정적 컴파일 타임 기반의 의존성 주입(DI) 라이브러리
- 객체 생성을 관리하고 의존성을 자동으로 제공하여 애플리케이션 테스트를 용이하도록 설계
- Dagger 2는 컴파일 타임에 코드를 생성하여, 리플렉션에 기반한 DI 프레임워크에 비해 더 나은 성능을 보장
- Dagger 2는 @Module, @Provides, @Inject와 같은 어노테이션을 사용하여 의존성을 선언하고 요청

```kotlin
@Module
class NetworkModule {
    @Provides
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com")
            .build()
    }
}

@Component(modules = [NetworkModule::class])
interface AppComponent {
    // MainActivity에 의존성 주입
    fun inject(activity: MainActivity)
}

class MainActivity : AppCompatActivity() {
    // Retrofit 의존성 주입 요청
    @Inject
    lateinit var retrofit: Retrofit
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Dagger 컴포넌트 생성 및 의존성 주입
        DaggerAppComponent.create().inject(this)
    }
}
```

#### Hilt란 무엇인가?

- Hilt는 Dagger 2를 기반으로 구축된 안드로이드용 의존성 주입 라이브러리
- Activity, Fragment, ViewModel과 같이 안드로이드 생명 주기에 밀접한 관련이 있는 클래스에 스코프가 지정된 사전 정의된 컴포넌트를 제공
- @HiltAndroidApp 및 @AndroidEntryPoint와 같은 어노테이션을 제공하여 DI 설정을 간소화함으로써 Dagger 2에 필요한 많은 보일러 플레이트 코드를 제공
- @Singleon 및 @ActivtyScoped와 같은 범위를 정의하여 의존성 생명주기를 관리

```kotlin
@HiltAndroidApp
class MyApplication : Application()

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    // Retrofit 의존성 주입 요청
    @Inject
    lateinit var retrofit: Retrofit
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Hilt가 자동으로 의존성 주입 처리
    }
}

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com")
            .build()
    }
}
```

#### Dagger 2와 Hilt의 주요 차이점

1. 통합 프로세스
   - Hilt는 사전 정의된 컴포넌트와 생명주기에 스코핑된 어노테이션을 제공하여 이를 단순화
   - Dagger 2는 개발자가 컴포넌트와 Injector를 수동으로 정의해야 해서 보일러 플레이트 코드 발생
2. 안드로이드 생명주기 통합
   - Hilt는 안드로이드 컴포넌트(Activity, Fragment, ViewModel 등)에 대한 스코프가 지정된 컴포넌트를 제공하여 생명주기 관리를 용이하게 함
   - Dagger 2는 더 범용적이며 생명주기 인식 컴포넌트에 대해 수동적인 설정이 필요
3. 스코핑(Scoping)
   - Hilt는 @Singleton, @ActivityScoped, @FragmentScoped와 같이 안드로이드 생명주기 클래스와 밀접하게 통합된 사전 정의된 범위를 제공
   - Dagger 2에서는 스코핑에 수동 설정 및 커스텀 어노테이션이 필요
4. 코드 단순성
   - Hilt는 많은 보일러 플레이트 코드를 추상화하여 DI 설정의 복잡성을 줄임
   - Dagger 2는 유연하게 복잡한 구조에서 더 세밀하게 사용할 수 있지만, 모든 컴포넌트와 관계를 수동으로 정의해야 함
5. 사용 사례
   - Hilt는 안드로이드 프로젝트를 위해 맞춤 설계되었으며 사용 편의성과 안드로이드 컴포넌트와의 통합에 중점을 둠
   - Dagger 2는 복잡하고 커스텀된 의존성 주입 그래프가 필요한 프로젝트에 적합

#### Dagger 2 기반의 어노테이션 (Dagger에서 제공하고 Hilt에서도 사용)

1. @Inject
   - 의존성 주입을 위해 생성자, 필드 또는 메소드에 표시
   - 의존성 주입을 실질적으로 요청하는 데 사용
2. @Provides
   - @Module 내에서 의존성 생성 메소드를 정의
   - Hilt와 Dagger 모두 이 어노테이션을 사용하여 객체를 제공
3. @Module
   - 클래스를 의존성 제공자 컨테이너로 선언
   - 모듈은 관련된 의존성 생성 로직을 그룹화
4. @Binds
   - @Module 내에서 인터페이스를 구현에 매핑하는 데 사용되어 의존성 정의 시 보일러 플레이트 코드를 줄임
5. @Qualifier
   - 커스텀 어노테이션을 사용하여 동일한 타입에 대해 여러 의존성 바인딩을 구별
6. @Scope
   - 특정 의존성의 생명주기를 제어하기 위해 커스텀 스코핑 어노테이션을 정의
7. @Singleton
   - 의존성이 해당 범위(일반적으로 앱 생명주기) 내내 단일 공유 인스턴스를 가져야 함을 지정
8. @Component
   - 의존성 그래프의 인터페이스르 정의
   - @Component는 모듈을 주입 대상에 연결하고 의존성 생명주기를 제어
9. @Subcomponent
   - 지정한 범위 내에서 의존성을 관리하기 위한 케이스를 위해 @Component 내에 더 작은 의존성 그래프를 생성
   - 종종 자체 생명주기를 가진 자식 컴포넌트를 만드는 데 사용

#### Hilt에 특화된 어노테이션

1. @HiltAndroidApp
   - Hilt를 부트스트랩하고 전체 앱에 대한 의존성 그래프를 생성하기 위해 사용
2. @AndroidEntryPoint
   - 안드로이드 컴포넌트(예를 들어, Activity, Fragment, Service 등)를 주입 대상으로 마크
   - 해당 어노테이션을 사용하는 것만으로도 커스텀 Dagger 컴포넌트를 정의할 필요가 없어짐
3. @InstallIn
   - @Module이 설치되어야 하는 컴포넌트(예를 들어, SingletonComponent, ActivityComponent)를 지정
4. @EntryPoint
   - Hilt에서 관리하는 안드로이드 컴포넌트가 아닌 외부에서 의존성에 접근하기 위한 진입점을 정의하는 데 사용
5. @HiltViewModel
   - Jetpack ViewModel을 Hilt와 통합하기 위한 특수 어노테이션
   - ViewModel이 생명주기를 인식하면서 Hilt의 읮노성 주입을 사용할 수 있도록 보장
   - 생성자에 @Inject와 함께 사용해야 함
6. Scope Annotations
   - @ActivityRetainedScoped: Activity가 재생성될 때까지 인스턴스를 유지
   - @ActivityScoped: Activity의 생명주기 동안 인스턴스를 유지
   - @FragmentScoped: Fragment의 생명주기 동안 인스턴스를 유지
   - @ViewScoped: View의 생명주기 동안 인스턴스를 유지
   - @ServiceScoped: Service의 생명주기 동안 인스턴스를 유지
   - @ViewModelScoped: ViewModel의 생명주기 동안 인스턴스를 유지
   - 사용자가 컴포넌트를 수동으로 정의하고 인스턴스화하는 순수 Dagger와 다릴, Hilt는 사전 정의된 컴포넌트를 제고앟여 특정 라이프 사이클에 의존성을 바인딩하는 프로세스를 단순화
   - Hilt에는 Hilt에 특화된 컴포넌트 뿐만 아니라, 스코프 지정 어노테이션들이 포함되어 있어 의존성 주입을 더 간소화하고 안드로이드 생명주기에 따라 의존성을 관리하기 쉽도록 함

#### 실전 질문

Q) Dagger 2와 비교하여 Hilt는 주입을 어떻게 단순화하고, 안드로이드 애플리케이션에서 Hilt를 사용하는 것의 장점은 무엇인가요?

A) Hilt는 Dagger 2의 복잡한 설정과 보일러플레이트 코드를 줄여 의존성 주입을 단순화합니다. Hilt는 @HiltAndroidApp 및 @AndroidEntryPoint와 같은 어노테이션을 제공하여 안드로이드 컴포넌트에 쉽게 통합할 수 있도록 합니다. 또한, Hilt는 사전 정의된 컴포넌트와 스코프를 제공하여 생명주기 관리를 용이하게 합니다. 이러한 기능들은 개발자가 의존성 주입에 집중할 수 있도록 하여 코드의 가독성과 유지보수성을 향상시킵니다.

Q) Dagger 2와 Hilt에서 @Provides와 @Binds의 차이점은 무엇이고, 각각 언제 사용해야 하나요?

A) @Provides는 메소드 수준에서 의존성을 생성하는 데 사용되며, 복잡한 객체 생성 로직이 필요한 경우에 적합합니다. 반면, @Binds는 인터페이스와 그 구현체 간의 매핑을 정의하는 데 사용되며, 단순히 인터페이스를 구현체에 바인딩할 때 더 효율적입니다. 따라서, 객체 생성 로직이 필요할 때는 @Provides를 사용하고, 단순한 인터페이스 바인딩이 필요할 때는 @Binds를 사용하는 것이 좋습니다.

Q) Hilt에서 @Singleton, @ActivityScoped, @ViewModelScoped를 사용하면 내부적으로 스코핑이 어떻게 작동하는지 메커니즘을 설명하고, 해당 스코프가 사용되면 애플리케이션 내 의존성을 어떻게 관리하는지 설명해 주세요.

A) Hilt에서 스코프 어노테이션은 의존성의 생명주기를 제어하는 데 사용됩니다. @Singleton은 애플리케이션 전체에서 단일 인스턴스를 유지하며, 앱이 실행되는 동안 동일한 인스턴스를 제공합니다. @ActivityScoped는 특정 Activity의 생명주기 동안 인스턴스를 유지하며, Activity가 재생성될 때마다 새로운 인스턴스를 생성합니다. @ViewModelScoped는 ViewModel의 생명주기 동안 인스턴스를 유지하여, ViewModel이 소멸될 때까지 동일한 인스턴스를 제공합니다. 이러한 스코핑 메커니즘을 통해 Hilt는 의존성의 생명주기를 효과적으로 관리하고, 메모리 누수를 방지하며, 필요한 시점에 적절한 인스턴스를 제공할 수 있습니다.

#### Pro Tips for Mastery: 수동으로 의존성 주입을 구현해 본 적이 있나요?

- 수동 의존성 주입(런타입 기반이라고 가정)은 객체의 전체 생명주기(스코핑, 그룹화 및 메노리 누수 방지를 위한 적절한 리소스 정리 포함)를 개발자가 수동으로 관리해야 하므로 상당한 비용이 요구
- 종종 광범위한 보일러 플레이트 코드를 작성해야 하고, 서비스 로케이터 패턴(service locator pattern)으로 전락하거나, 전역적인 싱글톤 패턴에 의존하게 될 위험이 있음
- 반면, Dagger 2 및 Hilt와 같은 라이브러리는 컴파일 타임에 주입 관련 코드를 생성하기 때문에 유지 관리를 단순화하고, 의존성 주입 순환참조와 같은 현상이 발생하는 것을 사전에 밪이
- 한편으로, Dagger 2 및 Hilt와 같은 DI 라이브러리(컴파일 타임 기반)는 컴파일 중 어노테이션 프로세싱 및 코드 생성으로 빌드 시간을 증가시킴
- 런타임 초기화에 의존하는 수동 DI는 빌드 시간을 ㅈ루일 수 있지만, 컴파일 타임에 최적화된 프레임워크 및 라이브러리에 비해 런타임 성능이 떨어질 수 있음

#### Pro Tips for Mastery: Dagger 2 및 Hilt 이외에 알고 있는 DI 라이브러리가 있나요?

##### Koin: 가볍고 사용하기 쉬운 DI 라이브러리

- 단순성을 염두에 두고 설계된 경량 의존성 주입 라이브러리
- 어노테이션, 컴파일 타임의 코드 생성 또는 무거운 보일러 플레이트 코드의 필요성을 없애고, Kotlin DSL을 사용하여 의존성 모듈을 정의하는 데 중점을 둠
- 주요 특징
  - 어노테이션 처리 없음
    - 의존성은 Kotlin 코드로 정의되어 어노테이션 처리를 피하고 빌드 시간을 단축
  - Kotlin 우선 접근 방식
    - Kotlin DSL을 사용하여 DI 구성을 매우 읽기 쉽고 직관적으로 만듦
  - 사용 편의성
    - 설정이 빠르고 소규모 프로젝트 또는 빠른 DI 환경 셋업을 추구하는 개발자에게 이상적
  - 동적 해결
    - 런타임 시 의존성이 결정되는 시나리오에서 유용한 동적 의존성 솔루션을 지원

```kotlin
// 모듈 정의
val appModule = module {
    single { Repository() } // 싱글톤 정의
    factory { ViewModel(get()) }    // 팩토리(매번 새 인스턴스 정의), get()으로 의존성 주입
}

// Koin 시작 (Application 클래스 등에서)
startKoin {
    androidContext(this@MyApplication)
    modules(appModule)
}

// 의존성 주입 (Activity, Fragment 등에서)
class MyActivity : AppCompatActivity() {
    // by Inject() Delegate 사용
    val viewModel: ViewModel by inject()
    // 또는 get() 직접 사용
    // val repository: Repository = get()
}
```

- Koin은 컴파일 타임 의존성 관련 코드를 전혀 생성하지 않고 모두 런타임에 처리하기 때문에, 소규모 프로젝트나 빌드 성능이 우선시되는 시나리오에 적합
- KMP(Koltin MulitPlatform)에서도 적합한 선택

##### Dagger 2 vs. Koin?

- Koin은 의존성 주입기 솔루션이 아니라 수동적으로 의존성 주입을 수행하기 위해 reified 트릭을 동반한 서비스 로케이터 패턴이므로, 사용하면 사용할 수록 보일러 플레이트 코드가 불균형하게 확장
- Dagger에는 일정량의 고정 오버헤드가 있지만, 바인딩이 주입된 타입 전체에 자동으로 전파되기 때문에 거의 그래프 형태를 변경할 필요가 없음
- 수동 의존성 주입을 사용하면 주입된 타입 전체에 수동으로 바인딩을 전파해야 함
- 대규모의 앱을 개발하려면, DI 라이브러리를 사용하는 것이 훨씬 나음

##### Koin은 서비스 로케이터 패턴인가요?

- Koin은 DI와 서비스 로케이터 패턴을 모두 지원하여 개발자에게 유연성을 제공
- 의존성이 생성자 매개변수로 전달되는 DI, 특히 생성자 주입 사용을 강력히 권장
- Koin의 디자인 철학은 필요할 때는 복잡한 구성을 허용하면서, 일반적인 상황에서는 단순성과 DI 환경 셋업의 용이성에 중점을 둠
- 서비스 로케이터 패턴(Service Locater Pattern)
  - 필요한 객체를 전역적으로 등록해 두고, 필요할 때마다 그 레지스트리에 찾아 사용하는 방식

##### Anvil: Dagger 2에 기반한 컴파일 프러그인

- Anvil은 팩토리 및 모듈 코드 생성을 간소화하여 초기 Dagger의 셋업 비용을 주임
- 손쉬운 Dagger 셋업
  - 어노테이션이 붙은 클래스에 대해 Dagger 컴포넌트 및 팩토리를 자동으로 생성
- 보일러 플레이트 코드 감소
  - 수동 구성을 최소화하여 대규모 프로젝트에서 Dagger를 더 쉽게 사용할 수 있도록 함
- Dagger와의 통합
  - 기존 DI 설정을 크게 변경할 필요 없이 Dagger와 원활하게 작동
- 빌드 성능
  - 특정 컴포넌트에 대해 어노테이션 프로세싱 오버헤드를 줄여 빌드 시간을 개선하는 데 크게 도움이 됨

```kotlin
import com.squareup.anvil.annotations.ContributesBinding
import com.squareup.anvil.annotations.ContributesTo
import javax.inject.Inject

interface Repository
interface AppScope

// Repository 구현 클래스에 ContributesBinding 적용
@ContributesBinding(AppScope::class)
class MyRepository @Inject constructor() : Repository

// 모듈 인터페이스에 ContributesTo 적용
@ContributesTo(AppScope::class)
interface AppModule {
    // Provides 메소드 정의 (Anvil이 구현 생성)
    fun provideRepository(): SomeDependency
}
```

- Anvil은 내부적으로 Dagger를 사용하며, 보일러 플레이트 코드를 줄이고 개발자 생산성을 향샹시키려는 프로젝트에 이상적

##### 올바른 라이브러리 선택하기

- Koin
  - 소규모 프로젝트나 DI를 빠르게 셋업하여 프로젝트에 적용하고 싶은 경우, 또는 어노테이션 처리 없이 간단하게 DI를 사요하고자 하는 경우 좋은 선택
- Anvil
  - 이미 대규모 프로젝트에서 Dagger를 사용하고 있으며, 기존 Dagger 컴포넌트와의 호환성을 유지하면서 워크플로를 단순화하려는 상황에 적합

### 57. Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?

- Jetpack paging 라이브러리는 대규모 데이터 셋을 청크 또는 페이지 단위로 로드하고 표시하는 프로세스를 돕도록 설계된 안드로이드 아키텍처 컴포넌트
- 데이터 캐싱, 재시도 메커니즘, 효율적인 메모리 사용과 같은 주요 측면을 기본적으로 처리

#### Paging 라이브러리의 구성 요소

1. PagingData
   - 점진적으로 로드되는 데이터 스트림을 나타냄
   - RecyclerView와 같은 UI 컴포넌트에 의해 관찰되고 사용될 수 있음
2. PagingSource
   - 데이터 소스에서 데이터가 로드되는 방식을 정의
   - 위치 또는 ID 같은 키값을 기반으로 데이터 페이지를 로드하는 메소드를 제공
3. Pager
   - PagingSource와 PagingData 간의 중개자 역할을 함
   - PagingData 스트림의 생명주기를 관리
4. RemoteMediator
   - 로컬 캐싱과 원격 API 데이터를 결합할 때 경계 조건을 구현하는 데 사용

#### Paging 라이브러리 작동 방식

1. PagingSource를 정의하여 데이터 가져오는 방법을 지정
2. Pager를 사용하여 PagingData의 Flow를 생성
3. ViewModel에서 PagingData를 관찰하고 RecyclerView에서 렌더링하기 위해 PagingDataAdapter에 전달

#### Jetpack Paging 구현 예시

- PagingSource 구현

```kotlin
class ExamplePagingSource(
    private val apiService: ApiService
) : PagingSource<Int, ExampleData>() { // Int: 페이지 키 타입, ExampleData: 로드할 데이터 타입
    
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, ExampleData> {
        val page = params.key ?: 1 // 기본 페이지는 1
        return try {
            val response = apiService.getData(page, params.loadSize)
            val data = response.items
            
            LoadResult.Page(
                data = data,
                prevKey = if (page == 1) null else page - 1, // 이전 페이지 키
                nextKey = if (data.isEmpty()) null else page + 1 // 다음 페이지 키
            )
        } catch (e: IOException) {
            LoadResult.Error(e) // 네트워크 오류 처리
        } catch (e: HttpException) {
            LoadResult.Error(e) // HTTP 오류 처리
        }
    }
    
    // 페이지 키를 정의하는 로직 (선택 사항, Paging 3에서는 load()에서 키 처리)
    override fun getRefreshKey(state: PagingState<Int, ExampleData>): Int? {
        return state.anchorPosition?.let { anchorPosition ->
            state.closestPageToPosition(anchorPosition)?.prevKey?.plus(1)
                ?: state.closestPageToPosition(anchorPosition)?.nextKey?.minus(1)
        }
    }
}
```

- PagingSource와 PagingData 간의 중개를 위해 리포지토리에서 Pager를 생성

```kotlin
class ExampleRepository(private val apiService: ApiService) {
    fun getExampleData(): Flow<PagingData<ExampleData>> {
        return Pager(
            // Paging 구성 설정 (페이지 크기 등)
            config = PagingCOnfig(
                pageSize = 20, // 각 페이지에 로드할 항목 수
                enablePlaceholders = false // 플레이스홀더 사용 여부
                // prefetchDistance, initialLoadSize 등 추가 설정 가능
            ),
            // PagingSource 인스턴스를 제공하는 팩토리
            pagingSourceFactory = { ExamplePagingSource(apiService) }
        ).flow
    }
}
```

- ViewModel에서 PagingData를 관찰하고 UI에 전달

```kotlin
class ExampleViewModel(private val repository: ExampleRepository) : ViewModel() {
    val exampleData: Flow<PagingData<ExampleData>> = repository.getExampleData()
        .cachedIn(viewModelScope) // ViewModel 범위 내에서 캐싱
}
```

- PagingDataAdapter를 상속받는 커스텀 RecyclerView.Adapter를 생성하여 RecyclerView에 데이터를 전달하고 렌더링

```kotlin
class ExampleAdapter : PagingDataAdapter<ExampleData, ExampleViewHolder>(DIFF_CALLBACK) {
    
    override fun onBindViewHolder(holder: ExampleViewHolder, position: Int) {
        val item = getItem(position)
        item?.let { holder.bind(it) }
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ExampleViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_example, parent, false)
        return ExampleViewHolder(view)
    }
    
    class ExampleViewHolder(itemView: View): RecyclerView.ViewHolder(itemView) {
        fun bind(data: ExampleData) {
            // 데이터 바인딩 로직
        }
    }
    
    companion object {
        private val DIFF_CALLBACK = object : DiffUtil.ItemCallback<ExampleData>() {
            override fun areItemsTheSame(oldItem: ExampleData, newItem: ExampleData): Boolean {
                return oldItem.id == newItem.id // 고유 ID 비교
            }
            
            override fun areContentsTheSame(oldItem: ExampleData, newItem: ExampleData): Boolean {
                return oldItem == newItem // 전체 내용 비교
            }
        }
    }
}
```

#### 실전 질문

Q) Paging 라이브러리는 데이터 로딩 중 오류를 어떻게 처리하며, 페이지네이션된 데이터 흐름에서 오류 처리 및 재시도 메커니즘을 구현하기 위해 사용해 본 전략은 무엇인가요?

A) Paging 라이브러리는 PagingSource의 load() 메소드 내에서 발생하는 IOException 및 HttpException과 같은 오류를 LoadResult.Error로 반환하여 오류를 처리합니다. 이를 통해 PagingDataAdapter는 오류 상태를 감지하고 UI에 적절한 피드백을 제공할 수 있습니다. 재시도 메커니즘을 구현하기 위해, PagingDataAdapter의 LoadStateListener를 사용하여 로딩 상태를 모니터링하고, 오류가 발생했을 때 사용자에게 재시도 버튼을 제공하거나 자동으로 재시도를 시도할 수 있습니다.

### 58. Baseline Profile은 앱의 성능에 어떤 이점을 가져다주나요?

- Baseline Profile은 앱 시작 시간과 런타임 실행을 최적화하기 위한 안드로이드 앱의 성능 향상을 위한 플러그인
- 미리 컴파일된 코드 정보를 제공함으로써 코드 해석 및 JIT(Just-In-Time) 컴파일 오버헤드를 줄여 앱의 초기 실행 속도를 개선
- Baseline Profile은 제공된 프로파일에 정확한 코드 경로를 정의하기 위해 AOT(Ahead-Of-Time) 컴파일을 활용

#### Baseline Profile 작동 방식

1. 중요한 코드 경로 정의
   - 개발자는 주요 실행 경로를 프로파일링하거나 애플리케이션 시작 순간부터 가장 일반적인 사용자의 앱 사용 패턴을 기반으로 성능에 중요한 메소드 및 클래스를 미리 정의
2. 프로파일 생성
   - Jetpack Macrobenchmark 라이브러리와 같은 도구를 사용하여 생성
   - 이를 통해 앱 동작을 기록하고 테스트하여 중요한 코드 경로를 식별
3. 프로파일 전파
   - 생성된 Baseline Profile은 APK 또는 AAB와 함께 번들로 제공되어 최종 사용자에게 전파되어 배포
4. 설치 중 최적화
   - 앱이 사용자 기기에 설치될 때 ART는 프로파일을 사용하여 미리 정의해 두었던 메소드 및 클래스를 네이티브 코드로 미리 컴파일

- AGP 8.0 이상부터는 Baseline Profile Gradle 플러그인을 활용하여 Baseline Profile 생성을 간소화하고 패키지 필터링 옵션을 제공하며 플레이버 컨트롤을 포함한 더 편리한 기능을 제공

#### 실전 질문

Q) Baseline Profile를 활용하면 Android Runtime (ART)이 앱 성능을 어떻게 개선시키고, 해당 접근 방식이 기존 Just-In-Time (JIT) 컴파일과 비교하여 가지는 성능적인 이점은 무엇인가요?

A) Baseline Profile은 ART가 앱 설치 시 중요한 코드 경로를 미리 컴파일할 수 있도록 하여, 앱 시작 시점에서 JIT 컴파일에 의한 오버헤드를 줄입니다. JIT 컴파일은 런타임에 코드를 해석하고 컴파일하는 과정에서 지연이 발생할 수 있지만, Baseline Profile을 사용하면 이러한 지연 없이 미리 컴파일된 네이티브 코드를 실행할 수 있습니다. 결과적으로, 앱의 초기 실행 속도가 향상되고, 사용자 경험이 개선됩니다.