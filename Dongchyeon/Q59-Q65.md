### 59. 장기적으로 실행되는 백그라운드 작업을 어떻게 실행하나요?

#### 조건부 작업에 적합한 WorkManager

- 앱이 닫히거나 기기 재부팅 후에도 실행되어야 하는 작업의 경우 WorkManager가 공식적으로 권장되는 솔루션
- 백그라운드 작업을 관리하고 네트워크 가용성 또는 충전 상태와 같은 제약 조건 하에서 작업이 실행되도록 보장
- 로그 업로드, 데이터 동기화, 비디오와 같이 영상 업로드 등이 일반적인 사용 사례

```kotlin
class UploadWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) {
    override fun doWork(): Result {
        // 여기서 백그라운드 작업 수행
        uploadData()
        return Result.success()
    }
    
    // 작업 예약
    val constraints = Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)  // 네트워크 연결 필요 제약 조건
        .build()
    
    val workRequest = OneTimeRequestBuilder<UploadWorker>()
        .setConstraints(constraints)
        .build()
    
    WorkManager.getInstance(conxtext).enqueue(workRequest)
}
```

#### 오랜 작업에 적합한 Service

- 음악 재생이나 위치 추적과 같이 지속적이고 오랜 실행이 필요한 작업에는 Service가 이상적
- 서비스는 UI와 독립적으로 실행되며 백그라운드에 있을 때도 계속 실행 가능
- 작업이 알림과 함께 사용자가 인지할 수 있는 상황에서 실행되어야 하는 경우 Foreground Service를 사용

```kotlin
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: int): Int {
        // 장기 실행 작업 수행
        startForeground(NOTIFICATION_ID, createNotification())
        // START_STICKY, START_REDELIVER_INTENT 등 반환 값 고려
        return START_NOT_STICKY
    }
    
    // 알림 생성 로직 (Notification Channel 포함)
    private fun createNotification(): Notification {
        // ...
        return NotificationCompat.Builder(this, CHANNEL_ID).build()
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
}
```

#### Kotlin Coroutines 및 Dispatchers 사용하기

- 앱 생명주기에 연결된 작업의 경우 Kotlun Coroutines를 사용하면 Kotlin 언어 수준에서 깔끔하고 구조화된 접근 방식 제공
- 무거운 작업을 오프로드하려면 Dispatchers.IO를 사용하고 CPU 집약적인 계산에는 Dispatchers.Default를 사용
- 앱이 닫힌 우에도 유지될 필요가 없는 작업에 이상적

```kotlin
class MyViewModel : ViewModel() {
    fun fetchData() {
        viewModelScope.launch(Dispatchers.IO) { // IO dispatcher에서 네트워크 작업 실행
            val data = fetchFromNetwork()
            // 결과를 메인 스레드로 전환하여 UI 업데이트
            withContext(Dispatchers.Main) {
                updateUI(data)
            }
        }
    }
}
```

##### Additional Tips

- CPU 집약적인 작업
  - 연산 능력을 요구하며 사용 가능한 CPU 코어 수에 의해 제약을 받음
  - 즉, 디바이스에서 사용가능한 코어의 수만큼만 스레드를 생성하여 작업
  - 사용 가능한 코어 수보다 많은 스레드를 추가하면 성능 향상보다 스레드 경합이 발생하는 경우가 많음
- I/O 집약적인 작업
  - CPU 코어 수보다 많은 스레드를 사용함으로써 여러 I/O 작업이 CPU 경합을 일으키지 않고 동시에 실행될 수 있도록 함
  - 예를 들어, 8개의 코어를 가진 시스템은 수십 개 또는 수백 개의 I/O 스레드를 효율적으로 관리할 수 있음
  - 코틀린 코루틴은 더 적은 수의 스레드로 수많은 I/O 작업을 처리할 수 있도록 하여 리소스 활용을 더욱 최적화

#### 시스템 수준 작업에 적합한 JobScheduler

- 작업이 기기 전체 작업과 관련되고 특정 조건(예를 들어, 충전 중에만 실행)이 필요한 경우 JobScheduler 사용
- 즉시 실행이 필요하지 않은 작업에 적합
- WorkManager는 JobScheduler를 내부적으로 사용하여 작업을 예약하므로 WorkManager를 선호하는 것이 일반적

```kotlin
val jobScheduler = context.getSystemService(JobScheduler::class.java)
val jobInfo = JobInfo.Builder(JOB_ID, ComponentName(context, MyJobServices::class.java))
    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) // Wi-Fi 연결 필요
    .setRequiresCharging(true) // 충전 중일 때만 실행
    .setPeriodic(TimeUnit.Minutes.toMillis(15)) // 15분마다 실행
    .build()
```

#### 실전 질문

Q) 안드로이드 앱에서 백엔드 서버로부터 대용량 파일(수백 MB)을 다운로드하는 기능을 구현해야 합니다. 다운로드는 앱이 닫혀도 계속되어야 하며, 성능 및 네트워크 조건 측면에서 효율적이어야 합니다. WorkManager, Foreground Service, JobScheduler 중 어떤 것을 선택하여 구현하셨나요?

A) 이 시나리오에서는 WorkManager를 사용하는 것이 가장 적합합니다. WorkManager는 앱이 닫히거나 기기가 재부팅된 후에도 작업이 계속 실행되도록 보장하며, 네트워크 상태와 같은 제약 조건을 설정할 수 있습니다. 예를 들어, Wi-Fi에 연결되어 있을 때만 다운로드가 시작되도록 설정할 수 있습니다. 또한, WorkManager는 백그라운드 작업을 효율적으로 관리하므로 성능 측면에서도 유리합니다. Foreground Service는 사용자가 다운로드 진행 상황을 인지해야 할 때 적합하지만, 이 경우에는 필요하지 않습니다. JobScheduler는 시스템 수준 작업에 더 적합하지만, WorkManager가 더 높은 수준의 추상화를 제공하므로 선호됩니다.

### 60. Json 형식을 객체로 어떻게 직렬화(serialize)하나요?

- 안드로이드 앱은 원격 서버와 자주 상호 작용하기 때문에 JSON을 객체로 직렬화하는 것은 안드로이드 개발에서 일반적인 작업
- 앱은 Kotlin 객체를 JSON으로 직렬화하여 데이터를 백엔드로 보내 필요한 정보를 요청하고, 서버의 JSON 응답을 받으면 다시 객체로 역직렬화해야 함

#### 직렬화(Serialization)와 역직렬화(Deserialization)란?

- 직렬화(Serialization)
  - 객체나 데이터 구조를 나중에 쉽게 저장, 전송 또는 재구성할 수 있는 형식으로 변환하는 프로세스
  - 안드로이드와 백엔드 통신에서는 종종 JSON 문자열이나 유사한 구조화된 형식으로 변환하는 것을 의미
- 역직렬화(Deserialization)
  - 직렬화된 데이터(JSON 문자열 등)를 가져와 애플리케이션에서 작업할 수 있는 메모리 내 객체로 재구성

#### 수동 직렬화 및 역직렬화

- 외부의 솔루션을 사용하지 않고 직접 수동적으로 객체를 JSON 문자열로 변환하고, 그 반대로 변환하여 직렬화 및 역직렬화를 수행할 수 있음

```kotlin
data class User(val name: String, val age: Int)

fun serializeUser(user: User): String {
    // 각 속성을 JSON 형식에 맞게 문자열로 변환
    return """{
        "name": "${user.name}",
        "age": ${user.age}
    }""".trimIndent()   // 들여쓰기 제거
}

// 사용 예제
val user = User("John", 30)
val jsonString = serializeUser(user)
// 출력: {"name": "John", "age": 30}
```

```kotlin
fun deserializeUser(json: String): User {
    // 정규 표현식을 사용하여 값 추출 (간단한 에시)
    val nameRegex = """name"\s*:\s*"([^"]+)"""".toRegex()
    val ageRegex = """age"\s*:\s*(\d+)""".toRegex()
    
    val name = nameRegex.find(json)?.groupValues?.get(1) ?: ""
    val age = ageRegex.find(json)?.groupValues?.get(1)?.toIntOrNull() ?: 0
    
    return User(name, age)
}

// 사용 예제
val jsonString = """{"name": "John", "age": 30}"""
val user = deserializeUser(jsonString)
// 출력: User(name=John, age=30)
```

#### kotlinx.serialization

- Kotlin과 직접적으로 통합되어 Kotlin의 언어적 기능을 활용하도록 설계
- 어노테이션을 사용하여 직렬화 동작을 정의하고 JSON 뿐만 아니라 ProtoBuf와 같은 다른 형식과도 원활하게 작동

```kotlin
import kotlinx.serialization.*
import kotlinx.serialization.json.*

@Serializable
data class User(val name: String, val age: Int)

val json = """{"name": "John", "age": 30}"""
// JSON 문자열을 User 객체로 역직렬화
val user: User = Json.decodeFromString<User>(json)
// User 객체를 JSON 문자열로 직렬화
val serializedJson: String = Json.encodeToString(user)
```

- Kotlin Compiler 플러그인을 사용하여
- Kotlin 객체를 JSON 문자열로 변환(직렬화)하고
- JSON 문자열을 Kotlin 객체로 파싱(역직렬화)하는 타입 안정성을 보장
- 내부적으로 리플렉션을 사용하지 않는 메커니즘을 제공하므로 최신 안드로이드 및 Kotlin 개발에서 선호되는 방법

#### Moshi

- Moshi는 Square에서 개발한 라이브러리로 타입 안전성과 Kotlin을 지원
- Gson과 달리 Moshi는 Kotlin의 null 가능성 및 기본 매개변수를 기본적으로 지원
- 따라서 Kotlin을 사용하는 프로젝트에 아주 적합

```kotlin
data class User(val name: String, val age: Int)

// Moshi 인스턴스 생성 (Kotlin 지원 추가 필요)
val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory()) // Kotlin 지원 추가
    .build()
// User 클래스에 대한 어댑터 가져오기
val adapter: JsonAdapter<User> = moshi.adapter(User::class.java)
val json = """{"name": "John", "age": 30}"""

// JSON을 객체로 역직렬화
val user: User? = adapter.fromJson(json)
// 객체를 JSON으로 직렬화
val serializedJson: String? = user?.let { adapter.toJson(it) }
```

- Moshi에서는 JSON 직렬화 및 역직렬화를 처리하는 두 가지 주요 접근 방식 존재
  - 리플레션에 기반한 동작 방식
    - Java 리플레션을 사용하여 런타임에 동적으로 JSON 어댑터를 생성
    - 추가 설정 없이 사용법이 간단
    - 런타임 오버헤드 발생
  - 컴파일 타임에 코드를 생성(codegen)하는 방식
    - 어노테이션 프로세스(Kotlin SymbolProcessor) 기법을 통해 컴파일 타임에 JSON 어댑터를 생성
    - 더 빠른 런타임 성능과 컴파일 타임 오류 검사를 제공

#### Gson

- Google에서 개발한 Gson은 안드로이드 개발에서 널리 사용되는 JSON 직렬화/역직렬화 라이브러리
- Java 객체를 JSON으로 직렬화하고 JSON을 다시 Java 객체로 역직렬화
- 간단한 API와 통합 용이성 덕분에 인기 있는 라이브러리

```kotlin
data class User(val name: String, val age: Int)

val gson = Gson()
val json = """{"name": "John", "age": 30}"""
val user = gson.fromJson(json, User::class.java) // JSON을 객체로 역직렬화
val serializedJson = gson.toJson(user) // 객체를 JSON으로 직렬화
```

- Gson보다 kotlinx.serialization이나 Moshi를 선택해야 하는 이유
  - 더 나은 Kotlin 지원
    - Gson은 Java용으로 설계되어 Kotlin 기능을 kotlinx.serialization이나 Moshi만큼 자연스럽게 처리하지 못함
  - 성능 및 효율성
    - kotlinx.seralization과 Moshi는 컴파일 타임 코드 생성을 통해 더 나은 성능을 제공
  - 멀티플랫폼 호환성
    - kotlinx.serialization은 Kotlin Multiplatform(KMP)을 완벽하게 지원
    - 반면, Moshi/Gson은 JVM 위에서 동작하도록 설계되어 있어 크로스 플랫폼 앱에는 비적합
  - 컴파일 타일 안전성
    - 컴파일 타임에 필요한 코드를 생성하는 kotlinx.serialization과 Moshi는 런타임 오류를 줄이고 개발자 경험을 향상
    - Gson은 런타임에 리플렉션을 사용하여 오류가 발생할 가능성이 더 높음

#### 실전 질문

Q) API의 JSON 응답이 주어졌을 때, 이를 Kotlin 데이터 클래스로 어떻게 역직렬화하시겠습니까? Kotlin을 사용하는 프로젝트에서 어떤 라이브러리를 선택할 것이고, 그 이유는 무엇인가요?

A) Kotlin의 기본 기능과 최적화를 최대한 활용하기 위해 kotlinx.serialization을 선택하겠습니다. 이 라이브러리는 Kotlin과 원활하게 통합되며, 컴파일 타임에 코드를 생성하여 런타임 성능을 향상시키고 오류를 줄입니다. 또한, kotlinx.serialization은 Kotlin Multiplatform을 지원하여 크로스 플랫폼 개발에도 적합합니다. JSON 응답을 역직렬화할 때는 @Serializable 어노테이션을 사용하여 데이터 클래스를 정의하겠습니다.

Q) Kotlin 데이터 클래스에 정의되지 않은 누락되거나 추가적인 필드가 있는 JSON 문자열을 역직렬화해야 하는 경우 어떻게 처리하실 건가요?

A) kotlinx.serialization에서는 기본적으로 JSON에 정의되지 않은 필드가 있어도 역직렬화가 가능합니다.
ignoreUnknownKeys = true를 통해 정의되지 않은 필드를 무시하도록 설정하고, 누락된 필드는 데이터 클래스에서 기본값을 제공하여 처리할 수 있습니다. 예를 들어, age 필드가 누락된 경우 기본값을 0으로 설정할 수 있습니다.

### 61. 원격 데이터를 가져오기 위해 네트워크 요청을 어떻게 처리하며, 효율성과 신뢰성을 위해 어떤 라이브러리나 기술을 사용하나요?

- Retrofit은 선언적 인터페이스를 제공하여 API 상호 작용을 단순화
- OkHttp는 기본적인 HTTP 클라이언트 역할을 하여 연결 풀링, 캐싱 및 효율적인 통신을 제공

#### Retrofit을 사용한 네트워크 요청

- Retrofit은 HTTP 요청을 깔끔하고 타입 안전한 API 인터페이스로 추상화
- JSON 응답을 Kotlin 또는 Java 객체로 변환하기 위해 Gson 또는 Moshi와 같은 직렬화 라이브러리와 원활하게 작동

1. API 인터페이스 정의
   - 어노테이션을 사용하여 API 엔드포인트와 HTTP 메소드를 선언
   ```kotlin
   interface ApiService {
       @GET("data")
       // 코루틴 지원을 위한 suspend 함수 또는 Call<DataModel> 반환
       suspend fun fetchData(): Response<DataModel>
   } 
   ```
   
2. Retrofit 인스턴스 생성
   - BASE URL과 JSON 직렬화를 위해 ConverterFactory를 아래와 같이 하여 Retrofit 인스턴스를 구성
   ```kotlin
   // Kotlinx Serialization Converter Factory 예시
   val retrofit = Retrofit.Builder()
       .baseUrl("https://api.example.com/")
       .addConverterFactory(Json { ignoreUnknownKeys = true }
       .asConverterFactory("application/json".toMediaType()))
       .build()
   
   // API 서비스 인스턴스 생성
   val apiService = retrofit.create(ApiService::class.java)
   ```
   
3. 네트워크 호출하기
   - 코루틴을 사용하여 API를 비동기적으로 호출
   ```kotlin
   viewModelScope.launch {  // ViewModel 스코프 또는 다른 코루틴 스코프 사용
       try {
          val response = apiService.fetchData()
          if (response.isSuccessful) { 
              val data = response.body()
              if (data != null) {
                  Log.d(TAG, "Data fetched: $data")
              } else {
                  Log.e(TAG, "Response body is null")
              }
          } else {
              // 오류 처리
              Log.e(TAG, "Error: ${response.code()} - ${response.message()}")
          }
       } catch (e: Exception) { // 네트워크 오류 또는 기타 예외 처리
          Log.e(TAG, "Network request failed", e)
       }
   } 
   ```

#### OkHttp를 사용한 커스텀 HTTP 요청

- OkHttp는 헤더, 캐싱 등을 세밀하게 제어할 수 있도록 HTTP 요청을 관리하기 위해 더 직접적인 접근 방식을 보여줌

```kotlin
val client = OkHttpClient()

val request = Request.Builder()
    .url("https://api.example.com/data")
    .builder()

// 비동기 요청 실행
client.newCall(request).enqueue(object : Callback {
    override fun onFailure(call: Call, e: IOException) {
        // 네트워크 오류 처리
        e.printStackTrace()
    }

    override fun onResponse(call: Call, response: Response) {
        response.use {  // response.body().close() 자동 호출
            if (response.isSuccessful) {
                val responseBody = response.body?.string()
                Log.d(TAG, "Data fetched: $responseBody")
            } else {
                Log.e(TAG, "Error: ${response.code} - ${response.message}")
            }
        }
    }
})
```

#### OkHttp와 Retrofit 통합하기

- Retrofit은 내부적으로 OkHttp를 HTTP 클라이언트로 사용
- 인터셉터를 추가하여 로깅, 인증 또는 캐싱과 같은 OkHttp의 동작을 커스텀

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(HttpLoggingInterceptor().apply {
        level = HttpLoggingInterceptor.Level.BODY // 요청 및 응답 본문 로깅
    })
    .addInterceptor { chain ->
        val originalRequest = chain.request()
        val newRequest = originalRequest.newBuilder()
            .header("Authorization", "Bearer your_token")
            .build()
        chain.proceed(newRequest)
    }
    .connectTimeout(30, TimeUnit.SECONDS) // 연결 타임아웃 설정
    .readTimeout(30, TimeUnit.SECONDS)    // 읽기 타임아웃
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .client(okHttpClient) // 커스텀 OkHttp 클라이언트 설정
    .addConverterFactory(GsonConverterFactory.create()) // Gson 컨버터 추가
    .build()
```

#### 실전 질문

Q) 앱에서 동시에 여러 API 요청을 수행하고 UI를 업데이트하기 전에 결과를 결합해야 한다고 가정해 봅시다. Retrofit과 코루틴을 사용하여 이를 효율적으로 구현하려면 어떻게 해야 하나요?

A) Retrofit과 코루틴을 사용하여 여러 API 요청을 병렬로 수행하고 결과를 결합하려면 `async`와 `awaitAll`을 활용할 수 있습니다. `viewModelScope` 또는 다른 코루틴 스코프 내에서 `async`를 사용하여 각 API 호출을 비동기적으로 시작하고, `awaitAll`을 사용하여 모든 호출이 완료될 때까지 기다린 후 결과를 결합할 수 있습니다.

```kotlin
interface UserApi {
    @GET("/user/profile")
    suspend fun getProfile(): ProfileResponse

    @GET("/user/statistics")
    suspend fun getStatistics(): StatisticsResponse
}

viewModelScope.launch {
    val profileDeferred = async(Dispatchers.IO) { userApi.getProfile() }
    val statsDeferred = async(Dispatchers.IO) { userApi.getStatistics() }

    // await() 시점에서 두 결과를 한꺼번에 받아 결합
    val profile = profileDeferred.await()
    val stats = statsDeferred.await()

    val combined = combine(profile, stats)
    updateUI(combined)
}
```

Q) API 응답 실패 시 어떻게 처리하고, 재시도 메커니즘은 어떻게 구현하나요?

A) safeApiCall 함수를 만들어 네트워크 요청을 안전하게 처리하고, 네트워크 실패나 서버 오류(5xx 상태)에 대해 retryApiCall 함수를 통해 재시도를 시도해볼 수 있습니다.

```kotlin
suspend fun <T> safeApiCall(
    apiCall: suspend () -> Response<T>
): Result<T> {
    return try {
        val response = apiCall()
        if (response.isSuccessful) {
            Result.success(response.body()!!)
        } else {
            Result.failure(HttpException(response))
        }
    } catch (e: IOException) {
        // 네트워크 예외 (timeout, unknown host 등)
        Result.failure(e)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

```kotlin
suspend fun <T> retryApiCall(
    times: Int = 3,
    delayMillis: Long = 1000,
    apiCall: suspend () -> Response<T>
): Response<T> {
    repeat(times - 1) {
        try {
            val response = apiCall()
            if (response.isSuccessful) return response
        } catch (e: IOException) {
            // 네트워크 오류일 때만 재시도
            delay(delayMillis)
        }
    }
    return apiCall() // 마지막 시도
}
```

#### Pro Tips for Mastery: OkHttp Authenticator 및 Interceptor를 사용하여 OAuth 토큰 갱신하기

##### OkHttp Authenticator

- OkHttp의 Authenticator 인터페이스는 토큰 만료와 같은 인증 문제를 처리하도록 따로 설계되었음
- 서버가 401 Unauthorized 응답을 반환할 때마다 호출되어 새로운 인증 토큰을 얻고 요청을 재시도

```kotlin
class TokenAuthenticator(private val tokenProvider: TokenProvider) : Authenticator {
    override fun authenticate(route: Route?, response: Response): Request? {
        // 이전 요청이 이미 헤더를 가지고 있었는지 확인 (무한 루프 방지)
        val previousToken = response.request.header("Authorization")
        
        // 토큰 동기화 및 새로고침 (한 번만 시도하도록 제어)
        synchronized(this) {
            // 현재 토큰과 이전 요청의 토큰 비교
            val currentToken = tokenProvider.getToken() // 현재 저장된 토큰 가져오기
            // 토큰이 변경되지 않았거나 새로고침 실패 시 null 반환 (더 이상 재시도 안 함)
            if (previousToken != null && previousToken == "Bearer $currentToken") {
                val newToken = tokenProvider.refreshToken() // 동기적으로 토큰 새로고침
                if (newToken == null) {
                    // 새로고침 실패 시 처리 (예: 로그아웃)
                    tokenProvider.clearToken() // 토큰 제거
                    return null // 인증 실패
                }
            }
            
            // 새로고침된 토큰 또는 현재 토큰으로 새 요청 생성
            val refreshedToken = tokenProvider.getToken()
            if (refreshedToken != null) {
                return response.request.newBuilder()
                    .header("Authorization", "Bearer $refreshedToken")
                    .build()
            }
            
            return null // 토큰이 없으면 인증 실패
        }
    }
}

// TokenProvider 인터페이스/클래스 (예시)
interface TokenProvider {
    fun getToken(): String?
    fun refreshToken(): String? // 동기적으로 토큰 새로고침
    fun clearToken()
    // ... (토큰 저장/관리 로직)
}
```

- TokenProvider는 일반적으로 토큰 재발급 엔드포인트와 상호 작용하여 새 토큰을 얻는 동기 메서드를 포함
- Authenticator를 사용하려면 OkHttpClient를 생성할 때 아래와 같이 설정이 필요

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .authenticator(TokenAuthenticator(tokenProvider))
    // ... 기타 설정
    .build()
```

##### OkHttp Interceptor 사용하기

- Authenticator와 달리 Interceptor는 모든 요청에 대해 호출되며, 요청을 수정하거나 로깅하는 데 사용
- 401 상태 코드에 대한 응답을 확인하고 토큰을 인라인으로 갱신하는 방법이 있음

```kotlin
class TokenInterceptor(
    private vla tokenProvider: TokenProvider
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response { 
        val token = tokenProvider.getToken()
        val originalRequest = chain.request()
        val requestWithToken = if (token != null) {
            originalRequest.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            originalRequest
        }
      
        val response = chain.proceed(requestWithToken)
       
        // 토큰 만료 확인 (401 응답)
        if (response.code == 401) {
            // 토큰이 만료된 경우 토큰 새로고침 시도
            synchronized(this) {
                val newToken = tokenProvider.refreshToken() // 동기적으로 토큰 새로고침
                if (newToken != null) {
                    // 새 토큰으로 요청 재시도
                    val newRequest = originalRequest.newBuilder()
                        .header("Authorization", "Bearer $newToken")
                        .build()
                    response.close() // 이전 응답 닫기
                    return chain.proceed(newRequest) // 새 요청으로 재시도
                } else {
                    // 새로고침 실패 시 처리 (예: 로그아웃)
                    tokenProvider.clearToken() // 토큰 제거
                }
            }
        }
        return response
    }
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(TokenInterceptor(tokenProvider))
    // ... 기타 설정
    .build()
```

##### Authenticator와 Interceptor의 주요 차이점

- 목적
  - Authenticator는 401 응답에 의해 트리거되는 인증 문제를 처리하도록 설계
  - Interceptor는 모든 요청과 응답을 가로채고 수정하는 등 더 세분화된 제어 처리
- 자동적으로 트리거
  - Authenticator는 401 응답에 대해 자동으로 호출
  - Interceptor는 특정 시나리오를 감지하고 처리하기 위한 수동 로직 필요
- 사례
  - 간단한 인증 문제에는 Authenticator 사용
  - 복잡한 요청/응답 처리가 필요한 시나리오에는 Interceptor 사용

#### Pro Tips for Mastery: Retrofit CallAdapter란?

- Retrofit CallAdapter는 개발자가 Retrofit API 메소드의 반환 타입을 사용자 정의할 수 있도록 하는 추상화 API
- Retrofit API 메소드는 동기식 또는 비동기식으로 실행될 수 있는 HTTP 요청을 나타내는 Call<T> 객체를 반환
- CallAdapter를 사용하면 이 기본 반환 타입을 LiveData, Flow, RxJava 또는 커스텀 타입과 같은 다른 타입으로 변환 가능

##### CallAdapter 작동 방식

- Retrofit은 CallAdapter 인스턴스를 생성하기 위해 CallAdapter.Factory를 사용
- CallAdapter는 런타임에 Call<T> 객체를 원하는 타입으로 변환

##### Retrofit의 기본 CallAdapter

- 기본적으로 Retrofit에는 Call<T>를 반환하는 CallAdapter가 포함되어 있음
- 추가적인 CallAdapter.Factory를 추가하여 다양한 반환 타입 지원 가능

##### Retrofit과 Coroutine CallAdapter 사용하기

- Kotlin Coroutines Adpater를 사용하면 Retrofit API 인터페이스에서 suspend 함수 사용 가능
- Call<T> 타입이 아닌 실제 네트워크 호출 결과를 반환하거나 오류에 대한 예외를 던지도록 함

```kotlin
interface ExampleApi {
    @GET("users")
    suspend fun getUsers(): List<User> // suspend 함수로 직접 결과 반환
}
```

##### 커스텀 CallAdapter

- LiveData를 Retrofit과 통합하려면 다음과 같이 커스텀 CallAdapter를 만들 수 있음

```kotlin
import androidx.lifecycle.LiveData
import retrofit2.*
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type

// LiveData를 반환하는 CallAdapter 구현
class LiveDataCallAdapter<R>(private val responseType: Type) : CallAdapter<R, LiveData<ApiResponse<R>>> {
    override fun responseType() = responseType

    override fun adapt(call: Call<R>): LiveData<R> {
        return object : LiveData<R>() { 
            private var started = AtomicBoolean(false)
          
            override fun onActive() {
               super.onActive()
                if (started.compareAndSet(false, true)) {  // 한 번만 실행되도록 보장
                    call.enqueue(object : Callback<R> {
                        override fun onResponse(call: Call<R>, response: Response<R>) {
                            postValue(response.body())
                        }

                        override fun onFailure(call: Call<R>, t: Throwable) {
                            // 실패 시 처리 (예: 에러 상태 설정)
                            postValue(null)
                        }
                    })
                }
            }
        }
    }
}

// LiveDataCallAdapter 인스턴스를 생성하는 Factory
class LiveDataCallAdapterFactory : CallAdapter.Factory() {
    override fun get(
        returnType: Type,
        annotations: Array<Annotation>,
        retrofit: Retrofit
    ): CallAdapter<*, *>? {
        // 반환 타입이 LiveData인지 확인
        if (getRawType(returnType) != LiveData::class.java) {
            return null
        }
        
        // LiveData의 제너릭 타입 추출 (LiveData<List<user>>에서 List<User> 추출)
        val observableType = getParameterUpperBound(0, returnType as ParameterizedType)
        val rawObservableType = getRawType(observableType)
       
        // 제너릭 타입이 Response인 경우 처리 (선택 사항)
        if (rawObservableType == Response::class.java) {
            if (observableType !is ParameterizedType) {
                throw IllegalArgumentException("Response must be parameterized as Response<Foo> or Response<? extends Foo>")
            }
            val responseType = getParameterUpperBound(0, observableType)
            return LiveDataCallAdapter<Any>(responseType)
        }
        // 일반 LiveData<T> 반환 타입 처리
        return LiveDataCallAdapter<Any>(observableType)
    }
}

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(GsonConverterFactory.create())
    .addCallAdapterFactory(LiveDataCallAdapterFactory()) // 커스텀 CallAdapter Factory 추가
    .build()

interface ExampleApi {
    @GET("users")
    fun getUsers(): LiveData<List<User>> // LiveData 반환 타입
}
```

### 62. 대규모 데이터 셋을 효율적으로 로드하는 데 왜 페이징 기법이 필요하고, RecyclerView로 구현해 본 경험이 있나요?

- 페이징 시스템은 대규모 데이터 셋을 처리할 때 데이터 로드 및 화면에 렌더링 하는 방식을 최적화
- 데이터를 더 작은 페이지로 로드하면 메모리 사용량이 크게 줄어들어 잠재적인 메모리 부족 문제를 방지
- 더 필요한 데이터는 필요할 때만 로드하여 초기 로드 시간을 단축하고, 네트워크 사용량이 최소화되어 특히 대역폭이 제한된 시나리오에서 리소르를 효율적으로 사용 가능
- 사용자 경험 관점에서 사용자가 스크롤을 내릴 때 데이터를 동적으로 로드하여 리스트 또는 그리드에서 부드러운 스크롤을 가능하게 함

#### 페이징 시스템 직접 구현

1. RecyclerView.Adapter 및 ViewHodler 생성
   - 데이터 셋을 표시하기 위한 RecyclerView.Adapter와 ViewHolder를 구현
   ```kotlin
   class PokedexAdapter: List<Pokemon, Pokedex.PokedexViewHolder>(diffUtil) {
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PokedexViewHolder {
            val binding = ItemPokedexBinding.inflate(LayoutInflater.from(parent.context), parent, false)
            return PokedexViewHolder(binding)
        }
   
        override fun onBindViewHolder(holder: PokedexViewHolder, position: Int) {
            holder.bind(getItem(position))
        }
   
        inner class PokedexViewHolder(private val binding: ItemPokedexBinding): RecyclerView.ViewHolder(binding.root) {
            fun bind(item: Pokemon) {
                // 데이터 바인딩 로직
            }
        }
   
        companion object {
            private val diffUtil = object : DiffUtil.ItemCallback<Pokemon>() {
                override fun areItemsTheSame(oldItem: Pokemon, newItem: Pokemon): Boolean {
                    return oldItem.name == newItem.name
                }
   
                override fun areContentsTheSame(oldItem: Pokemon, newItem: Pokemon): Boolean {
                    return oldItem == newItem
                }
            }
        }    
   } 
   ```
   
2. RecyclerView에 addOnScrollListener 추가
   - 스크롤 상태를 트래킹하여 마지막으로 보이는 화면이 데이터 셋의 끝에 가까워지면 다음 데이터셋 로드를 트리거
   - 더 부드러운 로딩을 보장하려면 임계값(threshold)을 설정하여 사용자가 끝에 도달하기 전에 미리 로드
   ```kotlin
   recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            super.onScrolled(recyclerView, dx, dy)
            val layoutManager = recyclerView.layoutManager ?: return
            val lastVisibleItemPosition = when (layoutManager) {
                is LinearLayoutManager -> layoutManager.findLastVisibleItemPosition()
                is GridLayoutManager -> layoutManager.findLastVisibleItemPosition()
                else -> return
            }   
   
            val totalItemCount = layoutManager.itemCount
            val threshold = 4 // 미리 로드할 아이템 개수 (임계값)
   
            // 마지막 아이템에 가까워지고 로딩 중이 아닐 때 다음 페이지 미리 로드)
            if (lastVisibleItemPosition >= totalItemCount - threshold && !isLoading) {
                loadNextPage() // 다음 페이지 로드 함수 호출
            }
        }
   })
   ```
   
3. ReyclerView.Adapter에 새 데이터 셋 추가
   - 다음 데이터를 성공적으로 로드하면 ReyclerView.Adapter의 기존 데이터에 추가
   - 결과적으로 리스트에 새 항목이 추가되고, 레이아웃은 이에 따라 원활하게 업데이트

#### 실전 질문

Q) 앱이 1000개의 데이터 셋을 가져와 리스트에 표시해야 한다고 가정해 봅시다. 원활한 스크롤을 보장하고 메모리 사용량을 줄이기 위해 효율적인 페이징 시스템을 어떻게 구현하시겠습니까?

A) 20개의 항목씩 페이지로 나누어 데이터를 로드하는 페이징 시스템을 구현하겠습니다. RecyclerView에 스크롤 리스너를 추가하여 사용자가 리스트의 끝에 가까워질 때마다 다음 페이지를 비동기적으로 로드하도록 합니다. 이를 위해 Retrofit과 코루틴을 사용하여 네트워크 요청을 처리하고, 로드 중임을 나타내는 플래그(isLoading)를 사용하여 중복 요청을 방지합니다. 새 데이터가 로드되면 RecyclerView.Adapter에 추가하여 리스트를 업데이트합니다.

Q) RecyclerView로 직접 페이징 시스템을 구현할 때 발생할 수 있는 문제는 무엇이며, 원활한 사용자 경험을 제공하기 위해 어떻게 해결할 수 있나요?

A) 스크롤이 끝에 도달할 때마다 여러 번의 네트워크 요청이 발생해 중복 데이터가 로드되거나, 서버에서 동일한 페이지를 반복적으로 가져오는 문제가 발생할 수 있습니다. 또한, 잘못된 페이지 관리로 인해 리스트 순서가 꼬이거나 중간 데이터가 갱신되지 않는 현상이 생길 수 있습니다.
이를 방지하기 위해 로딩 상태를 나타내는 플래그(isLoading)를 두어 중복 요청을 차단하고, 페이지 번호를 명확히 관리하여 올바른 순서로 데이터를 로드합니다.
또한 네트워크 오류 발생 시 사용자에게 피드백과 재시도 옵션을 제공하여 안정적인 사용자 경험을 보장할 수 있습니다.
나아가 Paging 3 라이브러리의 PagingDataAdapter를 활용하면, 이러한 로딩 관리와 중복 방지, 오류 처리 로직을 훨씬 간결하고 안정적으로 구현할 수 있습니다.

### 63. 네트워크에서 이미지를 어떻게 가져오고 렌더링하나요?

- 개발자가 직접 이미지 로딩 시스템을 만드는 것도 가능하지만, 네트워크 요청, 이미지 크기 조절, 캐싱, 렌더링 및 효율적인 메모리 관리와 같은 복잡한 기능을 구현해야 함
- 직접 이미지 로딩 솔루션을 구추갛는 대신, Glide, Coil, Fresco와 같은 라이브러리를 활용할 수 있음

#### Glide

- 캐싱, 플레이스홀더 이미지 및 이미지 변환과 같은 복잡한 시나리오를 처리하는 데 이상적
- 자동으로 이미지를 캐시하여 네트워크 호출을 최저과하고 성능을 향상
- 애니메이션 GIF 지원, 플레이스홀더, 변환, 캐싱, 리소스 재사용과 같은 유용한 기능 제공

```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg") // 이미지 URL
    .placeholder(R.drawable.placeholder) // 로딩 중 표시할 이미지
    .error(R.drawable.error_image) // 오류 시 표시할 이미지
    .circleCrop() // 이미지 변환 (예: 원형 크롭)
    .transition(DrawableTransitionOptions.withCrossFade()) // 페이드 인 애니메이션
    .into(imageView) // 이미지를 로드할 ImageView
```

#### Coil

- Kotlin Multiplatform으로 설계된 100% Kotlin 기반의 이미지 로딩 라이브러리
- 내부적으로 Coroutines를 활용하고 Jetpack Compose와 같은 최신 기능 지원
- 이미지 변환, 애니메이션 GIF 지원, SVG 렌더링, 비디오 프레임 추출과 같은 유용한 기능 제공

```kotlin
import coil.load
import coil.transform.CircleCropTransformation

imageView.load("https://example.com/image.jpg") {
    crossfade(true) // 페이드 인 애니메이션
    placeholder(R.drawable.placeholder) // 로딩 중 표시할 이미지
    error(R.drawable.error_image) // 오류 시 표시할 이미지
    transformations(CircleCropTransformation()) // 이미지 변환 (예: 원형 크롭)
    // size(Size.ORIGINAL) // 원본 크기로 로드
    // memoryCachePolicy(CachePolicy.ENABLED) // 메모리 캐싱 활성화
    // diskCachePolicy(CachePolicy.ENABLED) // 디스크 캐싱 활성화
}
```

#### Fresco

- Meta에서 개발한 이미지 로딩 라이브러리로 이미지를 디코딩하고 표시하기 위해 자체 파이프라인을 사용
- 큰 이미지 처리, 점진적 렌더링 및 고급 캐싱 전략에 매우 효율적이어서 메모리 제약이 있는 애플리케이션에 특히 유용
- 이미지 파이프라인, 드로위(Drawees), 최적화된 메모리 관리, 고급 로딩 메커니즘, 스트리밍 및 애니메이션과 같은 기능 제공
- 안드로이드 4.x 이하에서 이미지를 특수 메모리 영역에 할당하여 성능을 높였지만, 최신 안드로이드 버전에서는 이점이 줄어들었음

```kotlin
// Fresco 초기화 (Application 클래스에서)
// Fresco.initialize(this)

// 레이아웃에서 SimpleDraweeView 사용
val draweeView: SimpleDraweeView = findViewById(R.id.my_image_view)
val uri = Uri.parse("https://example.com/image.jpg")
draweeView.setImageURI(uri)

// 또는 Controller를 사용하여 서 세밀하게 제어
// val controller = Fresco.newDraweeControllerBuilder()
//     .setUri(uri)
//     .setOldController(draweeView.controller)
//     .build()
// draweeView.controller = controller
```

```xml
<com.facebook.drawee.view.SimpleDraweeView 
    xmlns:fresco="http://schemas.android.com/apk/res‑auto" <!‑‑ 네임스페이스 추가 ‑‑>
    android:id="@+id/drawee_view"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    fresco:placeholderImage="@drawable/placeholder" <!‑‑ 플레이스홀더 설정 ‑‑>
    fresco:failureImage="@drawable/error_image" <!‑‑ 오류 이미지 설정 ‑‑>
    fresco:progressBarImage="@drawable/loading_spinner" <!‑‑ 로딩 스피너 설정 ‑‑>
/>
```

#### 실전 질문

Q) 앱이 백엔드 서버에서 고해상도 이미지를 로드하여 RecyclerView에서 부드러운 스크롤을 제공해야 합니다. 어떤 이미지 로딩 라이브러리를 선택할 것이고, UI 지연을 방지하기 위해 성능을 어떻게 최적화하시겠습니까?

A) Coil을 선택하겠습니다. 썸네일를 사용하거나 이미지 크기를 적절히 조절하고, 메모리 및 디스크 캐싱을 활성화하여 네트워크 요청을 최소화하겠습니다. 또한, RecyclerView에서 onViewRecycled 콜백을 활용하여 불필요한 이미지 로딩 작업을 취소해서 메모리 사용량을 줄이겠습니다.

### 64. 로컬 디바이스에 데이터를 저장하고 복원하는 방법에 대해서 설명해 주세요.

#### SharedPreferences

- 앱 내 설정이나 사용자 환경 설정과 같은 가벼운 값에 가장 적합한 키-값 쌍 형태의 데이터 저장 메커니즘
- Boolean, Int, String, Float과 같은 원시타입(primitive 타입)을 저장하고 앱 재시작 시에도 유지
- SharedPreferences는 동기적으로 작동하여 메인 스레드를 차단하는 문제가 있고, 최근 DataStore의 등장으로 덜 선호됨

```kotlin
import androidx.core.content.edit // KTX 확장 함수 사용

val sharedPreferences = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
// KTX 확장 함수를 사용하여 간단하게 데이터 수정 후 반영
sharedPreferences.edit {
    putString("username", "JohnDoe")
    putInt("age", 30)
    // apply()  변경 사항을 비동기적으로 저장
    // commit() 변경 사항을 동기적으로 저장
    // KTX edit 함수는 apply()를 기본적으로 호출
}

// 값 읽기
val userName = sharedPreferences.getString("user_name", null) // 기본값 지정
```

#### DataStore

- 키-값 저장을 위한 PreferencesDataStore와 구조화된 객체 값 데이터를 위한 ProtoDataStore의 두 가지 유형 제공
- SharedPreferences와 달리 DataStore는 비동기적으로 작동하여 메인 스레드를 차단하지 않음

```kotlin
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking

// Context의 확장 함수로 DataStore 인스턴스 생성 (싱글톤 권장)
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")

// 데이터 저장을 위한 키 정의
val USER_NAME_KEY = stringPreferencesKey("user_name")

// 데이터 쓰기 (코루틴 내에서 수행)
suspend fun saveUserName(context: Context, name: String) {
    context.dataStore.edit { settings ‑>
        settings[USER_NAME_KEY] = name
    }
}

// 데이터 읽기 (Flow 사용)
fun getUserNameFlow(context: Context): Flow<String?> {
    return context.dataStore.data
        .map { preferences ‑>
            preferences[USER_NAME_KEY] // 키에 해당하는 값 반환 (없으면 null)
        }
}

// 값 저장 및 복원 예시
fun exampleUsage(context: Context) {
    viewModelScope.launch {
        saveUserName(context, "John Doe")
        val name = getUserNameFlow(context).first() // Flow에서 첫 번째 값 가져오기
        Log.d("DataStore", "User name: $name")
    }
}
```

#### Room Database

- 구조화되고 관계형 데이터를 처리하도록 설계된 SQLite를 수준 높게 추상화한 솔루션
- 어노테이션, 컴파일 타임 검사, 반응형 프로그래밍을 위한 LiveData 또는 Flow 지원을 통해 데이터베이스 관리를 단순화
- 복잡한 쿼리나 대량의 구조화된 데이터 저장이 필요한 앱에 이상적

```kotlin
// 데이터 엔티티 정의
@Entity(tableName = "users") // 테이블 이름 지정 (선택사항)
data class User(
    @PrimaryKey val id: Int,
    @ColumnInfo(name = "user_name") val name: String,
)

// 데이터 접근 객체(DAO) 정의
@Dao
interface UserDao {
    // suspend 함수로 비동기 처리
    @Insert(onConflict = OnConflictStrategy.REPLACE) // 충돌 시 대체
    suspend fun insertUser(user: User)
    
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserById(userId: Int): User?
    
    @Query("SELECT * FROM users ORDER BY user_name ASC")
    fun getAllUsers(): Flow<List<User>> // Flow로 비동기 스트림 제공
}

// 데이터베이스 클래스 정의
@Database(entities = [User::class], version = 1, exportSchema = false)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
  
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

#### File Storage

- 바이너리 또는 커스텀 데이터의 경우 안드로이드는 내부 또는 외부 저장소에 파일을 젖아할 수 있음
- 내부 저장소는 앱 전용이며 다른 앱에서 접근 불가, 외부 저장소는 사용자와 다른 앱이 접근 가능
- 파일 I/O 작업은 이미지, 비디오 또는 커스텀 직렬화된 데이터 저장과 같은 작업에 사용 가능

```kotlin
// 내부 저장소의 앱별 디렉토리에 파일 생성
val file = File(context.filesDir, "user_data.txt")
try {
    FileOutputStream(file).user { fos ->
        fos.write("Sample user data".toByteArray())
    }
    // 또는 BufferedWriter 사용
    // file.bufferedWriter().use { it.write("Sample user data") }
} catch (e: IOException) {
    e.printStackTrace()
}

// 파일 읽기 (예시)
try {
    val content = file.readText()
    Log.d("FileStorage", "File content: $content")
} catch (e: IOException) {
    e.printStackTrace()
}
```

#### 실전 질문

Q) 오프라인 접근을 위해 네트워크 API에서 받은 대용량 JSON 응답을 저장해야 하는 시나리오에서 어떤 로컬 저장 메커니즘을 사용할 것이고, 그 이유는 무엇인가요?

A) 대용량 JSON 응답을 저장하기 위해 Room Database를 사용할 것입니다. Room은 구조화된 데이터를 효율적으로 저장하고 쿼리할 수 있는 강력한 기능을 제공하며, 컴파일 타임에 SQL 쿼리를 검증하여 오류를 줄입니다. 또한, LiveData 또는 Flow와 같은 반응형 프로그래밍을 지원하여 UI 업데이트를 쉽게 처리할 수 있습니다. 대용량 데이터를 다룰 때는 데이터 무결성과 성능이 중요하므로, Room이 이러한 요구 사항을 충족하는 데 적합합니다.

### 65. 오프라인 우선(offline-first) 아키텍처를 어떻게 설계하실 건가요?

#### 오프라인 우선 아키텍처의 핵심 개념

1. 로컬 데이터 지속성(Local Data Persistence)
   - Room Database는 구조화된 로컬 데이터를 관리하기 위해 권장되는 솔루션
   - 앱이 오프라인 상태에서 데이터에 접근하고 업데이트할 수 있도록 보장
   - Room은 Kotlin Coroutines 및 Flow, LiveData와 원활하게 통합되어 비동기 데이터 작업을 단순화
2. 데이터 동기화(Data Synchronization)
   - 로컬 데이터와 원격 데이터 간의 동기화되는 일관성 보장
   - WorkManager는 네트워크 연결과 같은 조건이 충족될 때 지연된 동기화 작업이 실행되도록 함
   - 또한, 실패한 작업을 자동으로 재시도하여 데이터 무결성을 보장
3. 캐시 및 가져오기 정책(Cache and Fetch Policies)
   - 캐싱 데이터 읽기: 앱이 먼저 로컬 저장소에서 데이터를 가져오고 필요할 때만 네트워크에 새로운 데이터를 요청
   - 캐싱 데이터 쓰기: 업데이트가 로컬에 기록되고 백그라운드에서 서버와 동기화
4. 충돌 해결(Conflict Resolution)
   - 최신 데이터 우선: 가장 최근 변경 사항을 우선시
   - 사용자 정의: 사용자가 수동으로 충돌을 해결하거나 도메인별 규칙을 적용하도록 허용

#### 실제 구현

```kotlin
// 데이터 엔티티 (동기화 상태 플래그 포함)
@Entity
data class Article(
    @PrimaryKey val id: Int,
    val title: String,
    val content: String,
    val isSynced: Boolean = false   // 서버와 동기화되었는지 여부
)

// DAO 인터페이스
@Dao
interface ArticleDao {
    @Query("SELECT * FROM Article")
    fun getAllArticles(): Flow<List<Article>>
    
    // 로컬에만 있는 미동기화된 Article 조회
    @Query("SELECT * FROM Article WHERE isSynced = 0")
    suspend fun getUnsyncedArticles(): List<Article>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertArticle(article: Article)
    
    // 동기화 완료 후 상태 업데이트
    @Query("UPDATE Article SET isSynced = 1 WHERE id = :articleId")
    suspend fun markArticleAsSynced(articleId: Int)
}

// 동기화 Worker
class SyncWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {
    private val articleDao = AppDatabase.getInstance(appContext).articleDao()

    override suspend fun doWork(): Result {
        return try {
            val unsyncedArticles = articleDao.getUnsyncedArticles()
          
            if (unsyncedArticles.isNotEmpty()) {
                // 서버와 동기화 시도
                if (syncToServer(unsyncedArticles)) {
                    // 성공 시 로컬 상태 업데이트
                    unsyncedArticles.forEach {
                        articleDao.markArticleAsSynced(it.id)
                    }
                    Log.d("SyncWorker", "Sync successful for ${unsyncedArticles.size} articles.")
                } else {
                    Log.e("SyncWorker", "Sync failed.")
                    return Result.retry() // 실패 시 재시도
                }
                return Result.success() // 동기화할 항목이 없음
            } else {
                Log.d("SyncWorker", "No unsynced articles to sync.")
            }
            Result.success()
        } catch (e: Exception) {
            Result.retry() // 실패 시 재시도
        }
    }
  
    // 서버와 동기화하는 실제 로직 (네트워크 호출 등)
    private suspend fun syncToServer(articles: List<Article>): Boolean {
        // 실제 네트워크 요청 및 결과 처리 로직 구현
        Log.d("SyncWorker", "Attempting to sync ${articles.size} articles...")
        // 아래 예시에서는 가짜로 지연시키고 성공을 반환하고 있는데,
        // 실제 구현에서는 네트워크 요청 로직이 들어감
        kotlinx.coroutines.delay(2000)
        return true // 실제 구현에서는 API 호출 결과에 따라 반환
    }
}
```

#### 실전 질문

Q) 네트워크가 자주 끊기는 국가 및 지역에서도 원활한 사용자 경험을 보장하기 위해 오프라인 우선 기능을 어떻게 설계하시겠습니까?

A) 오프라인 우선 기능을 설계할 때, 먼저 Room Database를 사용하여 로컬에 데이터를 저장하고 관리합니다. 사용자가 데이터를 생성하거나 수정할 때, 변경 사항을 로컬에 즉시 반영하고, 동기화 상태를 나타내는 플래그를 추가하여 서버와의 동기화 여부를 추적합니다. WorkManager를 활용하여 네트워크 연결이 복구되었을 때 자동으로 동기화 작업을 수행하도록 설정합니다. 또한, 충돌 해결 전략을 마련하여 로컬과 서버 간의 데이터 불일치 문제를 최소화하고, 사용자에게 필요한 경우 수동으로 충돌을 해결할 수 있는 옵션을 제공합니다.

Q) 로컬 Room 데이터베이스 변경 사항을 백엔드 서버의 최신 데이터와 동기화하는 데 어떤 전략을 사용할 것이고, 로컬 및 백엔드가 모두 변경되었을 때 충돌을 어떻게 해결하시겠습니까?

A) 로컬 데이터베이스와 백엔드 서버 간의 동기화를 위해 WorkManager를 사용하여 네트워크 연결이 가능할 때마다 동기화 작업을 수행하도록 설정합니다. 동기화 작업은 로컬에서 변경된 데이터를 서버에 전송하고, 서버에서 최신 데이터를 가져와 로컬 데이터베이스를 업데이트하는 방식으로 진행됩니다. 충돌 해결 전략으로는 '최신 변경 사항 우선' 방식을 채택하여, 타임스탬프를 기반으로 가장 최근에 수정된 데이터를 우선시합니다. 만약 동일한 데이터가 로컬과 서버에서 모두 변경되었다면, 사용자에게 충돌 알림을 제공하고 수동으로 해결할 수 있는 인터페이스를 제공하여 데이터 무결성을 유지합니다.