### Q27. Layout이란 무엇인가요?

Layout 컴포저블은 자식 컴포저블의 크기 측정 및 위치 지정에 대한 완전한 제어를 제공하는 저수준 API

#### Layout 작동 방식

1. 측정 단계(Measurement Phase)
   - 부모가 제공한 제약 조건에 따라 각 자식 컴포저블의 크기를 결정
2. 배치 단계(Placement Phase)
   - 사용 가능한 공간 내에 각 자식 컴포저블을 배치

```kotlin
@Composable
fun CustomLayout(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit // 자식 컴포저블을 받는 람다 함수
) {
    Layout(
        content = content,  // 자식 컴포저블 컨텐츠
        modifier = modifier // 외부에서 전달된 Modifier 적용
    ) { measurables, constraints -> // 측정 가능한 자식 목록과 부모 제약 조건
        // 1. 자식 측정
        val placeables = measurables.map { measurable ->
            // 각 자식에게 제약 조건을 전달하여 측정
            measurable.measure(constraints)
        }

        // 2. 레이아웃 크기 결정
        // 예: 모든 자식 높이의 합으로 결정, 너비는 최대 제약 조건 사용
        val width = constraints.maxWidth
        val height = placeables.sumOf { it.height }

        // 결정된 크기로 레이아웃 정의
        layout(width, height) {
            // 3. 자식 배치
            var yPosition = 0
            placeables.forEach { placeable ->
                // 각 자식은 (0, yPosition)에 배치
                placeable.placeRelative(x = 0, y = yPosition)
                // 다음 자식의 y 위치 업데이트
                yPosition += placeable.height
            }
        }
    }
}
```

#### Layout의 주요 구성 요소

1. 자식 측정(Measuring Children)
   - measure() 함수는 부모로부터 제약 조건을 적용하여 각 자식 컴포저블을 측정하는 데 사용
2. 레이아웃 크기 결정(Determining Layout Size)
   - layout() 함수는 레이아웃의 최종 너비와 높이를 정의
3. 자식 배치(Placing Children)
   - placeRelative() 함수는 레이아웃 내에서 각 자식 컴포저블이 배치될 위치를 결정

#### Layout 유즈 케이스

- 표준 레이아웃 컴포넌트가 달성하지 모하는 특수한 디자인 요구 사항에 필요한 커스텀 컴포넌트를 구현해야 하는 시나리오에서 유용
- 비표준 배열, 겹치는 요소 또는 콘텐츠에 따라 동적으로 크기가 조절되는 컴포넌트와 같이 복잡한 UI 구조를 구현할 때 특히 유용

#### 실전 질문

Q) Row 또는 Column과 같은 표준 컴포넌트 대신 Layout 컴포저블로 컴포넌트를 구현해 본 경험이 있나요? 어떤 장점이 있나요?

A) 지그재그로 배치되는 이미지 갤러리를 구현할 때 Layout을 사용해 보았습니다. 표준 Row나 Column으로는 구현하기 어려운 복잡한 배치 요구 사항을 충족할 수 있었고, 각 이미지의 크기와 위치를 세밀하게 제어할 수 있었습니다.

Q) LazyVerticalGrid를 사용하여 달성할 수 없는 지그재그 형태의 그리드 레이아웃을 구축한다고 가정했을 때, Layout를 사용하여 어떻게 구현해 볼 수 있을까요?

A) 각 아이템의 높이가 다를 때 지그재그 형태의 그리드 레이아웃을 구현하려면, Layout 컴포저블을 사용하여 각 아이템의 크기를 측정하고, 가로 방향으로는 일정한 간격을 유지하면서 세로 방향으로는 아이템의 높이에 따라 위치를 조정할 수 있습니다.

```kotlin
@Composable
fun ZigZagGrid(
    columns: Int,
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
) {
    Layout(
        content = content,
        modifier = modifier
    ) { measurables, constraints ->

        val columnWidth = constraints.maxWidth / columns
        val columnHeights = IntArray(columns) { 0 }

        val placeablesWithPosition = measurables.map { measurable ->

            val placeable = measurable.measure(
                constraints.copy(
                    minWidth = columnWidth,
                    maxWidth = columnWidth
                )
            )

            // 가장 낮은 column 선택
            val column = columnHeights
                .withIndex()
                .minBy { it.value }
                .index

            val x = column * columnWidth
            val y = columnHeights[column]

            columnHeights[column] += placeable.height

            Triple(placeable, x, y)
        }

        val height = columnHeights.maxOrNull() ?: constraints.minHeight

        layout(
            width = constraints.maxWidth,
            height = height
        ) {
            placeablesWithPosition.forEach { (placeable, x, y) ->
                placeable.place(x, y)
            }
        }
    }
}
```

#### Pro Tips for Mastery: SubcomposeLayout의 개념 및 동작 원리

SubcomposeLayout은 레이아웃 내에서 동적 컴포지션을 허용하는 저수준 API<br> 
UI 컴포넌트가 부모 레이아웃 패스와 독립적으로 하위 컴포넌트를 recompose해야 할 때 주로 사용

##### SubcomposeLayout 작동 방식

측정 단계 중 자식의 컴포지션을 제약 조건이 정해질 때까지 지연하는 것을 허용하여 특수한 경우에 유연성을 제공<br>
일반적인 사용 사례는 다음과 같음:
- 일반적인 Layout 또는 LayoutModifier로 처리할 수 없는 컴포지션 중 부모가 가지는 제약 조건에 접근하는 경우
- 한 자식의 크기에 따라 다른 자식을 측정하거나 배치해야 하는 경우
- 긴 리스트에서 보이는 항목만 렌더링하고 필요할 때까지 다른 항목을 지연시키는 등 사용 가능한 공간을 기반으로 항목을 지연 구성(lazyily compose)하려는 경우
- 컴포저블 크기가 컴포지션 타임에 동적으로 정해져야 하는 콘텐츠의 경우
- 레이아웃 로직이 어려 독립적인 단계에 걸쳐 자식을 측정하고 배치해야 하는 경우
- 입력이 변경될 때만 recompose 되어야 하는 LazyList의 헤더와 같은 동적 UI를 처리하는 경우

##### 사용 예제

```kotlin
@Composable
fun DynamicContentLayout() {
    SubcomposeLayout { constraints -> // 부모로부터 받은 제약 조건
        // "content" 슬롯에 대한 하위 컴포지션 수행
        val placeables = subcompose("content") {
            Text(text = "Hello, skydoves!")
        }.map {
            it.measure(constraints)
        }

        // 측정된 크기 계산 (여기서는 첫 번째 요소만 사용)
        val measurable = placeables.firstOrNull()

        // 레이아웃 크기 결정
        val width = measurable?.width ?: 0
        val height = measurable?.height ?: 0

        // 레이아웃 배치
        layout(width, height) {
            // 측정된 자식 컴포저블 배치
            measurable?.placeRelative(0, 0)
        }
    }
}
```

- subcompose("content")는 텍스트 콘텐츠를 동적으로 구성
- measure 함수는 주어진 제약 조건에 따라 자식 크기를 계산
- layout 함수는 측정된 자식을 적절하게 배치

#### 고려 사항

- 자식 컴포넌트를 여러 번 재측정하고 구성할 수 있으므로 불필요한 recomposition이 발생하여 성능 저하를 유발할 수 있음
- 여러 횟수의 측정이 요구되는 UI 컴포넌트와 같은 표준 레이아웃으로 충분하지 않은 경우에 가장 적합

### Q28. Box에 대해 아는 대로 다 설명해 주세요.

Box는 여러 자식 컴포저블을 부모 내에 자유롭게 쌓을 수 있도록 설계된 Jetpack Compose의 기본적인 레이아웃 컴포넌트

#### Box 동작 방식

- 기본적으로 자식을 왼쪽 상단 정렬로 배열하지만 contentAlignment 매개변수를 사용하여 정렬을 커스텀할 수 있음
- Modifier 속성을 통해 크기, 패딩, 배경 및 클릭 상호 작용을 커스텀할 수 있음

#### 사용 예제

```kotlin
@Composable
fun ImageWithOverlay() {
    Box(
        modifier = Modifier.size(200.dp),
        contentALignment = Alignment.BottomCenter
    ) {
        // 배경 이미지
        Image(
            painter = painterResource(id = R.drawable.skydoves_image),
            contentDescription = "Background Image",
            contentScale = ContentScale.Crop,
            modifier = Modifier.matchParentSize()
        )
        // 오버레이 텍스트
        Text(
            text = "Hello, skydoves!",
            color = Color.White,
            modifier = Modifier
                .background(Color.Black.copy(alpha = 0.5f))
                .padding(8.dp)
        )
    }
}
```

- Box는 Image와 Text가 모두 Box의 사이즈 내에 위치하도록 보장
- contentAlignment = Alignment.BottomCenter는 모든 내부 콘텐츠를 Box의 하단 중앙에 배치
- Text에는 더 나은 가독성을 위해 반투명 배경 사용

#### 주요 특징

- 단일 레이아웃 내에 여러 자식 컴포저블을 겹치도록 쌓을 수 있어 UI 컴포넌트 오버레이에 유용
- Box에서 제공하는 contentAlignment 또는 자식 수준의 컴포저블에서 사용 가능한 Modifier.align()을 통해 정렬 제어를 구현

#### 실전 질문

Q) 어떤 시나리오에서 Column이나 Row 대신 Box를 사용하는 것이 효율적이고, Box는 자식 컴포저블을 어떻게 다르게 처리하나요?

A) Box는 자식 컴포저블을 겹치게 쌓아야 하는 경우에 효율적입니다. Box는 설정한 정렬 조건에 따라 자식 컴포저블을 쌓습니다.

Q) Box의 contentAlignment 매개변수는 자식 컴포저블에서 각각 Modifier.align()을 사용하는 것과 어떻게 다른가요? 둘 다 함께 사용할 수 있나요?

A) contentAlignment는 Box 내의 모든 자식 컴포저블에 대한 기본 정렬을 설정하는 반면, Modifier.align()은 개별 자식 컴포저블에 대해 별도의 정렬을 지정합니다. 둘 다 함께 사용할 수 있으며, Modifier.align()이 contentAlignment보다 우선 적용됩니다.

#### Pro Tips for Mastery: BoxWithConstraints 살펴보기

BoxWithConstraints는 컴포지션 중 부모의 레이아웃 제약 조건에 대한 접근을 제공하는 고급 레이아웃 API

##### BoxWithConstraints 작동 방식

- 컨텐츠 람다 함수 내에서 maxWidth, maxHeight, minWidth, minHeight와 같은 프로퍼티를 담고 있는 Constraints 스코프를 제공
- 해당 값들은 해당 BoxWithConstraints 컴포저블이 렌더링될 수 있는 크기를 나타내므로 주어진 제약 조건에 따라 자식 UI들을 유동적으로 스타일링

##### 사용 예제

```kotlin
@Composable
fun ResponsiveText() {
    BoxWithConstraints(
        modifier = Modifier.fillMaxWidth()
    ) {
        // maxWidth 제약 조건에 따라 텍스트 크기 결정
        val textSize = if (maxWidth < 300.dp) 14.sp else 20.sp
        Text(
            text = "Hello, skydoves!",
            fontSize = textSize
        )
    }
}
```

- BoxWithConstraints 컴포저블은 해당 컴포저블 내에서 사용할 수 있는 최대 가로 사이즈인 maxWidth를 제공
- maxWidth가 300.dp 미만이면 텍스트 크기가 14.sp로 설정되고, 그렇지 않으면 20.sp로 설정
- 텍스트가 사용 가능한 화면 너비에 따라 동적으로 변화

##### 주요 특징

- 실시간으로 제약 조건 값을 제공하므로 화면 크기에 따라 조건부로 레이아웃을 변경하거나, 타이포그래피를 조정하거나, UI 컴포넌트를 재배열
- 일반 Box에 비해 더 많은 오버헤드를 발생 (내부적으로 SubcomposeLayout 사용)하므로, 제약 조건에 접근할 필요가 없는 경우에는 일반 Box를 사용하는 것이 좋음

```kotlin
@Composable
@UiComposable
fun BoxWithConstraints(
    modifier: Modifier = Modifier,
    contentAlignment: Alignment = Alignment.TopStart,
    propagateMinConstraints: Boolean = false,
    content: @Composable @UiComposable BoxWithConstraintsScope.() -> Unit
) {
    val measurePolicy = maybeCachedBoxMeasurePolicy(contentAlignment, propagateMinConstraints)
    SubcomposeLayout(modifier) { constraints ->
        val scope = BoxWithConstraintsScopeImpl(this, constraints)
        val measurables = subcompose(Unit) { scope.content() }
        with(measurePolicy) { measure(measurables, constraints) }
    }
}
```

### Q29. Arrangement와 Alignment의 차이점에 대해서 설명해 주세요.

#### Arrangement란 무엇인가?

- Row 또는 Column과 같이 항목을 단일 방향으로 정렬하는 레이아웃 내에서 여러 자식 컴포저블의 간격 및 분포를 제어
- 레이아웃의 주축(main axis)을 따라 자식이 어떻게 배치되는지를 결정

#### Arrangement 예제

```kotlin
@Composable
fun RowWithArrangement() {
    Row(
        modifier = Modifier.fillMaxWidth(),
        // 자식 사이에 공간을 균등하게 분배
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(text = "Hello")
        Text(text = "skydoves")
    }
}
```

- Arrangement.SpaceBetween은 두 Text 컴포저블이 사용 가능한 너비에 걸쳐 균등하게 간격을 두도록 보장

#### Alignment란 무엇인가?

- Alignment는 자식 컴포저블이 교차축(cross axis)을 따라 부모 내에서 어떻게 배치되는지를 결정
- Row에서 Alignment는 수직 위치를 지정하는 데 영향을 미침
- Column에서 Alignment이 수평 위치를 지정하는 데 영향을 미침
- Box에서 Alignment는 수평 및 수직 위치 모두를 지정하는 데 영향을 미침

#### Alignment 예제

```kotlin
@Composable
fun ColumnWithAlignment() {
    Column(
        modifier = Modifier.fillMaxSize(),
        // 자식을 수평 중앙에 정렬
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Hello")
        Text(text = "skydoves")
    }
}
```

- horizontalAlignment = Alignment.CenterHorizontally는 두 Text 요소가 Column 내에서 수평 기준으로 중앙에 정렬되도록 보장
- Column은 여전히 자식을 수직으로 쌓지만 수평 축을 따라 중앙에 정렬

#### 주요 차이점

- Arrangement는 주축을 따라 여러 자식 요소의 위치를 지정하는 데 사용
- 반면 Alignment는 교차축을 따라 부모 내 개별 요소의 위치를 지정하는 데 사용

#### 실전 질문

Q) 항목이 화면 전체에 균등하게 간격을 두고 상단에 정렬되어야 하는 Row를 떠올려 보세요. Arrangement와 Alignment 조합을 어떻게 사용해서 구현하실 건가요?

A) 
```
Row(
    modifier = Modifier.fillMaxWidth(),
    horizontalArrangement = Arrangement.SpaceBetween, // 주축을 따라 균등 간격
    verticalAlignment = Alignment.Top // 교차축을 따라 상단 정렬
) {
    Text(text = "Item 1")
    Text(text = "Item 2")
    Text(text = "Item 3")
}
```

Q) Row에서 horizontalAlignment를 설정해도 동작하지 않는데, 반면 Column에서는 작동하는 이유는 무엇인가요? Compose 레이아웃 규칙 중 어떤 것이 이러한 동작을 유발하나요?

A) Alignment 속성은 교차축에 대한 정렬 옵션이기 때문에 Row에서 horizontalAlignment를 설정해도 동작하지 않습니다. Row에서는 수직 정렬을 제어하는 verticalAlignment 속성을 사용해야 합니다. 반면 Column에서는 horizontalAlignment가 수평 정렬을 제어하므로 작동합니다.

### Q30. Painter에 대해서 설명해 주세요.

Painter는 이미지, 벡터 그래픽 및 drawable 콘텐츠를 렌더링하는 데 사용되는 추상 클래스

#### Painter 작동 방식

전통적인 이미지 로딩 접근 방식과 달리 Painter는 이미지 리소스를 표시하는 UI 컴포넌트와 분리<br>
Compose UI에서 다음과 같은 방식으로 페인터를 구현:
- res/drawable 폴더에서 이미지를 로드하기 위한 painterResource(id)
- 단색으로 영역을 채우기 위한 ColorPainter(color)
- ImageVector에서 동적으로 VectorPainter를 생성하기 위한 rememberVectorPainter(image = ImageVector)

#### 사용 예제

```kotlin
@Composable
fun DisplayImage() {
    // drawable 리소스에서 Painter 로드
    val painter = painterResource(id = R.drawable.skydoves_image)
    Image(
        painter = painter,
        modifier = Modifier.size(100.dp),
        contentDescription = "Sample Image",
    )
}
```

```kotlin
@Composable
fun DisplayVector() {
    // Icons.Default.Start ImageVector에서 VectorPainter 생성
    val painter = painterVectorPainter(image = Icons.Default.Star)
    Image(
        painter = painter,
        modifier = Modifier.size(100.dp),
        contentDescription = "Sample Image",
    )
}
```

#### 주요 특징

- Painter 객체는 drawable 리소스를 Compose UI에 렌더링할 수 있는 형태로 나타내며 안드로이드의 전통적인 Drawable API를 대체하여 사용
- 커스텀 페인터를 만들려면 Painter 클래스를 상속받고 커스텀 그래픽 렌더링을 위해 필요한 DrawScope를 제공하는 onDraw 메소드를 구현

#### 실전 질문

Q) Jetpack Compose에서 커스텀 Painter를 만들어 본 적이 있나요? 어떤 시나리오에서 사용했고, 드로잉 로직을 어떻게 구현했나요?

A) 네, 커스텀 Painter를 만들어 본 적이 있습니다. 예를 들어, 원형 진행 표시기를 구현할 때 사용했습니다. onDraw 메소드에서 Canvas API를 사용하여 원형 Arc를 그렸고, 진행 상태에 따라 Arc의 각도를 동적으로 변경했습니다.

### Q31. 네트워크에서 받아오는 이미지는 어떻게 로딩하나요?

Coil, Glide, Landscapist와 같은 서드파티 라이브러리를 사용하여 URL에서 이미지를 효율적으로 로드하고 표시

#### Coil

- Jetpack Compose 및 Kotlin Multiplatform에 최적화된 이미지 로딩 라이브러리
- 내부적으로 OkHttp 및 Coroutines와 같이 안드로이드에서 이미 널리 사용되는 라이브러리 사용
- Jetpack Compose도 지원하면 변환, 애니메이션 GIF 지원, SVG 지원 및 비디오 프레임 지원과 같은 유용한 기능을 제공

```kotlin
AsyncImage(
    model = "https://example.com/image.jpg",
    contentDescription = null,
    // 추가 옵션 (플레이스홀더, 오류 이미지, 변환 등)
    placeholder = painterResource(R.drawable.placeholder),
    error = painterResource(R.drawable.error),
    contentScale = ContentScale.Crop,
    modifier = Modifier.size(128.dp)
)
```

#### Glide

- 현재 Compose 라이브러리는 여전히 베타 상태이며 유지 관리가 되지 않고 있음
- 애니메이션 GIF 지원, 플레이스홀더, 변환, 캐싱 및 효율적인 리소스 재사용과 같은 유용한 기능을 제공

```kotlin
import com.bumptech.glide.integration.compose.ExperimentalGlideComposeApi
import com.bumptech.glide.integration.compose.GlideImage

@OptIn(ExperimentalGlideComposeApi::class)
GlideImage(
    model = myUrl, // 이미지 URL 또는 모델
    contentDescription = stringResource(R.string.picture_of_cat), // 접근성 설명
    modifier = Modifier
        .padding(padding)
        .clickable(onClick = onClick)
        .fillMaxSize(),

    // 추가 옵션 (플레이스홀더, 오류, 변환 등)
    // loading = placeholder(R.drawable.placeholder),
    // failure = placeholder(R.drawable.error),
    // requestBuilderTransform = { it.circleCrop() }
)
```

#### Landscapist

- Glide, Coil 또는 Fresco의 코어 시스템을 사용하여 네트워크 또는 로컬 리소스에서 이미지를 가져와 Jetpack Compose 및 Kotlin Multiplatform에 가장 최적화된 성능으로 이미지를 로딩하는 라이브러리
- 모듈식 컴포넌트를 포함하여 광범위한 커스텀 옵션을 제공

```kotlin
import com.skydoves.landscapist.glide.GlideImage
import com.skydoves.landscapist.components.rememberImageComponent
import com.skydoves.landscapist.placeholder.shimmer.ShimmerPlugin

GlideImage( // 또는 CoilImage, FrescoImage
    imageModel = { imageUrl }, // 이미지 모델 제공 (람다 사용 권장)
    modifier = modifier,

    // ImageComponent를 사용하여 플러그인 구성
    component = rememberImageComponent {
        // 이미지 로딩 중 shimmer 효과
        +ShimmerPlugin(
            baseColor = Color.DarkGray,      // shimmer 기본 색상
            highlightColor = Color.LightGray // shimmer 하이라이트 색상
        )

        // +CrossfadePlugin() // 크로스페이드 애니메이션 (선택)
        // +PlaceholderPlugin.Failure(
        //     painterResource(id = R.drawable.error)
        // ) // 로딩 실패 시 이미지
    },

    // 요청 실패 시 표시할 UI
    failure = {
        Text(text = "Image request failed.")
    },

    // 로딩 중 플레이스홀더 (선택)
    // loading = { CircularProgressIndicator() }
)
```

#### 실전 질문

Q) Jetpack Compose에서 이미지를 로드하기 위해 사용해 본 서드파티 라이브러리는 무엇이 있으며, 왜 해당 라이브러리를 사용하셨나요? 각 라이브러리별로 트레이드오프는 무엇이라고 생각하나요?

A) Coil을 주로 사용해 보았습니다. Kotlin과 Compose에 최적화되어 있고, Coroutines와 잘 통합되어 있어 비동기 이미지 로딩이 간편했습니다. Glide는 오래전부터 존재해오던 라이브러리지만, Compose 지원이 아직 베타 상태라 안정성이 떨어질 수 있습니다. Landscapist는 다양한 컴포넌트를 지원하는 점이 매력적이지만, 추가적인 의존성이 필요하다는 단점이 있습니다.

### Q32. UI 버벅거림(jank)을 피하면서 리스트에 수백개의 항목을 효율적으로 렌더링하려면 어떻게 해야 하나요?

Jetpack Compose는 UI 버벅거림을 피하고 효율성을 개선하기 위해 필요에 따라 아이템을 동적으로 구성하고 재활용하는 LazyColumn, LazyRow, LazyGrid와 같은 Lazy List라는 최적화된 리스트 컴포넌트를 제공

#### 수직 나열을 위한 LazyColumn

LazyColumn은 현재 화면에 보이는 아이템만 렌더링하고 화면 밖 항목을 재활용하여 대규모 아이템을 효율적으로 렌더링 하도록 설계

```kotlin
@Composable
fun ItemList() {
    LazyColumn {
        // 1000개의 아이템 정의
        items(1000) { index ->
            Text(text = "Item #$index", modifier = Modifier.padding(8.dp))
        }
    }
}
```

#### 수평 나열을 위한 LazyRow

수평 스크롤 리스트의 경우 LazyRow 사용

```kotlin
@Composable
fun HorizontalItemList() {
    LazyRow {
        // 1000개의 아이템 정의
        items(1000) { index ->
            Text(text = "Item #$index", modifier = Modifier.padding(8.dp))
        }
    }
}
```

#### 그리드 레이아웃을 위한 LazyVerticalGrid

그리드 구조가 필요한 레이아웃의 경우 LazyVerticalGrid를 사용

```kotlin
@Composable
fun GridItemList() {
    LazyVerticalGrid(
        columns = GridCells.Fixed(3), // 고정된 3개의 열
        modifier = Modifier.fillMaxSize()
    ) {
        items(300) { index ->
            Text(text = "Item $index")
        }
    }
}
```

수직이 아닌 수평 형태의 그리드 레이아웃을 구현하려면 LazyHorizontalGrid 사용

#### 키(Keys)를 사용한 성능 최적화

- 아이템의 상태는 리스트 또는 그리드에서의 위치와 연결
- 아이템이 삽입, 제거 또는 재정렬되는 등 데이터 세트가 변경되면 위치가 이동하기 때문에 아이템이 상태를 잃을 수 있음
- 각 아이템마다 상태를 보존하려면 아이템에 고유한 키(key) 값을 할당하여 위치가 수정되어도 상태가 유지되도록 함

```kotlin
@Composable
fun KeyedItemList(
    items: List<Item>
) {
    LazyColumn {
        items(
            items = items,
            key = { item -> item.id } // 각 아이템에 고유한 키 제공
        ) { item ->
            Text(
                text = item.name,
                modifier = Modifier.padding(8.dp)
            )
        }
    }
}

// 예시 Item 데이터 클래스
data class Item(
    val id: String,
    val name: String
)
```

- 중복된 id 값이 있을 경우 exception이 발생하기 때문에, items.distinctBy { it.id }와 같이 중복을 제거하고 Lazy List로 넘겨줄 수 있음

#### 실전 질문

Q) 실시간으로 메시지를 처리해야 하는 채팅 화면을 개발한다고 가정해봅시다. 데이터 레이어 쪽에서는 Flow를 통해서 지속적으로 새로운 채팅 메시지가 들어고ㅗ 있고, UI에서는 이를 즉시 렌더링 해야 합니다. 스크롤을 부드럽게 유지하고 최소한의 recomposition으로 성능이 최적화된 화면을 개발하기 위해 레이아웃을 어떻게 설계하실 건가요?

A) LazyColumn을 사용하여 채팅 메시지를 렌더링하고, 각 메시지에 고유한 키를 할당하여 상태를 유지하도록 합니다. Flow에서 새로운 메시지가 도착할 때마다 리스트를 업데이트하되, 스크롤 위치를 감지하여 사용자가 스크롤 중일 때는 자동으로 스크롤하지 않도록 처리합니다. 또한, 메시지 항목 컴포저블을 최적화하여 불필요한 recomposition을 방지합니다.

Q) LazyColumn 또는 LazyGrid에서 키를 사용하는 것이 리스트 아이템 업데이트 시 UI 성능과 안정성을 유지하는 데 어떤 도움이 되나요?

A) 키를 사용하면 각 아이템의 상태가 위치에 의존하지 않고 고유한 식별자에 연결되므로, 아이템이 삽입, 삭제 또는 재정렬될 때도 상태가 유지됩니다. 이는 불필요한 recomposition을 방지하고, UI가 예기치 않게 변경되는 것을 방지하여 성능과 안정성을 향상시킵니다.

### Q33. Lazy List를 활용하여 페이지네이션(pagination)을 구현하는 방법을 설명해 주세요.

#### 스크롤 위치 감지하기

LazyListState를 사용하여 마지막으로 보이는 아이템에 도달하는 시점을 감지한 다음 추가 데이터를 로드

```kotlin
@Composable
fun PaginatedList(
    viewModel: ListViewModel
) {
    val listState = rememberLazyListState()

    // ViewModel 상태 수집
    val items by viewModel.items.collectAsStateWithLifecycle()
    val isLoading by viewModel.isLoading.collectAsStateWithLifecycle()

    // 마지막에서 n개 전에 로드 트리거
    val threshold = 2

    // 로드 필요 여부 계산 (불필요한 recomposition 방지)
    val shouldLoadMore by remember {
        derivedStateOf {
            val layoutInfo = listState.layoutInfo
            val totalItemsCount = layoutInfo.totalItemsCount

            val lastVisibleItemIndex =
                layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: -1

            lastVisibleItemIndex != -1 &&
                lastVisibleItemIndex + threshold >= totalItemsCount &&
                !isLoading
        }
    }

    // 방법 1: 상태 변화 기반
    LaunchedEffect(shouldLoadMore) {
        if (shouldLoadMore) {
            viewModel.loadMoreItems()
        }
    }

    /*
    // 방법 2: snapshotFlow 기반 (더 세밀한 제어)
    LaunchedEffect(listState) {
        snapshotFlow { shouldLoadMore }
            .distinctUntilChanged()
            .filter { it }
            .collect {
                viewModel.loadMoreItems()
            }
    }
    */

    LazyColumn(
        state = listState,
        modifier = Modifier.fillMaxSize()
    ) {
        items(items) { item ->
            Text(
                text = item.toString(),
                modifier = Modifier.padding(8.dp)
            )
        }

        // 로딩 중 하단 프로그레스
        item {
            if (isLoading) {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
        }
    }
}
```

derivedStateOf 또는 snapshotFlow를 사용하여 마지막으로 보이는 아이템의 인덱스를 추적하고 threshold 등을 사용하여 로딩이 필요한 시점을 계산하고 관찰

#### 페이지네이션 관리를 위한 ViewModel

```kotlin
class ListViewModel : ViewModel() {

    // 내부에서만 변경 가능한 아이템 목록
    private val _items = MutableStateFlow<List<Int>>(emptyList())
    val items: StateFlow<List<Int>> = _items.asStateFlow()

    // 로딩 상태
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private var currentPage = 0 // 현재 페이지 번호
    private val pageSize = 20

    // 다음 페이지 로드
    fun loadMoreItems() {
        // 이미 로딩 중이면 중복 요청 방지
        if (_isLoading.value) return

        _isLoading.value = true

        viewModelScope.launch {
            try {
                // 네트워크 요청 시뮬레이션
                delay(1_000)

                val newItems = List(pageSize) {
                    currentPage * pageSize + it
                }

                _items.value = _items.value + newItems
                currentPage++
            } finally {
                _isLoading.value = false
            }
        }
    }

    init {
        // 초기 데이터 로드
        loadMoreItems()
    }
}
```

#### 실전 질문

Q) 페이지네이션에서 당므 데이터를 로드하는 시점을 감지하기 위해 어떤 API 또는 상태 메커니즘을 사용하실 건가요?

A) LazyListState를 사용하여 마지막으로 보이는 아이템의 인덱스를 추적하고, derivedStateOf 또는 snapshotFlow를 활용하여 로딩이 필요한 시점을 감지합니다. 이를 통해 사용자가 리스트를 스크롤할 때 추가 데이터를 효율적으로 로드할 수 있습니다.

Q) 페이지네이션에서 LazyListState는 어떤 역할을 하며, derivedStateOf 및 snapshotFlow는 데이터 로딩 로직 최적화에 어떻게 도움이 되나요? snapshotFlow를 사용할 때 distinctUntilChanged()를 함께 사용하면 어떤 이점이 있나요?

A) LazyListState는 현재 스크롤 위치와 보이는 아이템 정보를 제공하여 페이지네이션 로직에서 중요한 역할을 합니다. derivedStateOf는 계산된 상태를 메모이제이션하여 불필요한 recomposition을 방지하고, snapshotFlow는 상태 변화를 관찰하여 데이터 로딩 로직을 세밀하게 제어할 수 있게 합니다. distinctUntilChanged()를 사용하면 동일한 값이 연속적으로 발생하는 경우 중복된 이벤트 처리를 방지하여 효율성을 높일 수 있습니다.

Q) 사용자가 목록을 빠르게 스크롤하다 보면 페이지네이션 중 중복 네트워크 호출이나 데이터 로딩이 발생할 가능성이 있는데 이를 어떻게 방지할 것인가요?

A) 중복 네트워크 호출을 방지하기 위해 ViewModel에서 로딩 상태를 관리하는 isLoading 플래그를 사용합니다. 데이터 로딩이 진행 중일 때는 추가 로딩 요청을 무시하도록 하여 중복 호출을 방지할 수 있습니다.