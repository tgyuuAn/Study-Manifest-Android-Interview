### 13. remember와 rememberSaveable의 차이점은 무엇인가요?

remember와 rememberSaveable은 모두 recomposition로부터 상태를 유지하도록 하는 API 이지만 서로 다른 목적을 가지고 있음

#### remember 이해하기

- 목적
  - remember API는 메모리에 값을 저장하고 recomposition가 발생했을 경우 메모리에 저장된 값을 꺼내와 상태를 유지
  - 화면 회전이나 프로세스 재시작과 같은 구성 변경 중에는 상태를 유지하지 않음
- 유즈 케이스
  - 상태가 구성 변경 후에도 유지될 필요가 없을 때 remember 사용
  - 화면이 회전되거나 사용자가 언어 설정을 바꿨을 때, 정보가 날아가도 상관없는 상태의 경우 remember가 적합

```kotlin
@Composable
fun RememberExample() {
    var count by remember { mutableStateOf(0) }

    Button(onClick = { count++ }) {
        Text("Clicked $count times")
    }
}
```
- 동작
  - 현재 컴포지션 생명주기 내에서만 상태를 저장하므로 기기가 회전하면 count 변수가 0으로 재설정

#### rememberSaveable 이해하기

- 목적
  - rememberSaveable API는 구성 변경 시에도 상태를 유지
  - 안드로이드 SDK의 Bundle에 저장할 수 있는 값에 한하여 자동으로 저장하고 복원
- 유즈 케이스
  - 유저 인풋 입력이나 네비게이션 상태와 같이 구성 변경 후에도 유지되어야 하는 상태의 경우 사용
```kotlin
@Composable
fun RememberSaveableExample() {
    var text by rememberSaveable { mutableStateOf("") }
    
    OutlinedTextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Enter text") }
    )
}
```
- 행동
  - text 값은 화면 회전이나 구성 변경 시에도 유지되어 원활한 사용자 경험을 보장
- rememberSaveable은 내부적으로 remember 보다 훨씬 다양한 내부 처리 및 오버헤드가 발생

#### 실전 질문

Q) remember이 아닌 rememberSaveable를 사용해야 하는 시나리오는 무엇이며, 어떤 트레이드오프를 고려해야 하나요?

A) 구성 변경 시에도 상태를 유지해야 하는 경우 rememberSaveable를 사용해야 함. 그러나 rememberSaveable는 내부적으로 더 많은 오버헤드가 발생하므로, 상태가 구성 변경 후에도 유지될 필요가 없는 경우에는 remember를 사용하는 것이 성능 측면에서 유리함.

Q) 기본적으로 지원되지 않는 커스텀 비원시(non-primitive) 값을 rememberSaveable로 저장하려면 어떻게 해야 하나요?

A) 커스텀 비원시 값을 rememberSaveable로 저장하려면, 해당 타입에 대해 Parcelable 인터페이스를 구현하거나, Saver를 정의하여 저장 및 복원 로직을 제공해야 함. Saver는 객체를 직렬화 가능한 형태로 변환하고 다시 복원하는 방법을 정의할 수 있음.

#### Pro Tips for Mastery: remember 및 rememberSaveable 내부 구조

##### remember 내부 구조 이해하기

```kotlin
@Composable
inline fun <T> remember(crossinline calculation: @DisallowComposableCalls () -> T): T =
    currentComposer.cache(false, calculation)
```

```kotlin
@ComposeCompilerApi
inline fun <T> Composer.cache(
    invalid: Boolean,
    block: @DisallowComposableCalls () -> T
): T {
    @Suppress("UNCHECKED_CAST")
    return rememberValue().let {
        if (invalid || it === Composer.Empty) { // 값이 유효하지 않거나 초기화되지 않았는지
            val result = block()    // 계산 (remember 매개변수인 calculation) 블록 실행
            updateRememberedValue(result)   // 컴포지션 데이터에 값 저장
            result
        } else {
            it  // 이전에 기억된 값 반환
        }
    } as T
}
```

- remember는 Compose 컴파일러 플러그인 API와 상호 작용하여 컴포지션 데이터에 값을 캐시
- 초기화되지 않았다면 제공된 블록 람다 함수를 사용하여 값을 계산하고 컴포지션 데이터에 저장한 다음 반환
- 그렇지 않다면 이전에 저장된 값을 단순히 복원하여 반환

##### rememberSaveable 내부 구조 이해하기

```kotlin
@Composable
fun <T: Any> rememberSaveable(
    vararg inputs: Any?,    // 상태 재계산을 트리거하기 위한 입력 키
    saver: Saver<T, out Any> = autoSaver(), // 상태 저장 및 복원 로직
    key: String? = null, // 상태 저장을 위한 고유 키
    init: () -> T // 초기값 계산 람다
): T {
    // 현재 컴포지션 해시로부터 기본 키 생성
    val compositionKey = currentCompositeKeyHash
    // 사용자가 제공한 키 또는 생성된 키 사용
    val finalKey = if (!key.isNullOrEmpty()) {
        key
    } else {
        compositionKey.toString(MaxSupportedRadix)
    }
    
    @Suppress("UNCHECKED_CAST")
    (saver as Saver<T, Any>)    // Saver 타입 캐스팅
    
    // 현재 SaveableStateRegistry 가져오기
    val registry = LocalSaveableStateRegistry.current
    
    // 상태를 관리할 Holder 생성 및 기억
    val holder = remember(saver, registry, finalKey) { // 키 변경 시 재실행
        // 레지스트리에서 복원 시도 또는 init으로 초기화
        val restored = registry?.consumeRestored(finalKey)?.let {
            saver.restore(it)
        }
        val finalValue = restored ?: init()
        SaveableStateHolder(saver, registry, finalKey, finalValue, inputs)
    }
    
    // 입력 키가 변경되지 않았다면 저장된 값 사용, 아니면 init 재실행
    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    
    // recomposition 시 상태 업데이트 및 레지스트리에 등록
    SideEffect {
        holder.update(saver, registry, finalKey, value, inputs)
    }
    
    return value
}
```

- rememberSaveable 함수는 구성 변경 및 프로세스 종료 시에도 상태를 저장하고 복원하는 기능을 추가적으로 지원
- LocalSaveableStateRegistry를 사용하여 구성 변경 시에도 상태를 보존함으로써 상태의 복원 범위를 넓힘

1. 키 생성(Key Generation)
   - key 매개변수를 통해 사용자가 커스텀 키를 제공
   - 제공되지 않으면 현재 컴포지션 해시를 사용하여 복합 키가 자동으로 생성
    ```kotlin
    val compositionKey = currentCompositeKeyHash
    val finalKey = if (!key.isNullOrEmpty()) {
        key
    } else {
        compositionKey.toString(MaxSupportedRadix)
    }
    ```
2. 상태 복원(Store Restoration)
   - LocalSaveableStateRegistry는 주어진 키에 대해 이전에 저장된 값을 검색하는 데 사용
   - 저장된 값이 존재하면 제공된 Saver를 사용하여 복원
    ```kotlin
    val registry = LocalSaveableStateRegistry.current
    val restored = registry?.consumeRestored(finalKey)?.let {
        saver.restore(it)
    }
    ```
3. 기본값 초기화(Default Value Initialization)
   - 복원된 값이 없으면 init 람다를 사용하여 기본값이 초기화
   ```kotlin
   val finalValue = restored ?: init()
   ```
4. SaveableHolder
   - 상태, saver, 레즈스트리 및 입려을 관리하기 위해 SaveableHolder 생성
   ```kotlin
   SaveableHolder(saver, registry, finalKey, finalValue, inputs)
   ```
5. 입력 변경 처리(Input Change Handling)
   - rememberSaveable에 대한 입력이 변경되면 상태가 무효화되고 값이 다시 초기화
   ```kotlin
   val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
   ```
6. 사이드 이펙트(Side Effects)
   - SideEffect는 recomposition 중에 업데이트된 상태가 레지스트리에 저장되도록 보장
   ```kotlin
   SideEffect { 
       holder.update(saver, registry, finalKey, value, inputs)
   }
   ```

### 14. 컴포저블 함수 내에서 안전하게 코루틴 스코프(coroutine scope)를 생성하는 방법은 무엇인가요?

#### rememberCoroutineScope를 사용하는 이유

- 컴포저블이 컴포지션을 벗어날 때 활성 중인 코루틴 스코프를 자동 취소
- 개발자가 수동적으로 생명주기를 관리할 필요 없이 컴포저블에서 코루틴을 안전하게 런칭 및 취

```kotlin
@Composable
fun CounterWithReset() {
    var count by rememer { mutableStateOf(0) }
    // 컴포지션에 연결된 코루틴 스코프 가져오기
    val coroutineScope = rememberCoroutineScope()
    
    Column(
        modifier = Modifier.padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Count: $count", style = MaterialTheme.typography.h5)
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = { count++ }) {
            Text("Increment")
        }
        Spacer(modifier = Modifier.height(8.dp))
        Button(onClick = {
            // 버튼 클릭 시 코루틴 시작
            coroutineScope.launch {
                // 리셋을 위한 지연 시뮬에이션
                delay(1000)
                // 지연 후 상태 업데이트
                count = 0
            }
        }) {
            Text("Reset After 1s")
        }
    }
}
```

#### 작동 방식

1. 컴포지션 인식(Composition Awareness)
    - rememberCoroutineScope는 현재 컴포지션으로 범위가 지정
    - 해당 스코프 내에서 시작된 모든 코루틴 작업은 컴포저블이 컴포지션에서 제거될 때 취소
2. 상태 관리(State Management)
    - 상황에 따라 remember와 함께 적절하게 사용하면 비동기 작업을 안전하게 관리하는 데 도움이 됨
3. 메모리 누수 방지(Avoids Memory Leaks)
    - GloalScope를 사용하거나 코루틴 스코프를 수동으로 관리하는 대신, rememberCoroutineScope를 사용하면 컴포저블의 생명주기에 맞춰 코루틴이 자동으로 취소되어 메모리 누수를 방지

#### 모범 사례

- 컴포지션 생명주기에 연결된 UI 관련 작업에는 rememberCoroutineScope를 사용
- 컴포지션 범위를 넘어서 장기적으로 실행되어야 하는 작업의 경우 viewModelScope 또는 lifecycleScope와 같은 더 넓은 코루틴 스코프를 사용
- 컴포저블 내에서 직접 코루틴 스코프를 생성하는 경우 수동으로 관리가 필요
- rememberCoroutineScope를 사용하더라도 컴포저블 내에서의 비즈니스 로직과 관련된 로직은 ViewModel 또는 다른 아키텍처 게층으로 위임하는 것이 좋음

#### 실전 질문

Q) 컴포저블 내에서 직접 코루틴 스코프를 생성하고 시작하면 어떤 위험성이 발생할 수 있나요? rememberCoroutineScope를 사용해야 하는 이유가 무엇인가요?

A) 컴포저블 내에서 직접 코루틴 스코프를 생성하면, 컴포저블이 컴포지션에서 제거될 때 해당 코루틴이 계속 실행되어 메모리 누수나 예기치 않은 동작이 발생할 수 있음. rememberCoroutineScope를 사용하면 컴포저블의 생명주기에 맞춰 코루틴이 자동으로 취소되어 이러한 위험을 방지할 수 있음.

#### Pro Tips for Mastery: rememberCoroutineScope 내부 구조

##### rememberCoroutineScope 내부 구현

```kotlin
@Composable
inline fun rememberCoroutineScope(
    crossinline getContext: @DisallowComposableCalls () -> CoroutineContext = { EmptyCoroutineContext }
): CoroutineScope {
    val composer = currentComposer
    // CompositionScopedCoroutineScopeCanceller 인스턴스를 remember로 감싸서 유지
    val wrapper = remember {
        CompositionScopedCoroutineScopeCanceller(
            // 실제 코루틴 스코프 생성
            createCompositionCoroutineScope(getContext(), composer)
        )
    }
    // 저장된 코루틴 스코프 반환
    return wrapper.coroutineScope
}
```

1. CompositionScopedCoroutineScopeCanceller
    ```kotlin
    internal class CompositionScopedCoroutineScopeCanceller(
        val coroutineScope: CoroutineScope
    ) : RememberObserver {  // 컴포지션 생명주기 관찰
        override fun onRemembered() {
            // nothing
        }
        
        override fun onForgotten() {
            // 컴포지션을 벗어날 때 현재 실행 중인 스코프 취소
            coroutineScope.cancel(LeftCompositionCancellationException())
        }
        
        override fun onAbandoned() {
            // 컴포지션이 버려질 때 현재 실행 중인 스코프 취소
            coroutineScope.cancel(LeftCompositionCancellationException())
        }
    }
    ```
    - RememberObserver 구현: 컴포저블의 생명주기를 추적
    - 컴포지션 인식: 컴포저블이 컴포지션에서 제거되면 onForgotten 또는 onAbandoned이 호출되어 코루틴 스코프를 취소
    - 안전한 리소스 정리: 스코프에서 시작된 모든 코루틴이 컴포저블이 컴포지션을 떠날 때 취소되도록 보장
2. createCompositionCoroutineScope
    ```kotlin
    internal fun createCompositionCoroutineScope(
        coroutineContext: CoroutineContext,
        composer: Composer
    ): CoroutineScope {
        return if (coroutineContext[Job] != null) {
            // 이미 Job이 포함된 context를 전달하면 독립된 스코프가 만들어지지 않음.
            // rememberCoroutineScope는 항상 새로운 Job(독립 스코프)을 가져야 하므로 예외 처리.
            CoroutineScope(
                Job().apply {
                    completeExceptionally(
                        IllegalArgumentException(
                            "CoroutineContext supplied to rememberCoroutineScope may not include a parent job"
                        )
                    )
                }
            )
        } else {
            // 새로운 Scope = Composer의 applyCoroutineContext + 새 Job + 외부 coroutineContext
            val applyContext = composer.applyCoroutineContext
            CoroutineScope(
                applyContext +
                    Job(applyContext[Job]) + // Composer의 Job을 parent로 두는 신규 Job
                    coroutineContext
            )
        }
    }
    ```
    - 상위 Job 제한: rememberCoroutineScope가 기존의 상위 Job에 종속되는 것이 아닌 독립적인 스코프를 생성하도록 보장
    - Job 관리: 스코프를 관리하기 위해 새로운 Job이 코루틴 컨텍스트에 추가
    - Composer와의 통합: 함수는 composer.applyCoroutineContext를 새로 생성된 Job과 결합하여 코루틴 스코프를 설정

##### rememberCoroutineScope 내부 자동 방식

1. 스코프 생성
   - createCompositionCoroutineScope를 사용하여 새 코루틴 스코프가 생성되고 CompositionScopedCoroutineScopeCanceller에 전달
2. 컴포지션 생명주기 인지
   - CompositionScopedCoroutineScopeCanceller는 RememberObserver를 구현하여 컴포저블의 생명주기를 추적
   - 컴포저블이 컴포지션에서 제거되면 메모리 누수를 방지하기 위해 스코프가 취소
3. 안정성
   - 컴포저블이 컴포지션을 종료할 때, 해당 스코프 내에서 시작된 모든 코루틴을 자동으로 취소하도록 보장

### 15. 컴포저블 함수 내에서 발생하는 사이드 이펙트를 어떻게 처리하나요?

#### 1. LaunchedEffect: 컴포저블 범위 내에서 suspend 함수 실행하기

- 컴포저블이 컴포지션에 진입할 때 한 번 실행
- 키가 변경되면 자동으로 취소하고 다시 시작
- 컴포지션 생명주기를 인지하여 컴포저블이 컴포지션을 떠날 때 코루틴 작업이 자동으로 취소
- 리스트에서 특정 아이템을 클릭할 때 네트워크에서 아주 가벼운 데이터를 추가적으로 가져와야 하는 경우 애니메이션을 실행해야 하는 경우 LaunchedEffect를 사용하여 처리
```kotlin
var selectedPoster: Poster? by remember { mutableStateOf(null) }

// selectedPoster가 변경될 때마다 LaunchedEffect 실행
LaunchedEffect(key1 = selectedPoster) {
    selectedPoster?.let { poster ->
        // 포스터가 선택되면 네트워크에서 추가 데이터 가져오기 위해 ViewModel에 이벤트 전송
        viewModel.fetchPosterDetails(poster.id)
        
        // Fade 애니메이션 실행
        ... // suspend 함수 실행
    }
}
```
- LaunchedEffect를 사용하여 flow를 안전하게 관찰할 수 있음
- Unit 또는 true와 같은 상수 값을 키 매개변수로 전달하면 컴포저블이 컴포지션에 진입할 때 한 번만 실행
```kotlin
LaunchedEffect(key = Unit) { // 키가 변경되지 않으므로 한 번만 실행됨
    stateFlow
        .distinctUntilChanged() // 중복 값 필터링
        .filter { it.marked }   // 특정 조건 필터링
        .collect { value -> // Flow 구독
            // Flow에서 보내는 값 수신 후 처리
        }
} 
```

#### 2. DisposableEffect: 메모리 해지 등이 필요한 사이드 이펙트에 적합

- 리스너, 관찰자 또는 구독과 같은 리소스 관리에 이상적
- onDispose 콜백으로 적절한 해지 및 리소스 정리 보장
- 생명주기 이벤트를 기반을 애널리틱스 관련 이벤트를 보내야 하는 경우 DisposableEffect를 사용하여 LifecycleObserver를 등록하고 컴포저블이 컴포지션을 떠날 때 등록 해제할 수 있음
```kotlin
@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -> Unit,   // 'started' 분석 이벤트
    onStop: () -> Unit     // 'stopped' 분석 이벤트
) {
    // 최신 람다 참조 유지 (recomposition 시 자동 업데이트)
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    // lifecycleOwner가 바뀌면 effect 재설정 (observer 재등록)
    DisposableEffect(lifecycleOwner) {
        // 생명주기 이벤트 관찰자
        val observer = LifecycleEventObserver { _, event ->
            when (event) {
                Lifecycle.Event.ON_START -> currentOnStart()
                Lifecycle.Event.ON_STOP -> currentOnStop()
                else -> Unit
            }
        }

        // 관찰자 등록
        lifecycleOwner.lifecycle.addObserver(observer)

        // 컴포지션에서 제거되면 관찰자 해제
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
}
```

#### 3. SideEffect: Compose의 상태를 non-Compose 코드로 실행하기

- 매 recomposition 후 실행 보장
- non-Compose 컴포넌트와의 상태 동기화에 유용
- 예를 들어, 애널리틱스 라이브러리를 사용하여 커스텀 메타데이터를 포함하여 사용자 세그먼트를 세분화하는 기능을 개발하려는 경우 SideEffect를 사용하여 현재 사용자의 데이터가 원활하게 애널리틱스 서버로 전달되도록 할 수 있음
```kotlin
@Composable
fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
    val analytics: FirebaseAnalytics = remember {
        FirebaseAnalytics.getInsance(LocalContext.current)  // Context 필요
    }
    
    // 컴포지션 이후 현재 User의 userType으로 FirebaseAnalytics 업데이트
    // 향후 분석 이벤트에 해당 메타데이터가 함께 전달되도록 보장
    SideEffect {
        analytics.setUserProperty("userType", user.userType)
    }
    return analytics
}
```
- recomposition이 완료된 후에만 Lottie 애니메이션을 시작하거나 non-Composable 작업을 트리거해야 하는 경우에도 사용
```kotlin
// LottieAnimationView 인스턴스가 있다고 가정
val lottieAnimationView = rememberLottieAnimationView()

SideEffect {
    // 최신 recomposition 트리거 후에만 애니메이션 재생
    lottieAnimationView.playAnimation()
}
```

#### 실전 질문

Q) LaunchedEffect는 컴포저블에서 suspend 함수를 관리하는 데 어떤 도움이 되며, 키 매개변수 값이 변경되면 어떤 동작이 발생하나요?

A) LaunchedEffect는 컴포저블이 컴포지션에 진입할 때 suspend 함수를 실행할 수 있도록 하며, 키 매개변수 값이 변경되면 이전에 실행 중인 코루틴이 자동으로 취소되고 새로운 코루틴이 시작됨으로써 상태 변화에 대응할 수 있도록 돕습니다.

Q) LaunchedEffect 대신 DisposableEffect를 사용해야 하는 경우는 언제인가요?

A) DisposableEffect는 리스너, 관찰자 또는 구독과 같은 리소스 관리에 적합하며, 컴포저블이 컴포지션을 떠날 때 적절한 해지 및 리소스 정리를 보장해야 할 때 사용해야 합니다. 반면 LaunchedEffect는 suspend 함수를 실행하는 데 더 적합합니다.

Q) SideEffect의 사용 사례를 설명하고 LaunchedEffect와 어떻게 다른지 설명해 주세요.

A) SideEffect는 매 recomposition 후에 non-Compose 코드와 상태를 동기화하는 데 사용됩니다. 예를 들어, 애널리틱스 라이브러리에 사용자 속성을 설정하는 경우에 적합합니다. LaunchedEffect는 suspend 함수를 실행하는 데 사용되며, 키가 변경될 때 코루틴을 재시작하는 반면, SideEffect는 단순히 recomposition 후에 실행됩니다.

### 16. rememberUpdatedState는 왜 사용하고 어떻게 작동하나요?

- 최초 컴포지션을 통해서 생성되었더라도 람다나 콜백의 상태 값에 대해 항상 최신 상태를 유지하도록 보장

#### 동작 구조

- 상태의 가장 최근 값을 기억하고 상태가 변경될 때마다 업데이트하고, 컴포저블 또는 람다 내에서 값을 읽고 가장 최신의 상태를 반영하는 State<T> 객체를 반환
- 함수의 시그니처는 다음과 같음

```kotlin
@Composable
fun <T> rememberUpdateState(newValue: T): State<T>
```

#### 사용 사례

1. 콜백이 사이드 이펙트 내부로 전달될 때
    - 사이드 이펙트 내에서 람다나 콜백이 최초 컴포지션을 통해 생성되었지만, 지속적으로 새로 업데이트된 람다 및 콜백을 실행해야 할 때 유용
2. 애니메이션 또는 사이드 이펙트 API
    - 지속되는 LaunchedEffect, DisposableEffect 또는 애니메이션과 함께 사용할 때 유용

```kotlin
@Composable
fun TimerWithCallback(
    onTimeout: () -> Unit,          // 타임아웃 시 호출할 콜백
    timeoutMillis: Long = 5000L     // 타임아웃 시간 (ms)
) {
    // 최신 onTimeout 람다 참조를 저장하여, 재구성 동안 값이 바뀌어도 반영되도록 함
    val currentOnTimeout by rememberUpdatedState(onTimeout)

    // TimerWithCallback의 생명주기 동안 한 번만 실행되는 효과
    // key = true → recompose가 일어나도 delay는 다시 시작되지 않음
    LaunchedEffect(true) {
        delay(timeoutMillis)

        // delay 도중 onTimeout이 바뀌더라도 항상 최신 콜백을 호출
        currentOnTimeout()
    }

    Text(text = "Timer running for $timeoutMillis ms…")
}
```

#### 주요 이점

- 오래된 상태 방지(Avoids Stale State)
  - 장기적인 작업을 수행하는 사이드 이펙트 내에서 상태에 대한 오래된 참조한 인한 문제를 방지
- 안전한 컴포지션 처리(Safe Composition Handling)
  - LaunchedEffect 또는 DisposableEffect와 같은 컴포지션의 생명주기를 인식하는 API와 원활하게 작동
- 간단한 통합(Simple Integration)
  - 람다 상태가 항상 최신 값을 반영하려면 단순히 rememberUpdatedState로 감싸주기만 하면 됨

#### 실전 질문

Q) LaunchedEffect를 사용하여 어느 정도의 딜레이 이후 람다 함수를 트리거하는 경우 최신 상태를 반영하는 람다가 호출되도록 어떻게 보장할 수 있나요?

A) LaunchedEffect 내에서 람다 함수를 호출할 때 rememberUpdatedState를 사용하여 최신 상태를 반영하는 람다 참조를 유지할 수 있습니다. 딜레이 도중 람다 함수가 바뀌더라도 최신 람다 함수를 호출하도록 보장합니다.

#### Pro Tips for Mastery: rememberUpdatedState 내부 구조

```kotlin
@Composable
fun <T> rememberUpdatedState(newValue: T): State<T> = 
    // remember를 사용하여 State 객체를 생성하고 기억
    remember { mutableStateOf(newValue) }
    // 매 recomposition마다 최신 newValue로 State의 값을 업데이트
        .apply { value = newValue }
```
- rememberUpdatedState를 사용하는 컴포저블 함수가 recompose 될 때마다 함수가 호출되고 이전에 기억된 상태가 새 newValue 매개변수로 업데이트

### 17. produceState의 목적은 무엇이며 어떻게 작동하나요?

- 컴포저블이 관찰할 수 있는 State 객체를 생성하고, 상태 값을 업데이트하기 위해 생산자(producer) 코루틴을 실행하며, 컴포저블이 컴포지션을 떠날 때 코루틴 스코프를 자동으로 취소

#### 구문 (Syntax)

produceState 함수의 시그니처는 다음과 같음
```kotlin
@Composable
fun <T> produceState(
    initalValue: T,   // 상태의 초기 값
    vararg keys: Any?, // 코루틴 재시자을 위한 키 값
    producer: suspend ProduceStateScope<T>.() -> Unit // 상태 값을 생산하는 suspend 함수
): State<T> // 관찰 가능한 State 객체 반환
```
- initialValue
  - 생산자가 코루틴을 실행하고 상태를 업데이트를 시작하기 전 초기값
- keys
  - 키 값 중 하나라도 변경되면 기존에 돌아가던 생산자 코루틴은 취소되고 다시 시작
- producer
  - 코루틴 동작을 수행하고 상태를 업데이트하는 suspend 함수
  - ProduceStateScope 내에서 실행

#### 사용 예제

```kotlin
@Composable
fun UserProfile(userId: String, viewModel: UserViewModel) {
    // userId가 변경되면 produceState 재실행
    val userState: State<User?> by produceState<User?>(initialValue = null, key1 = userId) {
        // 생산자 람다: 비동기 작업 수행 및 상태 업데이트
        value = viewModel.fetchUserFromNetwork(userId) // 간단한 네트워크 요청 실행
    }
    
    // 로딩 상태 또는 사용자 정보 표시
    if (userState == null) {
        Text("Loading...")
    } else {
        Text("User: ${userState?.name}")
    }
}

// 예시 ViewModel 함수
class UserViewModel : ViewModel() { 
    suspend fun fetchUserFromNetwork(userId: String): User {
        // 네트워크 요청 시뮬레이션
        delay(2000) // 2초 지연
        return User(userId, "User Name for $userId") // 가짜 사용자 데이터 반환
    }
}
```
1. produceState는 초기값인 null인 State<User?> 객체를 생성
2. userId가 키로 사용되어 userId가 변경되면 코루틴이 재시작
3. 비동기 로직은 생산자 코루틴은 사용자 데이터를 비동기적으로 가져와 Compose의 상태로 만들고 해당 상태 값인 value를 업데이트
4. value가 변경되면 UserProfile 컴포저블이 recompose되어 업데이트된 데이터를 반영

#### produceState의 이점

- 선언적(Declarative)
  - 비동기 작업을 실행하고 그 결과를 Compose 상태로 만들기 위해 Compose의 선언적 방식을 그대로 사용
- 컴포지션 생명주기 인지(Composition-aware)
  - 컴포저블이 컴포지션을 떠날 때 코루틴을 자동으로 취소하여 리소스 누수 위험을 방지
- 유연성(Flexible)
  - 외부 suspend 함수와도 잘 작동하고 의존성(키)이 변경될 때 코루틴 작업을 다시 시작

#### 모범 사례

- 생산자 코루틴이 필요할 때만 다시 시작되도록 의미 있는 keys 값을 사용해야 함
- withContext를 사용하여 명시적으로 코루틴 디스패처를 변경하지 않으면 기본적으로 메인 스레드에서 실행
- 메인 스레드를 차단하지 않으려면 무겁거나 장기저인 코루틴 작업을 실행하지 않거나, withContext를 통해 명시적으로 디스패처를 변경해야 함

#### 실전 질문

Q) 컴포저블 함수에서 코루틴 작업을 시작하고 그 결과를 상태로 관찰해야 하는 시나리오에서 LaunchedEffect나 rememberCoroutineScope를 사용하지 않고 구현하는 방법에 대해 설명해 주세요.

A) produceState를 사용하여 컴포저블 내부에서 안전하게 코루틴을 시작하고 그 결과를 상태로 관찰할 수 있습니다. LaunchedEffect의 key로 사용할 값을 ProduceState의 keys 매개변수로 전달하여, 해당 값이 변경될 때 코루틴이 재시작되도록 할 수 있습니다.

#### Pro Tips for Mastery: produceState 내부 구조

```kotlin
@Composable
fun <T> produceState(
    initialValue: T,
    key1: Any?,                                      // 키: 변경되면 생산자 코루틴 재시작
    producer: suspend ProduceStateScope<T>.() -> Unit
): State<T> {

    // 1) remember로 mutable State 생성 → State<T>로 반환될 실제 저장소
    val result = remember { mutableStateOf(initialValue) }

    // 2) key1 변화에 반응하여 코루틴을 "자동으로 취소·재시작" 하는 효과
    LaunchedEffect(key1) {
        // ProduceStateScopeImpl은 MutableState를 위임받기 때문에
        // producer 내부에서 this.value = ... 형태로 값 업데이트 가능
        ProduceStateScopeImpl(
            state = result,
            coroutineContext = coroutineContext
        ).producer()
    }

    // 3) State<T> 그대로 반환 → 컴포저블에서 value로 자동 관찰됨
    return result
}

// ProduceStateScope<T> 구현체
private class ProduceStateScopeImpl<T>(
    state: MutableState<T>,                          // State<T>의 실제 저장소
    override val coroutineContext: CoroutineContext  // 생산 코루틴의 컨텍스트
) : ProduceStateScope<T>, MutableState<T> by state { // MutableState 위임

    // 코루틴 취소 시 정리(clean-up) 작업을 실행하는 구문
    override suspend fun awaitDispose(onDispose: () -> Unit): Nothing {
        try {
            // 코루틴이 취소될 때까지 중단
            suspendCancellableCoroutine<Nothing> { }
        } finally {
            // 취소된 시점에 정리 작업 실행
            onDispose()
        }

        // awaitDispose는 정상적으로 돌아오는 일이 없어야 함
        throw RuntimeException("awaitDispose returned unexpectedly")
    }
}
```

- produceState는 내부적으로 remember와 mutableStateOf를 사용하여 상태를 생성
- 또한 LaunchedEffect를 활용하여 producer를 새 코루틴 스코프에서 안전하게 시작

### 18. snapshotFlow를 사용해 본 경험이 있을까요? 사용 시 주의사항은 무엇인가요?

snapshotFlow는 Compose의 상태를 Flow로 변환하는 함수

#### snapshotFlow의 주요 특징

- 상태 관찰(State observation)
  - Snapshot 시스템을 사용하여 Compose의 상태 변화를 관찰
- 스레드 안전성(Thread Safety)
  - 상태 읽기 및 쓰기가 Compose의 스냅샷 스코프 내에서 발생하도록 보장하여 경쟁 조건을 방지
- 유휴 건너뛰기(Idle Skipping)
  - 상태 값이 변경될 때만 Flow 값으로의 방출이 발생하고 recomposition이 발생하지 않는 중에는 업데이트를 건너뛰도록 보장
- 취소 인지(Cancellation-Aware)
  - Flow를 수집하는 코루틴이 취소될 때 구독 또한 자동으로 취소하여 부족절한 메모리 누수 방지

#### 유스 케이스

- 코루틴과의 인터페이스(Interfacing with Coroutines)
  - 변환, 플로우 결합 또는 필터링과 같은 추가적인 Flow의 연산 작업이 필요한 경우 Compose의 상태를 Coroutine Flow로 변경
- 비 UI 사이드 이펙트(Non-UI Side Effects)
  - 애널리틱스 이벤트 전송이나 백엔드 호출이 필요한 경우와 같이 UI에 직접적으로 관련이 없는 사이드 이펙트 작업을 수행하기에 적합

#### snapshotFlow 사용법

```kotlin
@Composable
fun SnapshotFlowExample(viewModel: MyViewModel) {
    val count by viewModel.count.collectAsState()
    
    LaunchedEffect(Unit) {
        snapshotFlow { count }
            .collect { value ->
                // 최신 값으로 사이드 이펙트 작업 수행
                // 예: 로그 기록, 분석 이벤트 전송 등 무겁지 않은 동작
                println("Count value changed to: $value")
            }
    }
    
    Text(text = "Count: $count")
}
```

- 사용자가 리스트를 스크롤하여 필요할 때마다 페이지네이션에 필요한 데이터를 불러와야할 때 snapshotFlow를 사용할 수 있음

```kotlin
val listState = rememberLazyListState()
val threshold = 2

LazyColumn(state = listState) {
    // ... 아이템 목록 ...
}

// 현재 ViewModel이 이미 추가 목록을 불러오고 있는지에 대한 상태 관찰
val isLoadingShorts by shortsViewModel.isLoadingShorts.collectAsStateWithLifecycle()
// Pagination을 구현하기 위해 추가 목록을 불러 와야하는지 말아야 하는지 판단
val shouldLoadMore by remember {
    derivedStateOf {
        val totalItemsCount = listState.layoutInfo.totalItemsCount
        val lastVisibleItemIndex = listState.firstVisibleItemIndex + listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0
        (lastVisibleItemIndex + threshold >= totalItemsCount) && !isLoadingShorts
    }
}

// listState가 변경될 때마다 LaunchedEffect 재실행
LaunchedEffect(listState) {
    snapshotFlow { shouldLoadMore } // 첫 번째 보이는 아이템 인덱스 관찰
        .map { index -> index > 0 } // 첫 번째 아이템을 지나 스크롤했는지 여부로 변환
        .distinctUntilChanged() // 값이 실제로 변경될 때만 방출
        .filter { it }  // shouldLoadMore가 true일 때만 진행
        .collect {
            // pagination 구현을 위해 추가 항목을 불러오는 이벤트 전송
            shortsViewModel.handleShortsEvent(event = ShortsEvent.LoadMore)
        }
}
```
- 해당 예제는 snapshotFlow를 사용하여 리스트의 스크롤 상태 변화를 관찰하고, 특정 조건이 충족될 때만 추가 데이터를 불러오는 로직을 구현

#### snapshotFlow 내부 작동 방식

1. 람다 매개변수로 제공된 Compose의 상태를 Snapshot 관찰자 내에서 지속적으로 관찰
2. 람다 매개변수에 상태 변수가 들어오는 순간 Compose는 해당 상태에 대해서 종속성을 등록
3. 상태가 변경되면 Compose는 snapshotFlow에 업데이트 상황을 알리고 새 값을 방출하도록 트리거

#### 명심해야 할 사항

- 스레드 안전성 및 수집(Thread Safety and Collection)
  - 수집된 플로우가 일반적으로 LaunchedEffect를 사용하는 코루틴 스코프 내에서 처리되도록 하여 컴포지션 외부에서 수집하는 것을 방지하고 메모리 누수를 방지
- 방출 빈도(Emission Frequency)
  - snapshotFlow는 람다 내에서 읽은 스냅샷 상태가 변경될 때마다 값을 방출하며 이는 생각보다 자주 발생
  - distinctUntilChanged() 또는 debounce()와 같은 연산자를 사용하여 불필요한 방출을 줄이고 성능을 최적화
- 스냅샷 격리(Snapshot Isolation)
  - Flow는 Compose의 스냅샷 시스템에 최대한 동기화되어 동작
  - 스냅샷 생명주기 내에서 예상되는 동작을 보장하기 위해 다른 Flow 또는 suspend 함수와 결합될 때는 주의해야 함

#### 실전 질문

Q) snapshotFlow를 사용하는 것이 선호되는 시나리오는 무엇이며, 이는 Compose의 스냅샷 시스템과 어떠한 연관이 있나요? 또한, Flow에서 값을 방출하는 동작을 어떻게 최적화하시겠습니까?

A) Compose 내부 상태 변화를 Flow 기반 비즈니스 로직으로 넘기고 싶을 때, 예를 들어 스크롤 위치, 선택 상태 등을 Flow로 관찰할 때 snapshotFlow를 사용함. Compose의 스냅샷 시스템과 연관되어 상태 변경을 감지하고 Flow로 방출함. 값을 방출하는 동작을 최적화하기 위해 distinctUntilChanged()와 같은 연산자를 사용하여 불필요한 방출을 줄일 수 있음.

### 19. derivedStateOf가 필요한 시나리오는 무엇이고, recomposition 최적화에 어떻게 도움이 되나요?

- 종속 상태 중 하나가 변경될 때만 파생된 값이 다시 계산되도록 보장
- 빈번한 상태 업데이트가 있는 시나리오에서 성능을 개선하고 불필요한 recomposition을 방지하는 데 유용

#### derivedStateOf 사용 시기

- 파생 데이터(Derived Data)
  - 필터링된 목록이나 결합된 텍스트와 같이 기존 상태 값에서 연산이 필요할 때 유용
- Recomposition 방지(Avoiding Recomposition)
  - 파생된 값이 자주 변경되는 상태에 의존하지만 파생된 값이 변경될 때만 recomposition이 발생하도록 해야 할 때 적합

#### derivedStateOf 사용 방법

```kotlin
@Composable
fun DerivedStateExample(items: List<String>, searchQuery: String) {
    // searchQuery 또는 items가 변경될 때만 filteredItems 재계산
    val filteredItems by remember(searchQuery, items) {
        derivedStateOf {
            items.filter { it.contains(searchQuery, ignoreCase = true) }
        }
    }
    
    Column {
        Text("Search results:")
        filteredItems.forEach { item ->
            Text(item)
        }
    }
}
```

- filteredItems는 items 및 searchQuery를 통해 파생된 상태
- derivedStateOf는 searchQuery 또는 items가 변경될 때만 목록이 다시 계산되도록 보장

#### derivedStateOf 작동 방식

1. derivedStateOf의 람다 매개변수 내에서 사용된 모든 상태들의 변화를 관찰
2. 관찰된 상태 중 하나가 변경되면 새 값을 계산
3. 새로 계산된 값이 이전 값과 다른 경우에만 recompostion을 트리거

#### 명심해야 할 주요 사항

- 파생된 상태가 recomposition으로부터 값을 유지하도록 하면 항상 remember와 함께 derivedStateOf를 사용
- 원활한 성능을 보장하기 위해 derivedStateOf 내에서 복잡한 계산을 피하고, 필요한 경우에만 상태를 재계산

#### 고급 예제: 실시간으로 파생 상태 계산하기

```kotlin
@Composable
fun RealTimeDerivedStateExample() {
    var text by remember { mutableStateOf("") }
    // text 상태로부터 입력 유효성을 계산
    val isInputValid by remember {
        derivedStateOf { text.length >= 5 }
    }
    
    Column {
        TextField(value = text, onValueChange = { text = it })
        // isInputValid가 변경될 때만 recomposition 발생
        if (isInputValid) {
            Text("Valid input")
        } else {
            Text("Input must be at least 5 characters")
        }
    }
}
```

- 입력 유효성(isInputValid)은 text 상태에 파생된 상태
- recomposition은 텍스트가 변경될 때마다 트리거되는 것이 아닌, isInputValid가 변경될 때만 발생

#### 잘못된 사용법

- 상태를 파생하기 때문에 항상 derivedStateOf를 사용해야 한다고 가정하는 것은 옳지 않음

```kotlin
var firstName by remember { mutableStateOf("") }
var lastName by remember { mutableStateOf("") }

// 아래 코드는 오버헤드만 추가할 뿐 성능적인 개선이 없음
val fullNameBad by remember { derivedStateOf { "$firstName $lastName" } }
```

- 단순한 문자열 합치기 수준의 작업을 derivedStateOf로 감싸는 것은 불필요한 오버헤드를 초래
- 파생된 값을 이루는 상태들이 자주 업데이트되고, 상태가 변경될 때 다시 계산하여 명확한 성능적인 이점이 있는 경우에만 derivedStateOf를 사용

#### 실전 질문

Q) 어떤 시나리오에서 derivedStateOf를 사용하는 것이 효과적인가요? 혹은 어떤 시나리오에서 derivedStateOf를 사용하지 말아야 하나요?

A) derivedStateOf는 파생된 상태가 자주 변경되는 상태에 의존하지만, 파생된 값이 변경될 때만 recomposition이 발생하도록 해야 할 때 효과적입니다. 예를 들어, 필터링된 목록이나 결합된 텍스트와 같이 기존 상태 값에서 연산이 필요할 때 유용합니다. 반면, 단순한 상태 조합이나 계산이 필요한 경우에는 derivedStateOf를 사용하지 않는 것이 좋습니다. 예를 들어, 단순한 문자열 합치기 수준의 작업을 derivedStateOf로 감싸는 것은 불필요한 오버헤드를 초래할 수 있습니다.