### 6. 안정성(stabilities) 개선을 통해 Compose 성능을 최적화한 경험이 있나요?

#### Immutable Collections

- List 또는 Map과 같은 읽기 전용 컬렉션은 구현 과정에서 참조값이 아닌 내부 아이템 변경 발생 가능
- 따라서, Compose 컴파일러에 의해 unstable 처리

```kotlin
internal var mutableUserList: MutableList<User> = mutableListOf()
public val userList: List<User> = mutableUserList
```

- 가령 위 코드의 기본 구현체인 mutableUserList의 아이템 항목은 언제든지 변경 가능
- 따라서, Compose 컴파일러는 recompoistion의 정확성을 보장하기 위해 해당 인스턴스를 unstable로 처리
- 안정성을 보장하기 위해 stable한 `kotlinx.collections.immutable` 또는 `Guava의 immutable 컬렉션` 사용 가능
- ImmutableList가 stable로 처리되는 이유는 Compose 컴파일러 내에서 해당 패키지를 stable로 처리하도록 하드코딩 되어있기 때문

#### Lambda Stability

- Compose 컴파일러는 람다 함수를 매개변수로 받는 경우 반드시 stable로 처리
- 내부적으로 람다가 람다식 스코프의 외부 변수를 참조하는지 여부에 따라 다르게 처리
    - 값을 캡처하지 않는 람다(Non-Capturing Lambdas)
      ```kotlin
      modifier.clickable {
        Log.d("Log", "This lambda doesn't capture any values")
      }
      ```
      - 외부 변수에 의존하지 않는 람다는 싱글톤으로 최적화되어 stable로 간주
      - recomposition을 트리거하지 않음
    - 값을 캡처하는 람다(Capturing Lambdas)
      ```kotlin
      var sum = 0
      ints.filter { it > 0 }.forEach {
        sum += it // 외부 변수 'sum'을 캡처
      }
      ```
      - 외부 변수에 의존하는 람다는 동적으로 변경 사항에 응답하기 위해 remember를 사용하여 메모이제이션
      - 외부 변수가 remember API의 key 매개변수로 전달되고, 동일한 key에 대해 동일한 return 값이 나오기에 stable로 간주

#### 래퍼 클래스 (Wrapper Classes)

- 제어할 수 없는 불안정한 클래스(e.g., 서브파티 라이브러리에서 제공하는 클래스)의 경우 안정성 어노테이션으로 마크하여 래퍼 클래스를 만들 수 있음

```kotlin
@Immutable
data class ImmutableUserList(
    val user: List<User>
)
```

- List는 여전히 unstable이지만, ImmutableUserList는 immutable로 간주되므로 ImmutableUserList 클래스 자체는 stable하게 간주

```kotlin
@Compose
fun UserAvatars(
    modifier: Modifier,
    userList: ImmutableUserList, // 안정적인 Wrapper 타입 사용
)
```

#### 안정성 구성 파일 (Stability Configuration File)

- Compose 컴파일러 1.5.5에 업데이트된 `안정성 구성 파일` 사용 시 stable로 간주하고 싶은 클래스를 개발자로 임의로 지정 가능
- stable로 처리할 클래스의 패키지 명을 나열하는 compose_compiler_config.conf 파일을 만듦
- Compose 컴파일러가 해당 파일에 정의된 패키지 목록에 대해 recomposition을 건너뛸 수 있도록 build.gradle.kts에서 추가적으로 설정이 필요
- 해당 기능은 특히 서드파티 클래스나 커스텀 타입을 stable하게 만드는데 유용. 이를 활성화하며 래퍼 클래스 없이 전역적으로 특정 클래스를 stable로 지정 가능

#### Strong Skipping Mode

- Strong Skipping Mode는 불안정한 매개변수를 포함하더라도, restartable로 분류된 컴포저블 함수에 대해 recomposition 생략을 활성화
- stable 매개변수가 있는 컴포저블 함수는 객체 동등성(equals) 을 사용하여 값을 비교하는 반면, unstable 매개변수는 인스턴스 동등성(===) 을 사용하여 비교됨
- 해당 기능이 활성화되면 모든 컴포저블 함수에 대해 적용되기 때문에, 특정 함수를 제외하려면 @NonSkippableComposable 사용

#### 실전 질문

Q) List를 매개변수로 받는 컴포저블 함수에서 불필요하게 발생하는 recomposition을 어떻게 최적화하시겠습니까?

A) ImmutableCollections를 사용하거나, @Immutable 어노테이션이 붙는 ImmutableListWrapper를 만들어서 List를 감싸서 사용할 것입니다. 이렇게 할 경우 내부 List는 여전히 unstable이지만, ImmutableListWrapper는 Immutable로 간주되므로 stable한 걸로 인식됩니다.

Q) 앱에서 recomposition 효율성을 개선하기 위해 시도해 본 전략 혹은 Compose 컴파일러 기능 중에 어떤 게 있나요?

A) @Immutable 또는 @Stable 어노테이션을 붙여서 stable하게 취급하거나 안정성 구성 파일을 통해 서드파티 클래스나 커스텀 타입을 stable하게 만들어서 사용한 적이 있습니다.

### 7. 컴포지션(composition)이란 무엇이며 어떻게 생성하나요?

- 컴포지션(composition)은 compose 컴파일러가 해석한 UI에 대한 정보를 실질적인 UI로 구체화하는 단계
- UI를 컴포저블의 트리 구조로 구성하며, Composer를 활용하여 트리를 동적으로 생성하고 관리
- 컴포지션은 상태를 기록하고 UI를 효율적으로 업데이트하기 위해 노드 트리에 필요한 변경 사항을 적용하며, 변경사항을 적용하고 UI를 업데이트하는 과정이 recomposition

#### 컴포지션 생성하기

- 컴포지션은 컴포저블 함수를 화면에 렌더링할 수 있게 UI 계층 구조로 변환하는 프로세스
- 컴포지션을 생성하고 관리하는 방법은 다음과 같음

#### ComponentActivity.setContent() 함수

- ComponentActivity 또는 ComposeView에서 제공하는 setContent 함수 사용
- 컴포지션을 초기화하고 그 안에 표시될 컨텐츠를 정의

```kotlin
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.runtime.Composable

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent { // Activity의 content를 Compose UI로 설정
            MyComposableContent()
        }
    }
}

@Composable
fun MyComposableContent() {
    // Compose UI 컴포넌트로 레이아웃 구현
}
```

- setContent는 컴포저블 함수를 렌더링하고 컴포지션을 시작하는 역할을 하며, Compose UI의 진입점이 됨

```kotlin
public fun ComponentActivity.setContent(
    parent: CompositionContext? = null,
    content: @Composable () -> Unit
) {
    // 이미 윈도우에 연결된 ComposeView 찾기
    val existingComposeView = window.decorView
        .findViewById<ViewGroup>(android.R.id.content)
        .getChildAt(0) as? ComposeView

    if (existingComposeView != null) {
        // 기존 View 재사용
        with(existingComposeView) {
            setParentCompositionContext(parent)
            setContent(content)
        }
    } else {
        // 새 ComposeView 생성 및 설정
        ComposeView(this).apply {
            setParentCompositionContext(parent)
            setContent(content)
            // ViewTree 관련 Owner 설정
            setOwners()
            // Activity의 ContentView로 설정
            setContentView(this, DefaultActivityContentLayoutParams)
        }
    }
}
```

- 내부적으로 ComposeView에 의존하며 ComposeView.setContent를 호출하여 컴포지션을 초기화하고 생성

```kotlin
val existingComposeView = window.decorView.findViewById<ViewGroup>(android.R.id.content).getChildAt(0) as? ComposeView
```

- 함수는 먼저 Activity의 뷰 계층 구조에서 기존 ComposeView를 검색하고, 없으면 새 인스턴스를 생성

```kotlin
if (exisingComposeView != null) {
    with(existingComposeView) {
        setParentCompositionContext(parent)
        setContent(content)
    }
}
```

- 기존 ComposeView가 발견되면 새 부모 CompositionContext와 새 컴포저블 콘텐츠로 업데이트

```kotlin
// 새 ComposeView 생성 및 설정
ComposeView(this).apply {
    setParentCompositionContext(parent)
    setContent(content)
    // ViewTree 관련 Owner 설정
    setOwners()
    // Activity의 ContentView로 설정
    setContentView(this, DefaultActivityContentLayoutParams)
}
```

- Compose UI는 본진적으로 전통적으로 View 시스템, ComposeView 내에서 렌더링
- 결국 기존의 View 시스템 위에서 동작하는 것을 기반으로 함

#### XML 레이아웃에 Compose 포함시키기

- XML에 정의된 레이아웃 내에서도 컴포지션을 생성할 수 있으며, setContent API가 내부적으로 작동하는 원리와 유사하게 작동

```kotlin
import androidx.compose.ui.platform.ComposeView

// XML이 아닌 Kotlin 코드로 직접 ComposeView 생성 및 설정
val composeView = ComposeView(context).apply {
    setContent {
        MyComposableContent()
    }
}
// 기존 ViewGroup에 추가
// viewGroup.addView(composeView)
```

- ComposeView를 기존 ViewGroup에 추가하거나 <androidx.compose.ui.platform.ComposeView> 태그를 사용해 XML 레이아웃 내에서 직접 사용할 수도 있음

#### 실전 질문

Q) ComposeView는 전통적인 View와 Compose UI 시스템을 어떻게 연결하며, 언제 사용되나요? 그리고, ComposeView와 컴포지션의 관계는 어떻게 되나요?

A) ComposeView는 전통적인 Android View 시스템과 Jetpack Compose UI 시스템을 연결하는 브릿지이다. 기존 View 트리 내부에 Compose UI를 포함시키거나, 반대로 Compose UI 안에 기존 View를 포함할 때 사용한다.<br>
ComponentActivity.setContent() 역시 내부적으로 ComposeView를 생성하고 setContent()를 호출하여 컴포지션을 시작한다. 이 과정에서 ComposeView는 Compose 런타임의 루트 역할을 하며, Compose 트리와 View 트리를 연결해준다.

### 8. XML 기반 프로젝트를 Jetpack Compose로 마이그레이션하는 전략에 대해서 설명해 주세요.

#### 점진적 마이그레이션 (Incremental Migration)

- 기존 XML 레이아웃에 Compose 콘텐츠를 포함하기 위해 ComposeView를 사용

```xml
<androidx.compose.ui.platform.ComposeView
    android:id="@+id/compose_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
```

```kotlin
findViewById<ComposeView>(R.id.compose_view).setContent {
    Greeting("Hello Compose!")
}
```

- 반대로, 컴포저블 함수 내에 XML 기반 뷰를 포함시키려면 AndroidView를 사용
- ExoPlayer나 YouTubePlayerView와 같이 아직 Jetpack Compose UI를 공식적으로 지원하지 않는 컴포넌트를 사용할 때 유용

```kotlin
@Composable
fun LegacyViewComposable() {
    AndroidView(factory = { context ->
        LayoutInflater.from(context).inflate(R.layout.legacy_view, null)
    })
}
```

#### 화면별 마이그레이션 (Screen-by-Screen Migration)

1. Compose로 마이그레이션하기 쉽거나, 마이그레이션 하면 즉각적인 이점이 생길만한 화면 선별
2. 해당 화면의 레이아웃 구조를 Compose를 사용하는 형태로 완전히 다시 설계
3. Compose의 상태 기반 아키텍처를 활용하여 XML 레이아웃을 컴포저블 함수로 교체

#### 점진적 컴포넌트 마이그레이션 (Grandual Component Migration)

- 텍스트, 버튼 또는 커스텀 컴포넌트와 같은 개별적인 재사용 가능한 컴포넌트, 또는 전체 디자인 시스템부터 마이그레이션하는 전략
1. 자주 사용되는 View 기반의 UI 컴포넌트 또는 디자인 시스템의 일부를 선별
2. 선별한 컴포넌트를 컴포저블 함수로 다시 만듦
3. 해당 컴포넌트를 사용 중인 XML 레이아웃에서 기존 컴포넌트를 새 컴포저블 컴포넌트로 교체

#### 전체 재작성 (Full Rewrite)

- 광범위한 레거시 코드가 있거나 오래된 UI 라이브러리에 복잡한 의존관계를 가지고 있는 경우, 프로젝트 전체를 Jetpack Compose로 새로 작성
1. Compose에서 테마, 레이아웃 및 커스텀 컴포넌트, 혹은 디자인 시스템 전체를 다시 개발
2. 전체 UI 스택에 Compose를 활용하여 XML로 구현했던 앱과 동작 형태를 똑같이 가져감
3. Compose 활용에 최적화된 MVI 또는 MVVM과 같은 최신 디자인 패턴을 채택하여 앱 전체 아키텍처를 재정의 해볼 수도 있음

#### 라이브러리에 대한 상호 운용성 활용 (Leverage Interoperability for Libraries)

- 아직 Compose를 채택하지 않은 라이브러리를 사용하는 경우 상호 운용성을 신경써야 함
- ComposeView 또는 AndroidView를 사용하여 Compose UI를 지원하지 않는 UI 라이브러리 또는 컴포저블 함수에 원활하게 통합

#### 마이그레이션 중 테스트 및 모니터링 (Test and Monitor During Migration)

- 마이그레이션 중에는 앱이 예상대로 작동하는지 확인하기 위해 테스트가 필수적
- Compose의 테스트 라이브러리를 활용하여 다시 작성한 컴포저블 함수의 동작을 검증
- 성능 프로파일링을 수행하여 Compose를 기존 XML 구현과 비교하여 최소한 성능적인 면에서 동등하거나 향상된 사용자 경험을 보장하는 것이 중요

#### 실전 질문

Q) XML에서 Compose로 마이그레이션 할 때 기존 View 기반 레이아웃 내에서 부분적으로 컴포저블 함수로 마이그레이션하는 전략에 대해서 설명해 주시고, 이러한 접근 방식이 가장 유용한 시나리오는 무엇인가요?

A) ComposeView를 사용하여 자주 사용되는 View의 컴포넌트를 컴포저블 함수로 다시 만든 뒤, XML 레이아웃 내에서 기존 컴포넌트를 새 컴포저블 컴포넌트로 교체할 수 있다.

Q) 안드로이드 앱을 화면별로 Jetpack Compose로 마이그레이션 하는 것과 컴포넌트별로 마이그레이션 하는 것의 각 장단점을 경험에 기반하여 말씀해 주세요.

A) 화면별로 하는 경우에는 화면 전체를 Compose 스타일로 일관된 상태 관리나 아키텍처를 사용할 수 있지만, 초기 공수와 리스크가 크고 부분 재사용이 어려웠습니다. 반면에 컴포넌트 단위 마이그레이션의 경우 비교적 적은 리스크로 점진적 전환이 가능하지만, View/Compose 혼용을 위한 상태 관리 코드가 늘어나는 단점이 있었습니다.

#### Pro Tips for Mastery: XML과 Jetpack Compose를 동시에 사용하면 앱 (APK/AAB) 사이즈에 영향을 미치나요?

- 마이그레이션 중 XML과 Jetpack Compose를 같이 사용하면 앱 크기에 영향을 미칠 수 있지만, 그 효과는 비교적 미미함
- R8 최적화를 사용하는 경우 Compose UI 라이브러리를 여럿 추가하는 걸로는 약 2MB 정도밖에 늘어나지 않음

### 9. Compose 성능 테스트를 항상 릴리스 모드(release mode)에서 해야 하는 이유는 무엇인가요?

- 디버그 모드는 UI 코드에 대한 불필요한 해석, JIT 컴파일, Live Edit Literals와 같은 개발자 도구와 관련된 것들이 추가 오버헤드를 유발
- 따라서 일반적으로 Jetpack Compose로 개발된 앱은 디버그 앱이 릴리스 앱보다 월등히 느린 경우가 많음

#### 디버그 모드가 Compose에 미치는 옇야

- Compose는 라이브러리 형태로 제공되므로, 디버그 앱을 실행할 때 런타임에 의하여 해석되고 컴파일
- 따라서 디버그 모드에 Compose와 관련한 추가적인 해석 및 JIT 컴파일 오버헤드를 발생

> 안드로이드 팀에 의하면, 전통적인 View와 관련한 코드들은 안드로이드 프레임워크에 이미 통합되어 있기 때문에 빠르게 컴파일되고, 최적화된 형태로 돌아갑니다. 반면 Compose 라이브러리는 Lazy List에서 관리하는 작은 단위의 컴포넌트 뿐만 아니라, 전체 UI 스택을 debuggable한 형태로 실행하기 때문에 디버그 모드에서의 추가적인 오버헤드가 발생합니다.

#### Live Edit Literals 및 개발자 도구

- 디버그 빌드는 런타임 업데이트를 지원하기 위해 상수를 getter 함수로 지원하는 Live Edit Literals와 같은 개발자 기능을 활성화
- 추가적인 산술 비용을 유발하고, 디버그 모드에서 recomposition 및 렌더링을 더 느리게 함

#### 릴리스 모드에서의 R8 최적화

- R8은 람다 그룹화, 소스 정보 생략, 상수 폴딩, 인터페이스 호출을 더 빠른 정적 호출로 변환하는 등 최적화를 통해 릴리스 빌드의 성능을 크게 향상
- 기본적으로 R8 최적화를 활성화 하는 것 만으로도 앱 시작 성능이 약 75%, 프레임 렌더링 성능이 약 60% 향상
- R8이 제공해주는 최적화 중 일부는 다음과 같음:
  - 람다 그룹화: 유사한 람다 구현을 그룹화하여 람다 표현식을 최적화하고 오버헤드를 줄임
  - 소스 정보 생략: 디버그 및 소스 메타데이터를 제거하여 APK 크기를 최소화
  - 상수 폴딩: 컴파일 시 상수 표현식을 단순화하여 런타임 효율성을 햣아
  - 인터페이스 호출을 정적 호출로 변환: 동적 인터페이스 호출을 더 빠른 정적 메소드 호출로 대체하여 실행 속도를 크게 향상

#### Baseline Profiles가 중요한 이유

- Baseline Profiles는 중요한 Compose 메소드를 사전에 컴파일하여 앱 시작 중 런타임 해석 및 JIT 컴파일을 피함
- 보통 디버그 빌드는 Baseline Profiles를 반영하지 않음

#### 실제 테스트 권장 상황

- 성능을 정확하게 평가하려면 항상 R8 및 Baseline Profiles가 활성화된 릴리스 모드에서 Compose 앱을 테스트해야 함
- 앱 시작 및 런타임 성능을 측정하기 위해 Macrobenchmark와 같은 도구를 활용해 보는 것도 좋음

#### 실전 질문

Q) R8은 Jetpack Compose 성능 최적화에서 어떤 역할을 하며, 릴리스 빌드에서 어떤 사항을 개선하는지 구체적으로 설명해 주세요.

A) R8은 코드 압축, 난독화, 최적화를 수행한다. Compose는 런타임 시점에 Recomposer, SlotTable, Lambda Capture, State Object 등을 기반으로 동작하기 때문에 릴리스 빌드에서 R8 최적화가 많은 영향을 준다.
<br>remember, LaunchedEffect, SideEffect 등 내부에서 사용되는 람다, 클로저 객체 중 재사용되지 않는 인스턴스나 인라인 가능한 부분은 R8이 인라인 및 제거한다.
<br>Modifier, remember, CompositionLocal 등의 유틸 함수를 인라인 처리하거나, 불필요한 상수 연산을 Constant Folding을 통해 제거한다.
<br>일부 내부 API(rememberSaveable, Saver) 등에서 사용하는 리플렉션 힌트를 분석하여 불필요한 리플렉션 경로를 제거하고, 실제 참조되는 클래스만 남긴다.
<br>Compose는 컴파일 시점에 컴포저블 함수에 숨겨진 파라미터(예: \$composer, \$changed, \$default)를 추가하지만, R8은 unused synthetic parameter 및 metadata를 제거하여 DEX 사이즈를 줄인다.

### 10. Jetpack Compose에서 자주 사용하시는 Kotlin 관용구(idioms)에 대해서 말씀해 주세요

#### 기본 매개변수 (Default Arguments)

- Kotlin은 매개변수에 기본값을 지정하여 여러 함수에 대해 오버로드의 필요성을 줄임
- 예를 들어, Text 컴포저블은 선택적으로 요구되는 매개변수에 대해 기본값을 제공하여, 최소한의 매개변수만 사용하여 함수를 호출할 수 있도록 허용하면서도 풍부한 커스텀을 지원

```kotlin
Text("Hello, Android!")
// 위의 코드는 아래와 동일하게 작동함
Text(
    text = "Hello, Android!",
    color = Color.Unspecified,
    fontSize = TextUnit.Unspecified,
    // ... 기타 기본 매개변수
)
```

#### 고차 함수 및 람다 표현식 (Higher-Order Functions and Lambda Expressions)

```kotlin
Button(onClick = { showToast("Clicked!") }) { // 람다를 onCLick 콜백으로 전달
    Text("Click Me")
}
```

- 별도의 함수를 정의하는 대신 람다 표현식을 사용하면 동작을 인라인으로 정의하여 코드를 더 가독성 있게 하고, 유지 관리하기 쉽게 만들 수 있음

#### 후행 람다 (Trailing Lambdas)

- Kotlin은 람다 표현식을 함수의 마지막 매개변수로 전달하면 람다의 실행체를 함수 바깥으로 뺄 수 있도록 허용하여 코드를 더 간결하게 만듦

```kotlin
Column { // 마지막 람다를 괄호 박으로 이동  
    Text("Item 1")
    Text("Item 2")
}
```

#### 스코프 및 수신 객체 (Scopes and Receivers)

- Compose API는 종종 스코프가 포함된 람다 함수를 제공하여 특정 컨텍스트 내에서만 특정 Modifier나 프로퍼티에 접근할 수 있도록 함
- 코드 구성을 개선하고 의도된 컨텍스트 외부에서 함수를 오용하는 것을 방지

```kotlin
Row { // RowScope가 암시적으로 제공됨
    Text(
        text = "Hello",
        // RowScope 내에서만 사용 가능한 align 확장 함수
        modifier = Modifier.align(Alignment.CenterVertically)
    )
}
```

#### 위임 속성 (Delegated Properties)

- Compose는 상태를 효율적으로 관리하기 위해 위임 속성(by 구문)을 사용
- 밑의 코드는 MutableState<Int>의 value 프로퍼티(get/set)을 count라는 변수의 getter/setter에 위임(delegate)하는 예시

```kotlin
// 'by' 키웓르르 사용하여 State 객체 에서 값을 직접 위임받음
var count by remember { mutableStateOf(0) }
```

#### 데이터 클래스 구조 분해 (Destructing Data Classes)

- Kotlin의 구조 분해 기능은 특히 ConstriantLayout과 같이 제약 조건 기반의 레이아웃을 작업할 때 유용

```kotlin
// ConstraintLayout의 createRefs() 예시
val (image, title, subtitle) = createRefs()
```

#### 싱글톤 객체 (Singleton Objects)

- Kotlin의 object 선언은 MaterialTheme과 같은 테마 시스템에서 사용되는 싱글톤 생성을 단순화

```kotlin
val primaryColor = MaterialTheme.colorScheme.primary // MaterialTheme은 object
```

#### 타입-세이프 빌더 및 DSL (Type-Safe Builders and DSLs)

- Jetpack Compose는 선언적 UI 구조를 만들기 위해 Kotlin의 DLS 기능을 활용
- LazyColumn은 계층적 UI 컴포넌트를 읽기 쉬운 방식으로 정의하기 위해 타입-세이프 빌더를 활용

```kotlin
LazyColumn {
    item { Text("Header") } // 단일 아이템 정의
    items(listOf("Item 1", "Item 2")) { item -> // 목록 아이템 정의
        Text(item)
    }
}
```

#### Kotlin 코루틴

- Compose는 내부적으로 비동기 작업을 처리하기 위한 방법으로 코루틴을 많이 활용
- rememberCoroutineScope 함수는 recomposition이 발생해도 진행하고 있는 작업을 유지하는 코루틴 스코프를 제공

```kotlin
val scope = rememberCoroutineScope() // 컴포지션에 연결된 코루틴 스코프
val scrollState = rememberScrollState() // 스크롤 상태

Button(onClick = {
    scope.launch { // 코루틴 시작
        scrollState.animateScrollTo(0) // 스크롤 애니메이션
    }
}) {
    Text("Scroll to Top")
}
```

#### 실전 질문

Q) 컴포저블 함수를 구조화하기 위해 후행 람다나 고차 함수를 자주 사용하는데 이러한 Kotlin 관용구가 Compose API에서 사용되는 예시를 들어주세요.

A) Compose에서 제공하는 Button 컴포넌트를 예시로 들 수 있다. 마지막 매개변수인 content를 바깥 블록에 선언할 수 있다.
```kotlin
Button(
    onClick = { println("Clicked") }
) {
    Text("Click Me")
}
```

### 11. 상태(State)란 무엇이며 이를 관리하는 데 사용되는 API는 무엇인가요?

- Jetpack Compose에서 State는 앱 시나리오에서 흔히 변경될 수 있는 값이자, UI에서 동적으로 반영되는 데이터

#### State와 Composition

- 초기 Composition
  - 컴포저블을 실행하여 UI 트리가 처음 생성되고 렌더링되는 프로세스
- Recomposition
  - 상태 변경 시 트리거되며, recomposition은 관련 컴포저블을 업데이트하여 새로운 상태를 반영
- Compose Runtime은 상태 변경 사항을 자동으로 추적하고 View 시스템의 View.invalidate() 메소드와 유사한 동작을 개발자 대신하여 UI를 업데이트
- Recomposition은 업데이트된 상태를 반영해야 하는 컴포저블 함수에 대해서만 트리거

```kotlin
@Composable
fun HelloContent() {
    Column(modifier = Modifier.paddign(16.dp)) {
        // remember와 mutableStateOf를 사용하여 상태 정의
        var name by remember { mutableStateOf("") }
        
        // name 상태가 비어 있지 않을 때만 Text 표시
        if (name.isNotEmpty()) {
            Text(
                text = "Hello, $name!",
                modifier = Modifier.padding(bottom = 8.dp)
            )
        }
        
        // TextField는 name 상태를 표시하고 업데이트
        TextField(
            value = name, // 현재 상태 값
            onValueChange = { name = it }, // 상태 업데이트 콜백
            label = { Text("Name") }
        )
    }
}
```

- 위의 코드에서 name이 변경되면 Text 및 TextField가 자동으로 업데이트

#### Compose에서 상태 관리하기

1. remember
   - 초기 컴포지션이 발생했을 때 메모리에 객체를 저장하고 recomposition이 발생하면 기존 메모리에 저장된 값을 꺼내옴
2. rememberSaveable
   - recomposition 뿐만 아니라, 화면 회전과 같은 구성 변경 시에도 상태를 유지. Bundle에 저장할 수 있는 유형 또는 그 외 유형에 대해서는 saver 객체와 함께 작동
3. mutableStateOf
   - 상태 값이 변경될 때 recomposition을 트리거하는 관찰 가능한 상태 객체를 생성

```kotlin
// (1) State<String> 타입
val mutableState: MutableState<String> = remember { mutableStateOf("") }

// (2) String 타입 (delegate 속성 사용)
var value: String by remember { mutableStateOf("") }

// (3) 구조 분해 선언 (value: String, setValue: (String) -> Unit)
val (value, setValue) = remember { mutableStateOf("") }
```

#### remember와 mutableStateOf를 함께 사용하는 이유

- remember API는 객체를 메모리에 저장
- mutableStateOf는 상태값이 변할 때 recomposition을 트리거하기 위한 관찰 가능한 객체를 생성
- 두 함수를 함께 사용하면 상태가 메모리에 유지되면서, 변경 시 UI가 자동으로 다시 그려지는 구조를 만들 수 있음
- mutableStateOf만 사용 시 문제점
  - 상태 값이 변경될 때마다 recomposition을 트리거하는데, recomposition 이후에는 초기값으로 리셋되어 의도한 상태가 유지되지 않음

#### 실전 질문

Q) 상태는 recomposition과 어떤 관련이 있으며, recomposition이 발생하면 내부적으로 어떤 일이 발생하나요?

A) 상태가 변경되면 자동으로 recomposition이 트리거되면 내부적으로
1. Compose의 Snapshot 시스템이 변화를 감지하여
2. 해당 상태를 읽고 있던 컴포저블 함수를 추적하고 그 함수 범위만 부분적으로 다시 실행한다.
3. 이전 Composition과 새 Composition을 비교하여 변경된 UI 노드만 실제 ViewTree/SlotTable에 반영한다.
4. 변경되지 않은 부분은 SlotTable에 저장된 정보를 활용해 재사용하여 불필요한 리컴포지션을 방지한다.

### 12. 상태 호이스팅(state hoisting)으로 어떤 이점을 얻을 수 있나요?

- 상태 호이스팅은 상태를 상위 수준의 컴포저블 함수로 끌어올리는 것을 의미
- 따라서, 상태 값과 상태 값을 업데이트하는 람다 함수를 컴포저블 매개변수로 관리하고
- 해당 값은 현재 컴포저블이 아닌 다른 호출자 쪽에 관리하도록 함
- 상태 호이스팅의 특성은 다음과 같음:
  - State
    - 부모 컴포저블에서 관리
  - Events 또는 triggers
    - 자식에서 값을 바꾸고, 해당 값을 부모로 다시 전달받는 형태로 상태를 업데이트
    - 보편적으로 람다 함수를 매개변수로 넘기고, 해당 컴포저블을 호출하는 쪽에서 업데이트된 값을 콜백으로 받아 상태를 업데이트
  - 업데이트된 상태는 매개변수로 자식에게 다시 전달되어 단방향 데이터 흐름을 생성

```kotlin
@Composable
fun Parent() {
    var sliderValue by remember { mutableStateOf(0f) }
    
    // SliderComponent에 상태와 콜백 전달
    SliderComponent(
        value = sliderValue,
        onValueChange = { sliderValue = it } // 상태를 업데이트하는 람다 함수
    )
}

// SliderComponent는 상태를 직접 관리하지 않음 (Stateless)
// 즉, 단방향 데이터 흐름이 성립됨
@Composable
fun SliderComponent(value: Float, onValueChange: (Float) -> Unit) {
    Slider(value = value, onValueChange = onValueChange)
}
```

- SliderComponent와 같이 내부적으로 어떤 상태를 관리하지 않고 있는 함수를 stateless라고 부름

```kotlin
@Composable
fun SliderComponent() {
    var sliderValue by remember { mutableStateOf(0f) }
    
    Slider(value = sliderValue, onValueChange = { sliderValue = it })
}
```

- 위처럼 내부적으로 상태를 가지는 함수를 stateful이라고 부름
- 다른 화면에서 이를 사용하기 위해 약간의 요구사항 변화가 생겨도 완전히 다른 컴포저블 함수를 만들어야 함

#### 상태 호이스팅의 장점

- 더 나은 재사용성
  - 상태 호이스팅을 적용하면 컴포저블을 무상태 및 재사용 가능하게 만들 수 있음
  - 상태 및 이벤트 콜백을 전달함으로써 동일한 컴포저블을 다른 화면이나 컨텍스트에서 사용 가능
- 단순화된 테스트(Simplified Testing)
  - 매개변수로 전다로딘 상태 값에 전적으로 의존하므로 테스트하기가 더 쉬움
- 더 나은 관심사 분리(Better Separation of Concerns)
  - 상태 관리 로직을 부모 컴포저블 또는 ViewModel로 옮김으로써, UI 컴포넌트가 인터페이스 렌더링에만 집중
- 단방향 데이터 흐름 지원(Support of Unidirectional Data Flow)
  - 항태 호이스팅은 Jetpack Compose의 단방향 데이터 흐름 아키텍처와 일치하여 상태가 SSOT에서 흐르도록 보장
  - 여러 소스가 동일한 상태를 관리하려고 할 때 발생하는 예상치 못한 동작의 발생 가능성을 줄임
- 향상된 상태 관리(Enhanced State Management)
  - 상태 호이스팅을 사용하면 ViewModel 또는 부모 컴포저블과 같은 상위 컨테이너에서 상태를 중앙 집중화
  - 복잡한 UI 흐름을 관리하고 인스턴스 상태 저장 또는 상태 복원 관리와 같은 작업을 더 쉽게 처리할 수 있음

#### 실전 질문

Q) 상태 호이스팅이 왜 컴포저블 함수의 테스트 용이성을 향상시키나요? 예시를 들어서 설명해 주세요.

A) 상태 호이스팅은 상태와 상태를 변경하는 트리거 함수를 외부에서 주입하기 때문에 특정 시나리오에 따라 상태 및 상태 변경 함수를 주입하여 재사용할 수 있다. 또한 밖에서 주입하는 상태 값에 전적으로 의존하기 때문에 테스트도 용이하다.

```kotlin
@Composable
fun LoginForm(
    email: String,
    onEmailChange: (String) -> Unit
) {
    TextField(
        value = email,
        onValueChange = onEmailChange
    )
}
```

```kotlin
@Composable
fun LoginFormPreview() {
    var email by remember { mutableStateOf("test@example.com") }
    LoginForm(email = email, onEmailChange = { email = it })
}
```

Q) 어떤 시나리오에서 상태 호이스팅을 사용하지 않고, 컴포저블 내부에 상태를 갖도록 하실 건가요? 해당 시나리오에서는 컴포저블에 상태를 갖도록 하는 것이 상태 호이스팅을 적용하는 것에 비해 어떤 장점을 갖나요?

A) 외부에서 제어될 필요가 없는 일시적 UI 상태일 경우 상태 호이스팅을 사용하지 않아도 된다고 생각한다.
예를 들어, 패스워드 입력 컴포넌트에서 입력된 내용이 한글자라도 있으면 우측에 삭제 버튼을 노출시키고 싶을 때 이부분은 외부에 제어받을 필요가 없으므로 내부 상태로 만들 수 있다.

```kotlin
@Composable
fun PasswordTextField() {
    var isVisible by remember { mutableStateOf(false) }

    TextField(
        value = "password",
        onValueChange = {},
        trailingIcon = {
            IconButton(onClick = { isVisible = !isVisible }) {
                Icon(
                    painter = painterResource(
                        if (isVisible) R.drawable.ic_visible else R.drawable.ic_hidden
                    ),
                    contentDescription = null
                )
            }
        }
    )
}
```

#### Pro Tips for Mastery: Stateful vs. Stateless, 코드로 상태 호이스팅 이해하기

- 상태 호이스팅은 상태 관리를 호출하는 쪽(call site)으로 이동시켜 상태 저장(stateful) 컴포저블을 상태 비저장(stateless) 컴포저블로 변환하는 데 사용되는 디자인 패턴

![state_hoisting.png](assets/state_hoisting.png)

- 예를 들어, MyTextField 컴포저블은 부모로부터 직접 텍스트 값과 사용자 입력 처리를 위한 콜백을 받아 명확한 데이터 흐름을 보장

```kotlin
@Composable
fun HomeScreen() {
    // MyTextField가 자체적인 상태를 관리하므로 호출자는 편함
    MyTextField()
}

@Composable
fun MyTextField() {
    // remember와 mutableStateOf를 사용하여 내부 상태 관리
    val (value, onValueChanged) = remember { mutableStateOf("") }
    
    // 내부 상태를 TextField에 전달
    TextField(value = value, onValueChange = onValueChanged)
}
```

- 위 코드에서 MyTextField는 내부 상태를 관리함. 이러한 디자인은 자체 상태를 독립적으로 처리하므로 MyTextField을 Stateful 컴포저블로 만듦
- 위와 같이 구현 시 호출부에서 상태를 관리할 필요가 없어 구현이 단순화되지만, 유연성이 감소함

```kotlin
@Composable
fun HomeScreen() {
    // 상태를 HomeScreen에서 관리 (호이스팅 - 끌어 올린다고 이해하면 됩니다)
    val (value, onValueChanged) = remember { mutableStateOf("") }
    
    // MyTextField에 상태와 콜백 전달
    MyTextField(
        value = value,
        onValueChanged = onValueChanged
    )
}

// MyTextField는 상태를 받아서 표시하고 변경 사항을 위임 (Stateless)
@Composable
fun MyTextField(
    value: String,
    onValueChanged: (String) -> Unit // 상태 변경 콜백
) {
    TextField(value = value, onValueChange = onValueChanged)
}
```

- 위 코드에서 MyTextField는 매개변수를 통해 변경 사항을 반영하면서 상태 관리를 호출자 쪽에 위임하는 Stateless 컴포저블로 구현
- 상태 저장(stateful) 구현에 비해 코드가 약간 길어질 수 있지만, MyTextField를 stateless 한 상태로 유지함으로써 다른 상황에서도 보다 쉽게 재사용할 수 있음

```kotlin
@Composable
fun HomeScreen() {
    // 상태를 HomeScreen에서 관리 (호이스팅 - 끌어 올린다고 이해하면 됩니다)
    val (value, onValueChanged) = remember { mutableStateOf("") }
    val processedValue by remember(value) { derivedStateOf { value.filter { !it.isDigit() } } }
    
    // MyTextField에 상태와 콜백 전달
    MyTextField(
        value = processedValue,
        onValueChanged = onValueChanged
    )
}

// MyTextField는 상태를 받아서 표시하고 변경 사항을 위임 (Stateless)
@Composable
fun MyTextField(
    value: String,
    onValueChanged: (String) -> Unit // 상태 변경 콜백
) {
    TextField(value = value, onValueChange = onValueChanged)
}
```

- statelss 컴포저블 사용 시 다음과 같이 숫자 입력을 필터링 하는 시나리오에서도 원본 컴포저블을 수정하지 않고도 쉽게 커스텀이 가능하게 함