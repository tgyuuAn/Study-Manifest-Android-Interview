### 24. 예외(exceptions)를 어떻게 추적하나요?

#### Logcat을 이용한 예외 로깅

- 예외가 발생하면 시스템은 예외 유형, 메시지 및 예외가 발생한 코드 줄을 포함하여 자세한 스택 트레이스를 Logcat에 기록
- E/AndroidRuntime과 같은 키워드를 사용하여 Logcat 로그를 필터링하여 예외에 집중

#### try-catch를 이용한 예외 처리

- try-catch 블록을 사용하면 예외를 제어된 방식으로 처리하고 코드의 중요한 부분에서 앱 크래시를 방지

```kotlin
try {
    val result = performRiskyOperation()
} catch (e: Exception) {
    Log.e("Error", "Exception occurred: ${e.message}", e)
}
```

#### 전역 예외 핸들러 사용하기

- Thread.setDefaultUncaughtExceptionHandler를 사용하면 앱 전체에서 처리되지 않은 예외를 포착하는 데 도움이 됨.

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
        Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
            Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}: ${exception.message}", exception)
            // 예외 세부 저장 또는 서드 파티 솔루션으로 전송 (Crashlytics 등)
            // FirebaseCrashlytics.getInstance().recordException(exception)
            // 기존 핸ㄷ르러 호출 (선택 사항, 시스템 기본 크래시 동작 유지)
            defaultHandler?.uncaughtException(thread, exception)
        }
    }
}
```

- 애플리케이션의 전체 런타임 문제를 디버깅하고 모니터링하는 데 매우 효과적
- 디버그 또는 QA 빌드에서만 전역 예외 핸들러를 구현 가능

#### Firebase Crashlytics 사용하기

- 처리되지 않은 예외를 자동으로 기록하고 스택 트레이스, 기기 상태 및 사용자 정보와 함께 자세한 크래시 보고서 제공
- 중요하지 않은 문제에 대해 커스텀 예외를 기록

```kotlin
try {
    val data = fetchDate()
} catch (e: IOException) {
    FirebaseCrashlytics.getInstance().recordException(e)
}
```

#### 브레이크포인트(Breakpoints)를 이용한 디버깅

- 브레이크포인트를 찍으면 코드 실행을 일시 중지하고 앱 상태를 점진적으로 검사 가능
- 디버그 모드를 활성화하고 브레이크포인트에 도달했을 때 변수, 메소드 호출 및 예외 스택 트레이스를 상세하게 탐색 가능

#### 버그 리포트(Bug Report) 캡처하기

안드로이드에서 버그 리포트를 캡처하면 기기 로그, 스택 트레이스 및 시스템 정보를 수집하여 문제를 진단하고 수정하는 데 도움이 됨.
세 단계로 버그 리포트 생성 가능

1. 개발자 옵션: 개발자 옵션을 활성화하고, 설정 > 개발자 옵션 > 버그 신고로 이동하여 버그 신고 유형을 선택하고 생성된 보고서를 공유
2. Android Emulator에서 버그 신고 캡쳐: 확장 컨트롤을 열고 버그 신고를 선택한 다음 관련 세부 정보와 함께 보고서를 저장
3. ADB (Android Debug Bridge)를 사용하여 버그 신고 캠처: 터미널에서 adb bugreport /path/to/save/bugreport를 실행하거나, adb -s <device_serial_number> bugreport로 특정 기기를 지정

생성된 ZIP 파일에는 디버깅에 필수적인 dumpsys, dumpstate, logcat과 같은 로그가 포함

#### 실전 질문

Q) Logcat를 사용하여 개발 환경에서 예외를 디버깅하는 것돠 Firebase Crashlytics와 같은 도구를 사용하여 프로덕션 환경에서 예외를 처리하는 것의 차이점은 무엇인가요? 또한, Logcat과 같은 로컬 환경에서 추적된 예외랑 프로덕션에서 추적된 예외를 각각 어떻게 해결하시나요?

A) Logcat은 개발 환경에서 실시간으로 예외를 추적하고 디버깅하는 데 유용하며, Firebase Crashlytics는 프로덕션 환경에서 발생하는 예외를 자동으로 기록하고 분석하는 데 사용됩니다. Logcat을 통해 개발자는 즉각적으로 문제를 파악하고 수정할 수 있지만, 프로덕션 환경에서는 Crashlytics와 같은 도구를 통해 사용자에게 영향을 미치지 않도록 예외를 모니터링하고 해결합니다. 로컬 환경에서 추적된 예외는 코드 수정과 테스트를 통해 해결하고, 프로덕션에서 추적된 예외는 사용자 경험을 최소화하기 위해 신속하게 패치를 배포하거나 사용자에게 알림을 보내는 방식으로 해결합니다.

### 25. 빌드 변형(build variants)과 플레이버(flavors)란 무엇인가요?

#### 빌드 변형 (Build Variants)

- 빌드 변형은 특정 빌드 타입(build type)과 제품 플레이버(product flavor)를 결합한 결과
- 안드로이드 Gradle 플러그인은 각 조합에 대해 빌드 변형을 생성하여 다양한 사용사례에 맞는 APK 또는 번들을 생성
- 일반적으로 아래 타입을 포함:
  - 디버그(Debug): 개발 중에 사용되는 빌드 구성으로 종종 디버그 도구, 로그 및 테스트용 디버그 툴을 활용하여 개발자가 개발 향상성을 높이도록 함
  - 릴리즈(Release): 배포에 최적화된 구성으로 종종 리소스 최적화 및 최소화(minification), 난독화(obfuscation)가 적용되어 스토어 게시를 위해 별도의 릴리스 키가 서명되어야 함

#### 제품 플레이버 (Product Flavors)

- 제품 플레이버를 통해 개발자는 무료 및 유료 버전이나 us 및 eu와 같은 지역별 버전과 같이 앱의 다양한 변형을 정의
- 각 플레이버는 애플리케이션 ID, 버전 이름 또는 리소스와 같은 고유한 구성을 가짐

```kotlin
// Kotlin DSL (build.gradle.kts)
android {
    ...
    flavorDimensions += "version"   // 플레이버 차원(dimension) 정의
    
    productFlavors {
        create("free") {
            dimension = "version"
            applicationIdSuffix = ".free"
            versionNameSuffix = "-free"
        }
        
        create("paid") {
            dimension = "version"
            applicationIdSuffix = ".paid"
            versionNameSuffix = "-paid"
        }
    }
}
```

#### 빌드 타입과 플레이버 결합하기

- 빌드 변형 시스템은 빌드 타입과 제품 플레이버를 결합하여 가능한 빌드의 매트릭스를 만듦
- freeDebug, paidRelease...
- 각 조합은 변형 조건에 따른 설정, 리소스를 가지거나 코드를 다르게 동작시킬 수 있음

#### 빌드 변형 및 플레이버 사용의 이점

1. 효율적인 구성: 프로젝트를 통째로 복제할 필요가 없으므로, 중복 코드를 줄이고 단일 코드베이스에서 여러 빌드를 처리할 수 있음
2. 커스텀 동작: 유료 버전에서 프리미엄 기능을 활성화하거나 디버그와 릴리스 빌드에서 각각 다른 API를 사용하는 등 앱 동작을 맞춤 설정할 수 있음
3. 자동화: Gradle은 빌드 변형에 따라 APK 서명, 최적화 및 난독화와 같은 작업을 자동화함

#### 실전 질문

Q) 빌드 타입과 제품 플레이버의 차이점은 무엇이며, 빌드 변형을 생성하기 위해 그 두 가지가 어떤 식으로 함께 작동하나요?

A) 빌드 타입은 디버그와 릴리즈와 같은 빌드의 유형을 정의하며, 제품 플레이버는 무료와 유료 버전과 같은 앱의 변형을 정의합니다. 빌드 변형은 이 두 가지를 결합하여 다양한 조합의 APK를 생성할 수 있게 합니다. 예를 들어, freeDebug와 paidRelease와 같은 조합을 통해 각각의 빌드 타입에 맞는 제품 플레이버를 적용할 수 있습니다.

### 26. 접근성(accessibility)을 어떻게 보장하나요?

- 접근성은 시각, 청각 또는 신체 장애가 있는 사람들을 포함하여 모든 사람이 애플리케이션을 사용할 수 있도록 보장하는 것
- 접근성 기능을 구현하면 사용자 경험이 향상되고 WCAG(Web Content Accessibility Guidelines)와 같은 글로벌 접근성 표준 준수를 보장

#### 콘텐츠 설명(Content Descriptions) 활용하기

- 콘텐츠 설명은 UI 컴포넌트에 텍스트 레이블을 제공하여 TalkBack과 같은 스크린 리더가 시각 장애가 있는 사용제게 해당 컴포넌트를 알릴 수 있도록 함
- 버튼, 이미지, 아이콘과 같이 상호작용하는 컴포넌트에는 android:contentDescription 속성을 사용
- 컴포넌트의 목적이 단순히 장식용이라면 android:contentDescription을 null로 설정하거나 View.IMPORTANT_FOR_ACCESSIBILITY_NO를 사용

```xml
<ImageView
    android:contentDescription="사용자 프로필 사진"
    android:src="@drawable/profile_image" />
```

#### 동적 글꼴 크기 지원하기

- 앱이 기기 설정에서 사용자가 설정한 글꼴 크기 환경 설정을 존중하도록 보장
- 접근성 설정에 따라 자동으로 크기가 조정되도록 텍스트 크기에는 sp 단위를 사용

```xml
<TextView
    android:textSize="16sp"
    android:text="샘플 텍스트" />
```

#### 포커스 관리 및 탐색

- 커스텀 뷰, 다이얼로그 및 양식의 경우 포커스 동작을 적절하게 관리
- 키보드 및 D-패드 사용자를 위한 논리적인 탐색 경로를 정의하려면 android:nextFocusDown, android:nextFocusUp 및 관련 속성을 사용

#### 색상 대비 및 시각적 접근성

- 저시력 또는 색맹 사용자의 가독성을 향상시키기 위해 텍스트와 배경색 간의 충분한 대비를 제공
- Android Studio의 Accessibility Scanner를 사용하여 색상 대비 문제를 식별하고 수정

#### 커스텀 뷰 및 접근성

- 커스텀 뷰를 만들 때 AccessibilityDelegate를 구현하여 스크린 리더가 커스텀 UI 컴포넌트와 상호 작용하는 방식을 정의
- 커스텀 컴포넌트에 의미 있는 설명을 제공하려면 onInitializeAccessibilityNodeInfo 메소드를 오버라이드

```kotlin
class CustomView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) {
    init {
        importForAccessibility = IMPORTANT_FOR_ACCESSIBILITY_YES
        // 클릭 가능하게 설정 (예시)
        isClickable = true
        setAccessibilityDelegate(object : View.AccessibilityDelegate() {
            override fun onInitializeAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfo) {
                super.onInitializeAccessibilityNodeInfo(host, info)
                // 역할 및 상태 정보 설정
                info.className = Button::class.java.name    // 예: 버튼 역할 부여
                info.text = "커스텀 구성 요소 설명"  // 접긍성 텍스트
                // info.contentDescription = "추가 설명"
                // info.isCheckable = true
                // info.isChecked = ...
                info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_CLICK)
            }
            // 다른 필요한 접근성 콜백 재정의
        })
    }
    // ... (뷰 나머지 구현)
}
```

#### 접근성 테스트하기

- Android Studio의 Accessibility Scanner 및 Layout Inspector와 같은 도구를 사용하여 접근성 문제를 식별하고 수정

#### 실전 질문

Q) 동적인 글꼴 사이즈를 지원하기 위한 모범 사례는 무엇이고, 텍트스 크기에 dp 단위보다 sp 단위를 사용하는 것이 선호되는 이유는 무엇인가요?

A) 동적인 글꼴 사이즈를 지원하기 위한 모범 사례는 사용자의 접근성 설정을 존중하고, 텍스트 크기를 sp 단위로 정의하여 기기 설정에 따라 자동으로 조정되도록 하는 것입니다. sp 단위를 사용하는 이유는 사용자의 글꼴 크기 환경 설정을 반영할 수 있기 때문입니다. dp 단위는 픽셀 밀도에 따라 크기가 조정되지만, sp 단위는 사용자 설정에 따라 크기가 조정되어 접근성을 향상시킵니다.

Q) 개발자는 보조 기술에 의존하는 사용자를 위해 적절한 포커스 관리 및 탐색을 어떻게 보장할 수 있으며, 접근성 문제를 테스트하는 데 도움이 되는 안드로이드 도구에는 어떤 것이 있나요?

A) 개발자는 View의 포커스 동작을 적절하게 관리하고, 논리적인 탐색 경로를 정의하여 보조 기술에 의존하는 사용자가 앱을 쉽게 탐색할 수 있도록 해야 합니다. 이를 위해 android:nextFocusDown, android:nextFocusUp 등의 속성을 사용할 수 있습니다. 접근성 문제를 테스트하는 데 도움이 되는 안드로이드 도구로는 Accessibility Scanner와 Layout Inspector가 있습니다. 이 도구들은 UI 요소의 접근성 문제를 식별하고 수정하는 데 유용합니다.

### 27. 안드로이드 파일 시스템이란 무엇인가요?

- 안드로이드 파일 시스템은 안드로이드 기기에서 데이터 저장을 관리하고 구성하는 구조화된 환경
- 파일 시스템은 리눅스의 파일 시스템 아키텍처 위에 구축되어 엄격한 보안 및 권한 모델을 준수하면서 애플리케이션을 위한 비공개 및 공유 저장 공간을 모두 제공

#### 안드로이드 파일 시스템의 주요 구성 요소

- System Partition (/system): 안드로이드 프레임워크 라이브러리, 시스템 앱 및 구성 파일을 퐇마한 핵심 운영 체제 파일이 들어있음. 이 파티션은 우발적이거나 악의적인 수정을 방지하기 위해 일반 사용자 및 앱에 대해 읽기 전용
- Data Partition (/data): 데이터베이스, SharedPreferences 및 사용자가 생성한 파일을 포함한 앱 별 데이터가 저장됨. 각 앱은 /data/data 내에 해당 앱만 접근할 수 있는 비공개 디렉토리를 가지므로 데이터 보안이 보장됨
- Cache Partition (/cache): 시스템 업데이트나 기기 재시작 시 유지할 필요가 없는 캐시된 파일과 같은 임시 데이터 저장에 사용
- External Storage (/sdcard 또는 /storage): 여러 앱에서 접근할 수 있는 공유 저장 공간을 제공하며, 이미지, 비디오, 문서와 같은 미디어 파일에 자주 사용됨. 이는 내부 또는 이동식 SD 카드일 수 있음
- Temporary Files (/tmp): 앱 실행 중 임시 파일을 저장하는 위치. 이러한 파일은 앱이나 시스템이 재시작될 때 지워짐

#### 안드로이드에서 파일 접근하기

- 내부 저장소(Internal Storage): 애플리케이션 샌드박스 내의 비공개 저장 공간으로, 해당 앱만 접근 가능. 민감하거나 앱별 데이터 저장에 이상적
- 외부 저장소(External Storage): 여러 앱에서 접근할 수 있는 공유 저장 공간으로, 사용자가 앱 외부에서 접근할 것으로 예상하는 사용자 생성 콘텐츠 또는 미디어를 저장하는 데 사용

#### 파일 권한 및 보안

- 비공개 앱 데이터: 앱의 내부 저장소에 저장된 파일은 비공개이며 해당 앱만 접근 가능
- 공유 파일: 앱 간에 파일을 공유하려면 개발자는 외부 저장소나 적절한 권한이 있는 ContentProvider를 사용
- 범위 지정 저장소(Scoped Storage): 안드로이드 10에서 도입되었으며, 공유 저장소에 대한 직접 접근을 제한하여 앱이 MediaStore 또는 SAF(Storage Access Framework) API를 사용하도록 요구

#### 실전 질문

Q) 안드로이드는 파일 시스템에서 보안 및 권한을 어떻게 관리하며, 앱이 서로의 비공개 데이터에 접근할 수 없도록 보장하는 메커니즘은 무엇인가요?

A) 안드로이드는 파일 시스템에서 보안 및 권한을 관리하기 위해 각 앱에 대한 샌드박스 환경을 제공합니다. 각 앱은 /data/data 내에 비공개 디렉토리를 가지며, 이 디렉토리는 해당 앱만 접근할 수 있습니다. 이를 통해 앱 간의 데이터 격리가 이루어지며, 다른 앱이 비공개 데이터를 직접 접근할 수 없도록 보장합니다. 또한, 범위 지정 저장소(Scoped Storage)를 통해 외부 저장소에 대한 접근을 제한하고, ContentProvider를 사용하여 안전하게 데이터를 공유할 수 있도록 합니다.

### 28. 안드로이드 런타임(ART), Dalvik, Dex 컴파일러란 무엇인가요?

#### 안드로이드 런타임 (ART)

- 안드로이드 런타임(ART)은 안드로이드 4.4 (KitKat)에서 도입되어 안드로이드 5.0 (Lollipop)부터 디폴트로 사용되는 관리형 런타임 환경
- ART는 Ahead-of-Time (AOT) 컴파일을 사용하여 애플리케이션을 컴파일하며, 앱 설치 중에 바이트코드를 기계 코드로 변환
- 이는 런타임 시 Just-in-Time (JIT) 컴파일의 필요성을 없애 앱 시작 시간을 단축하고 실행 중 CPU 사용량을 줄임
- 다음과 같은 특징을 가짐
  - 개선된 성능: AOT 컴파일은 최적화된 기계 코드를 생성하여 런타임 오버헤드를 줄임
  - 가비지 컬렉션: ART는 더 나은 메모리 관리를 위해 개선된 가비지 컬렉션 기술을 도입
  - 디버깅 및 프로파일링 지원: ART는 개발자를 위해 상세한 스택 트레이스 및 메모리 사용량 분석과 같은 향상된 도구를 제공

#### Dalvik

- ART 이전에 안드로이드에서 사용된 런타임으로 가상 머신 환경에서 애플리케이션을 실행하도록 설계되었으며 제한된 메모리와 처리 능력을 위해 최적화됨
- Just-in-Time (JIT) 컴파일을 사용하여 런타임에 바이트코드를 기계 코드로 변환
- 앱 설치에 필요한 시간을 줄이지만, 즉석 컴파일로 인한 런타임 오버헤드가 증가
- 다음과 같은 특징을 가짐
  - 컴팩트한 바이트코드: Dalvik은 낮은 메모리 사용량과 빠른 실행을 위해 최적화된 .dex (Dalvik Excecutable) 파일을 사용
  - 레지스터 기반 VM: Dalvik은 스택 기반(JVM과 같음)이 아닌 레지스터 기반이므로 명령어 효율성이 샹상됨
- Dalvik은 느린 앱 시작 시간과 높은 CPU 사용량과 같은 한계로 인해 최신 안드로이드 버전에서는 ART로 대체

#### Dex 컴파일러

- Dex 컴파일러는 Java/Kotlin 컴파일러에서 생성된 Java 바이트코드를 .dex (Dalvik Executable) 파일로 변환. 이러한 .dex 파일은 컴팩트하며 Dalvik 및 ART 런타임 환경에 최적화
- 다음과 같은 특징을 가짐
  - 멀티덱스(Multi-dex) 지원: 64K 메소드 제한을 초과하는 애플리케이션의 경우 Dex 컴파일러는 바이트코드를 여러 .dex 파일로 분할하는 것을 지원
  - 바이트코드 최적화: 컴파일러는 안드로이드 기기에서 더 나은 메모리 사용량과 실행 성능을 위해 바이트코드를 최적화

#### Dalvik에서 ART로의 전환

- Dalvik에서 ART로의 전환은 안드로이드의 런타임 환경을 상당히 개선시킴
- ART의 AOT 컴파일, 개선된 가비지 컬렉션 및 프로파일링 기능을 더 나은 개발자 및 사용자 경험을 제공함
- Dalvik 용으로 설계된 앱은 .dex 파일을 사용하기 때문에 ART와 완벽하게 호환되어 개발자에게 원활한 마이그레이션을 보장

#### 실전 질문

Q) ART의 Ahead-of-Time (AOT) 컴파일은 Dalvik의 Just-in-Time (JIT) 컴파일과 어떻게 다르며, 앱 시작 시간과 CPU 사용량에 어떤 영향을 미치나요?

A) ART의 AOT 컴파일은 앱 설치 중에 바이트코드를 기계 코드로 변환하여 런타임 시 오버헤드를 줄이는 반면, Dalvik의 JIT 컴파일은 런타임에 바이트코드를 기계 코드로 변환합니다. AOT 컴파일은 앱 시작 시간을 단축시키고 CPU 사용량을 줄이는 반면, JIT 컴파일은 즉석에서 변환되므로 앱 시작 시간이 느려지고 CPU 사용량이 증가할 수 있습니다.

### 29. APK 파일과 AAB 파일의 차이점은 무엇인가요?

#### APK (Android Package)

- APK 파일은 안드로이드 애플리케이션을 배포하고 설치하는 전통적인 포맷
- 앱이 기기에서 작동하는 데 필요한 모든 리소스, 코드 및 메타데이터를 포함하는 완전하고 즉시 설치 가능한 패키지
- 모든 리소스를 포함하여 사용자의 기기와 관련 없는 리소스를 포함하게 되어 파일 크기가 커질 수 있음
- APK 파일은 기기에 직접 설치되며 공식 앱 스토어 외부에서 공유하거나 사이드로딩(sideloading)할 수 있음

#### AAB (Android App Bundle)

- 개발자가 AAB를 Google Play에 업로드하면, Google Play는 이를 개별 기기에 맞게 최적화된 APK로 처리
- AAB 파일은 모듈식으로, 다른 구성에 대한 리소스와 코드를 별개의 번들로 분리. Google Play는 이 모듈식 구조를 사용하여 다운로드 시점에 기기별 APK를 생성
- AAB 파일은 Google Play 서버 측에서 처리되므로 직접 설치될 수 없음

#### APK와 AAB의 주요 차이점

1. 목적 및 구조
  - APK: 모든 구성에 대한 모든 리소스와 코드를 포함하는 완전한 패키지
  - AAB: 기기별 APK를 생성하는 모듈식 게시 형식
2. 파일 크기
  - APK: 모든 기기에 대한 리소스를 포함하여 크기가 더 큼
  - AAB: 더 작고 최적화된 APK를 생성할 수 있게 하여 사용자에게 전달되는 앱 크기를 줄임
3. 배포
  - APK: 기기에 직접 공유하고 사이드로딩할 수 있음
  - AAB: Google Play에 업로드되며, Google Play가 최종 사용자를 위해 최적화된 APK를 생성
4. 관리
  - APK: 개발자가 리소스와 구성을 수동으로 관리해야 함
  - AAB: 구성 관리를 Google Play에 위임하여 프로세스를 자동화
5. 도구 및 호환성
  - APK: 모든 안드로이드 기기 및 앱 스토어에서 지원
  - AAB: 설치 가능한 APK를 생성하기 위해 Google Play 또는 bundletool이 필요하며, 기본적으로 Google 외 앱 스토어와 호환되지 않음

#### 실전 질문

Q) AAB 포맷은 어떻게 다양한 기기 구성에 대해서 앱을 최적화하며, 이는 기존 APK 포맷에 비해 어떤 장점이 있나요?

A) AAB 포맷은 모듈식 구조를 사용하여 기기별로 필요한 리소스와 코드를 분리합니다. Google Play는 AAB를 처리하여 각 기기에 최적화된 APK를 생성함으로써, 불필요한 리소스를 제거하고 앱 크기를 줄입니다. 이는 기존 APK 포맷에 비해 파일 크기를 줄이고, 다운로드 시간을 단축시키며, 사용자에게 더 나은 경험을 제공합니다.

### 30. R8 최적화란 무엇인가요?

- R8은 안드로이드 빌드 프로세스에서 APK 또는 AAB의 크기를 줄이고 런타임 성능을 향상시키 위해 사용되는 코드 축소 및 최적화 도구
- 안드로이드 빌드 시스템에 통합되어 이전의 프로가드 (ProGuard) 도구를 대체하고 코드 축소, 최적화, 난독화 및 리소스 관리를 위한 향상된 기능을 제공

#### R8 작동 방식

- 코드 축소(Shrinking): 애플리케이션 코드베이스에서 사용되지 않는 클래스, 메소드, 필드 및 속성을 제거하여 최종적인 APK 또는 AAB 크기를 줄임
- 최적화(Optimization): 런타임 성능을 향상시키기 위해 코드를 단순화하고 재구성함. 여기는 메소드 인라이닝(inlining), 중복 코드 제거, 동일한 코드 블록 병합 등이 포함됨
- 난독화(Obfuscation): 클래스, 메소드 및 필드의 이름을 변경하여 원래 이름을 모호하게 만들어 리버스 엔지니어링을 더 어렵게 만듦
- 리소스 최적화: 사용되지 않는 리소스(가령, 레아아웃, 드로어블(Drawable), 문자열)를 제거하여 앱 사이즈를 더욱 최소화

#### R8 최적화의 주요 특징

- 죽은 코드 제거(Dead Code Removal): R8은 코드베이스를 분석하여 앱에서 도달할 수 없거나 사용되지 않는 코드를 식별하고 제거
- 인라이닝(Inlining): 짧은 메소드나 함수를 호출자쪽에 직접 인라인하여 메소드 호출 오버헤드를 줄이고 런타임 성능을 향상
- 클래스 병합(Class Merging): 유사한 클래스나 인터페이스를 하나로 결합하여 메모리 공간을 줄이고 효율성을 향상
- 도달 불가능한 코드 제거(Unreachable Code Elimination): 실행되지 않는 코드 경로를 완전히 제거
- 상수 폴딩 및 전파(Constant Folding and Propagation): 표현식을 단순화하고 변수를 가능한 경우 해당 상수 값으로 대체
- 난독화(Obfuscation): R8은 코드의 의미 있는 이름을 더 짧고 덜 설명적인 이름으로 대체하여 앱 크기를 줄이고 리버스 엔지니어링을 더 어렵게 만듦

#### R8 구성

R8은 앱 빌드 구성을 위해 ProGuard 규칙을 동일하게 사용
- 리플렉션을 위한 코드 보존: 리플레션을 통해 접근하는 클래스나 메소드는 런타임에 해당 패키지 이름을 알아야하기 때문에 ProGuard 규칙에 명시적으로 유지(keep)하여 난독화하지 않도록 함
- 서드파티 라이브러리 제외: 일부 라이브러리는 내부적으로 리플렉션을 사용할 수도 있고, 정상적인 기능 동작을 위해 특정 규칙이 필요할 수도 있음
```xml
-keep class com.example.MyClass { *; }
```

#### R8의 장점

- 긴밀한 통합: R8은 안드로이드 빌드 시스템에 내장되어 있어 일반적인 ProGuard 규칙 외에 추가 설정이 필요하지 않음
- 향상된 효율성: 축소, 최적화 및 난독화를 단일 패스로 결합하여 ProGuard 보다 빠르고 효율적
- 앱 크기 감소: 사용되지 않는 코드와 리소스를 제거하여 최종 APK 또는 AAB 크기를 크게 줄임
- 향상된 보안: 난독화는 해커 및 크래커가 앱을 리버스 엔지니어링하기 어렵게 만들어 보안을 강화

#### R8의 한계

- 과도한 축소 위험: 제대로 구성하지 않으면 R8이 간접적으로 참조되는 코드나 리소스를 제거하여 런타임 오류를 유발할 수도 있음
- 복잡한 구성: 복잡한 프로젝트, 특히 리플렉션이나 동적 클래스 로딩을 사용하는 프로젝트의 경우 ProGurad 규칙 작성이 복잡하고 까다로울 수 있음
- 디버깅 어려움: 난독화는 스택 트레이스에 난독화된 이름이 로깅되기 때문에 디버깅을 더 어렵게 만들 수 있음

#### 실전 질문

Q) R8 최적화는 앱 성능을 어떻게 개선하고, APK/AAB 용량을 어떻게 줄이나요?

A) R8 최적화는 사용되지 않는 코드, 리소스 및 중복 코드를 제거하여 APK/AAB의 크기를 줄이고, 메소드 인라이닝, 클래스 병합 및 상수 폴딩과 같은 최적화를 통해 런타임 성능을 향상시킵니다. 또한, 난독화를 통해 앱의 보안을 강화하고 리버스 엔지니어링을 어렵게 만듭니다.

Q) R8은 ProGuard와 어떻게 다르며, 어떤 추가적인 장점을 제공하나요?

A) R8은 ProGuard의 기능을 통합하고 향상시킨 도구로, 축소, 최적화 및 난독화를 단일 패스로 처리하여 더 빠르고 효율적입니다. R8은 안드로이드 빌드 시스템에 내장되어 있어 추가 설정이 필요하지 않으며, 앱 크기를 더욱 줄이고 성능을 향상시키는 데 중점을 둡니다. ProGuard보다 더 나은 통합과 효율성을 제공하는 것이 R8의 주요 장점입니다.

