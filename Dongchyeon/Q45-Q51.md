### 45. 안드로이드 Bitmap이란 무엇이며, 큰 Bitmap을 효율적으로 처리하는 방법은 무엇인가요?

- Bitmap은 메모리 내 이미지 표현이며 픽셀 데이터를 저장하며 리소스, 파일 또는 원격 소스에서 가져온 이미지를 화면에 렌더링하는 데 자주 사용
- 대량의 픽셀 데이터를 부적절하게 처리하면 메모리 고갈 및 OutOfMemoryError가 발생

#### 큰 Bitmap의 문제점

- 과도한 메모리를 소비함
- 성능 오버헤드를 유발함
- 메모리 압박으로 인해 크래시가 발생할 위험이 있음

#### 메모리를 할당하지 않고 Bitmap 크기 읽기

- 비트맵을 고드하기 전에 전체 로그다 정당한지 결정하기 위해 크기를 검사하는 것이 중요
- `BitmapFactory.Options` 클래스를 사용하면 `inJustDecodeBounds = true`로 설정하여 픽셀 데이터에 대한 메모리 할당을 피하면서 이미지 메타데이터를 디코딩할 수 있음
```kotlin
val options = BitmapFactory.Options().apply {
    inJustDecodeBounds = true
}
BitmapFactory.decodeResource(resource, R.drawable.my_image, options)

val imageWidth = options.outWidth
val imageHeight = options.outHeight
val imageType = options.outMimeType
```

#### 샘플링을 사용하여 축소된 Bitmap 로드하기

- 크기를 알게 되면 inSampleSize 옵션을 사용하여 비트맵을 대상 크기에 맞게 축소할 수 있음
- 이는 이미지를 2, 4 등의 배수로 서브샘플링하여 메모리 사용량을 줄임

```kotlin
fun calculateInSampleSize(
    options: BitmapFactory.Options,
    reqWidth: Int,
    reqHeight: Int
) : Int {
    val (height, width) = options.run { outHeight to outWidth }
    var inSampleSize = 1

    if (height > reqHeight || width > reqWidth) {
        val halfHeight: Int = height / 2
        val halfWidth: Int = width / 2

        while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {
            inSampleSize *= 2
        }
    }
    return inSampleSize
}
```
#### 서브샘플링을 사용한 전체 디코딩 프로세스

calculateInSampleSize를 사용하여 두 단계로 비트맵을 디코딩할 수 있음

1. 경계(bounds)만 디코딩
2. 계산된 inSampleSize를 설정하고 축소된 비트맵을 디코딩

```kotlin
fun docodeSampledBitmapFromResource(
    resources: Resources,
    resId: Int,
    reqWidth: Int,
    reqHeight: Int
): Bitmap? {
    // 먼저 inJustDecodeBounds를 true로 설정하여 경계만 디코딩
    return BitmapFactory.Options().run {
        inJustDecodeBounds = true
        BitmapFactory.decodeResource(resources, resId, options)

        // inSampleSize 계산
        inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)

        // inSampleSize를 설정하고 비트맵 디코딩
        inJustDecodeBounds = false
        BitmapFactory.decodeResource(resources, resId, this)
    }
    
    return null
}
```

이를 ImageView와 함께 사용하려면 간단히 호출

```kotlin
// ImageView 크기에 맞게 reqWidth와 reqHeight 설정
val bitmap = decodeSampledBitmapFromResource(
    resources,
    R.drawable.my_image,
    imageView.width,
    imageView.height
)
imageView.setImageBitmap(bitmap)
```

#### 실전 질문

Q) 큰 Bitmap을 메모리에 로드하는 것은 어떤 위험성이 있으며, 어떻게 효율적으로 처리할 수 있나요?

A) 큰 Bitmap을 메모리에 로드하면 과도한 메모리 사용으로 인해 OutOfMemoryError가 발생할 수 있습니다. 이를 방지하기 위해 BitmapFactory.Options의 inJustDecodeBounds를 사용하여 이미지 크기를 먼저 확인하고, 적절한 샘플링 비율을 계산한 후, 축소된 Bitmap을 로드하는 것이 좋습니다. 이렇게 하면 메모리 사용량을 줄이고 성능을 향상시킬 수 있습니다.

#### Pro Tips for Mastery: 커스텀 이미지 로딩 시스템에서 큰 비트맵 캐싱을 어떻게 구현하나요?

- LruCache를 사용한 메모리 내 캐싱과 DiskLruCache를 사용한 디스크 기반 캐싱이 존재

##### LruCache를 사용한 메모리 내 캐싱

- LruCache는 최근에 사용된 항목에 대한 강력함 참조를 유지하고, 메모리가 부족할 때 가장 최근에 사용되지 않은 항목을 자동으로 제거

```kotlin
object LruCacheManager {
    // 사용 가능한 최대 메모리 (KB)
    val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
    // 캐시 크기를 최대 메모리의 1/8로 설정 (KB)
    val cacheSize = maxMemory / 8
    
    val memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
        // 캐시 항목 크기를 KB 단위로 정의
        override fun sizeOf(key: String, bitmap: Bitmap): Int {
            // 비트맵의 크기를 KB 단위로 반환
            return bitmap.byteCount / 1024
        }
    }
}
```

```kotlin
fun loadBitmap(imageId: Int, imageView: ImageView) {
    val imageKey = imageId.toString()
    // 메모리 캐시에서 먼저 확인
    LruCacheManager.memoryCache.get(key)?.let {
        imageView.setImageBitmap(it)
    } ?: run {
        // 캐시에 없으면 플레이스홀더 설정 및 백그라운드 작업 요청
        imageView.setImageResource(R.drawable.image_placeholder)
        
        val workRequest = OneTimeWorkRequestBuilder<BitmapDecodeWorker>()
            .setInputData(workDataOf("imageId" to imageId))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}
```

```kotlin
class BitmapDecodeWorker(
    context: Context,
    workerParams: WorkerParameters
) : CoroutineContext(context, workerParams) {
    
    override suspend fun doWork(): Result {
        val imageId = inputData.getInt("imageId", -1)
        if (imageId == -1) return Result.failure()
        
        // 리소스에서 샘플링된 비트맵 디코딩
        val bitmap = decodeSampledBitmapFromResource(
            res = applicationContext.resources,
            resId = imageId,
            reqWidth = 100,
            reqHeight = 100
        )
        
        bitmap?.let {
            LruCacheManager.memoryCache.put(imageId.toString(), it)
            return Result.success()
        }
        
        return Result.failure()
    }
}
```

- SoftReference 또는 WeakReference를 사용하면 GC가 수거해갈 수도 있기 때문에 사용하지 않음

##### DiskLruCache를 사용한 디스크 캐싱

- 비트맵이 앱 세션 간에 지속되고 재계산을 피하도록 보장하려면 DiskLruCache 라이브러리를 사용하여 비트맵을 디스크에 저장할 수 있음
- 리소스 집약적인 이미지나 스크롤 가능한 이미지 목록을 처리할 때 유용

```kotlin
class DiskCacheManager(
    context: Context, 
    cacheDirname: String = "images",
    cacheSize: Long = 10 * 1024 * 1024
) {
    
    private var diskLruCache: DiskLruCache? = null
    private val lock = Any()
    
    init {
        val cacheDir = getDiskCacheDir(context, cacheDirname)
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
        try {
            // DiskLruCache 열기 (앱 버전, 값 개수, 최대 크기)
            diskLruCache = DiskLruCache.open(cacheDir, 1, 1, cacheSize)
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
    
    private fun getDiskCacheDir(context: Context, uniqueName: String): File {
        val cachePath = if (Environment.MEDIA_MOUNTED == Environment.getExternalStorageState() || !Environment.isExternalStorageRemovable()) {
            context.externalCacheDir?.path
        } else {
            context.cacheDir.path
        }
        return File(cachePath + File.separator + uniqueName)
    }
    
    // 키를 안전한 파일 이름으로 변환 (SHA-1 사용)
    private fun filenameForKey(key: String): String {
        return try {
            val messageDigest = MessageDigest.getInstance("SHA-1")
            messageDigest.update(key.toByteArray())
            bytesToHexString(messageDigest.digest())
        } catch (e: NoSuchAlgorithmException) {
            key.hashCode().toString()
        }
    }
        
    private fun bytesToHexString(bytes: ByteArray): String {
        val sb = StringBuilder()
        for (b in bytes) {
            val hex = Integer.toHexString(0xFF and b.toInt())
            if (hex.length == 1) {
                sb.append('0')
            }
            sb.append(hex)
        }
        return sb.toString()
    }
        
    // 디스크 캐시에서 비트맵 가져오기
    fun get(key: String): Bitmap? {
        synchronized(lock) {
            val safeKey = filenameForKey(key)
            var snapshot: DiskLruCache.Snapshot? = null
            return try {
                snapShot = diskLruCache?.get(safeKey)
                snapShot?.getInputStream(0)?.use { inputStream ->
                    BitmapFactory.decodeStream(inputStream)
                }
            } catch (e: IOException) {
                e.printStackTrace()
                null
            } finally {
                snapshot?.close()
            }
        }
    }
    
    // 디스크 캐시에 비트맵 설정하기
    fun set(key: String, bitmap: Bitmap) {
        synchronized(lock) {
            val safeKey = filenameForKey(key)
            var editor: DiskLruCache.Editor? = null
            try {
                editor = diskLruCache?.edit(safeKey)
                editor?.let {
                    it.newOutputStream(0).use { outputStream ->
                        if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)) {
                            it.commit()
                        } else {
                            it.abort()
                        }
                    }
                }
            } catch (e: IOException) {
                e.printStackTrace()
                editor?.abort()
            }
        }
    }
}
```

이 클래스는 다음을 보장
- 디스크 안전한 SHA-1 기반 파일 이름 생성
- 안전한 I/O 작업
- 디스크 캐시에 중복으로 데이터를 쓰는 행위 방지

```kotlin
class BitmapWorker(
    private val context: Context,
    workerParams: WorkerParameters
) { 
    // DiskCacheManager 인스턴스는 싱글톤 또는 의존성 주입으로 관리해야 한다
    private val diskCacheManager = DiskCacheManager(context)
    
    override suspend fun doWork(): Result {
        val key = inputData.getString("imageKey") ?: return Result.failure()
        val resId = inputData.getInt("resId", -1)
        if (resId == -1) return Result.failure()
        
        // 메모리 캐시 먼저 확인
        LruCacheManager.memoryCache.get(key)?.let {
            // 메모리 캐시에이미 있으면 성공
            return Result.success()
        }
        
        // 디스크 캐시 확인
        diskCacheManager.get(key)?.let { bitmapFromDisk ->
            // 디스크 캐시에 있으면 메모리 캐시에 추가하고 성공
            LruCacheManager.memoryCache.put(key, bitmapFromDisk)
            return Result.success()
        }
        
        // 캐시에 없으면 디코딩 및 캐싱
        val bitmap = decodeSampledBitmapFromResource(
            res = context.resources,
            resId = resId,
            reqWidth = 100,
            reqHeight = 100
        )
        
        // 비트맵을 메모리 및 디스크 캐시에 추가
        return try {
            bitmap?.let {
                addBitmapToCache(diskCacheManager, key, it)
                Result.success()
            } ?: Result.failure()
        } catch (e: Exception) {
            Result.failure()
        }
    }
    
    private fun addBitmapToCache(diskCacheManager: DiskCacheManager, key: String, bitmap: Bitmap) {
        // 메모리 캐시에 추가
        if (LruCacheManager.memoryCache.get(key) == null) {
            LruCacheManager.memoryCache.put(key, bitmap)
        }
        
        diskCacheManager.set(key, bitmap)
    }
    
    private fun decodeSampledBitmapFromResource(
        res: Resources,
        resId: Int,
        reqWidth: Int,
        reqHeight: Int
    ): Bitmap? {
        // 먼저 inJustDecodeBounds를 true로 설정하여 경계만 디코딩
        return BitmapFactory.Options().run {
            inJustDecodeBounds = true
            BitmapFactory.decodeResource(res, resId, this)

            // inSampleSize 계산
            inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)

            // inSampleSize를 설정하고 비트맵 디코딩
            inJustDecodeBounds = false
            BitmapFactory.decodeResource(res, resId, this)
        }
        
        return null
    }
}
```

- 가능하면 디스크 캐시에서 읽음
- 디코딩으로 대체함
- 결과를 메모리 및 디스크 캐시 모두에 저장
- 코루틴을 활용하여 메인 스레드 외부에서 안전하게 실행

### 46. 애니메이션을 어떻게 구현하나요?

- 애니메이션은 부드러운 전환을 만들고, UI 변화에 대해서 유저들의 이목을 집중시키며, 시각적인 피드백을 제공하여 사용자 경험을 향상시킬 수 잇음

#### View Property Animations

- View Property Animations는 API 11부터 도입되었으며 alpha, translationX, translationY, rotation, scaleX와 같은 View 객체의 속성을 애니메이션화

```kotlin
val view: View = findViewById(R.id.my_view)
view.animate()
    .alpha(0.5f)
    .translationX(100f)
    .setDuration(500) // 지속 시간 설정
    .setInterpolator(AccelerateDecelerateInterpolator())
    .start()
```

#### ObjectAnimator

- ObjectAnimator는 View 객체뿐만 아니라 setter 메소드가 있는 모든 객체의 속성을 애니메이션화

```kotlin
val animator = ObjectAnimator.ofFloat(view, "translationY", 0f, 300f)
animator.duration = 500
animator.interpolator = OvershootInterpolator()
animator.start()
```

#### AnimatorSet

- AnimatorSet는 여러 애니메이션을 순차적으로 또는 동시에 실행하도록 결합하여 복잡한 애니메이션을 조정하는 데 적합

```kotlin
val fadeAnimator = ObjectAnimator.ofFloat(view, "alpha", 1f, 0f)
val moveAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 200f)

val animatorSet = AnimatorSet()
// 순차적으로 재생: fadeAnimator 실행 후 moveAnimator 실행
animatorSet.playSequentially(fadeAnimator, moveAnimator)
// 동시에 재생: animatorSet.playTogether(fadeAnimator, moveAnimator)
// 복잡한 순서: animatorSet.play(fadeAnimator).after(moveAnimator) 등
animatorSet.duration = 1000
animatorSet.start()
```

#### ValueAnimator

- ValueAnimator는 임의의 값 사이를 애니메이션화하는 방법을 제공하여 커스텀 가능하고 유연한 애니메이션을 구현

```kotlin
val valueAnimator = ValueAnimator.ofFloat(0f, 100f) // 0에서 100까지 정수 값 변경
valueAnimator.duration = 500
valueAnimator.addUpdateListener { animation ->
    val animatedValue = animation.animatedValue as Int
    // animtedValue를 사용하여 UI 업데이트 (예: ProgressBar 너비 조정)
    val params = binding.progressBar.layoutParams
    params.width = ((screenSize / 100f) * animatedValue).toInt()
    binding.progressBar.layoutParams = params
}
valueAnimator.start()
```

#### XML 기반 View 애니메이션

- XML 파일을 사용하여 애니메이션을 정의하고 이를 코드에서 로드하여 적용할 수 있음

```xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromXDelta="0%"
    android:toXDelta="50%"
    android:duration="500"
    android:interpolator="@android:anim/accelerate_decelerate_interpolator"/>
```

```kotlin
val animation = AnimationUtils.loadAnimation(this, R.anim.slide_in)
view.startAnimation(animation)
```

#### MotionLayout

- MotionLayout는 ConstraintLayout의 확장으로, 복잡한 애니메이션과 전환을 쉽게 구현할 수 있도록 설계

```xml
<MotionScene xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <ConstraintSet android:id="@+id/start">
        <!-- 시작 상태 제약 조건 정의 -->
        <Constraint
            android:id="@+id/box"
            android:layout_width="100dp"
            android:layout_height="100dp"
            motion:layout_constraintTop_toTopOf="parent"
            motion:layout_constraintStart_toStartOf="parent"/>
    </ConstraintSet>

    <ConstraintSet android:id="@+id/end">
        <!-- 종료 상태 제약 조건 정의 -->
        <Constraint android:id="@id/box">
            <Layout
                android:layout_width="100dp"
                android:layout_height="100dp"
                motion:layout_constraintBottom_toBottomOf="parent"
                motion:layout_constraintEnd_toEndOf="parent"/>
        </Constraint>
    </ConstraintSet>

    <Transition
        motion:constraintSetStart="@id/start"
        motion:constraintSetEnd="@id/end"
        motion:duration="500">
        <!-- 스와이프 또는 클릭 트리거 추가 -->
        <OnSwipe
            motion:dragDirection="dragDown"
            motion:touchAnchorId="@id/box"
            motion:touchAnchorSide="top"/>
    </Transition>
</MotionScene>
```

```xml
<androidx.constraintlayout.motion.widget.MotionLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutDescription="@xml/motion_scene">

    <!-- 애니메이션할 뷰 정의 -->
    <View
        android:id="@+id/box"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:background="@color/blue" />
    
</androidx.constraintlayout.motion.widget.MotionLayout>
```

#### Drawable 애니메이션

- Drawable 애니메이션은 AnimationDrawable을 사용하여 프레임별 전환을 포함하며, 로딩 스피너와 같은 간단한 애니메이션을 만드는 데 적합

```xml
<animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="false">
    <item android:drawable="@drawable/frame1" android:duration="100"/>
    <item android:drawable="@drawable/frame2" android:duration="10"/>
    <item android:drawable="@drawable/frame3" android:duration="10"/>
    <!-- 추가 프레임 -->
</animation-list>
```

```kotlin
// ImageView의 배경으로 설정했다고 가정
val imageView: ImageView = findViewById(R.id.animted_image)
imageView.setBackgroundResource(R.drawable.animation_list)
val animationDrawable = imageView.background as AnimationDrawable.drawable
animationDrawable.start()
```

#### 물리 기반 Animations

- 물리 기반 애니메이션은 실제 역학을 시뮬레이션 SpringAnimation과 FlingAnimation을 사용하여 자연스러운 움직임을 구현

```kotlin
val springAnimation = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f)
springAnimation.spring = SpringForce()
    .setFinalPosition(0f)   // 최종 위치 설정 (중복될 수 있음)
    .setStiffness(SpringForce.STIFFNESS_LOW)    // 강성 설정
    .setDampingRatio(SpringForce.DAMPING_RATIO_HIGH_BOUNCY) // 감쇠 비율 설정
springAnimation.start()
```

#### 실전 질문

Q) 클릭 시 확장 및 축소되는 버튼에 부드러운 애니메이션을 추가하려고 합니다. 어떻게 구현해 볼 수 있을까요?

A) View Property Animations를 사용하여 버튼의 크기와 투명도를 애니메이션화할 수 있습니다. 클릭 이벤트 리스너에서 버튼의 scaleX, scaleY, alpha 속성을 변경하는 애니메이션을 설정하고, AnimatorSet을 사용하여 순차적으로 실행할 수 있습니다. 예를 들어, 버튼이 클릭되면 크기가 1.2배로 확장되고 투명도가 0.5로 감소한 후 원래 상태로 돌아오는 애니메이션을 구현할 수 있습니다.

Q) 전통적인 View 애니메이션 대신 MotionLayout을 사용하는 사례는 무엇이고, 그 장점은 무엇인가요?

A) MotionLayout은 복잡한 애니메이션과 전환을 쉽게 구현할 수 있도록 설계된 ConstraintLayout의 확장입니다. 전통적인 View 애니메이션은 단순한 애니메이션에 적합하지만, MotionLayout은 여러 뷰 간의 상호작용과 상태 전환을 관리하는 데 뛰어납니다.

#### Pro Tips for Mastery: 인터폴레이터(interpolator)는 애니메이션과 어떻게 작동하나요?

Interpolator는 애니메이션 값 변경 속도를 수정하여 애니메이션이 시간 경과에 따라 어떻게 진행되는지 정의

1. LinearInterpolator: 가속이나 감속 없이 일정한 속도로 애니메이션
2. AccelerateInterpolator: 느리게 시작하여 점진적으로 속도를 높임
3. DecelerateInterpolator: 빠르게 시작하여 끝으로 갈수록 느려짐
4. AccelerateDecelerateInterpolator: 부드러운 효과를 위해 가속과 감속을 모두 결합
5. BounceInterpolator: 스프링 애니메이션을 모방하여 애니메이션이 튕기는 것처럼 보이게 함
6. OvershootInterpolator: 최종 값을 초과하여 애니메이션한 후 다시 정착

```kotlin
class CustomInterpolator : Interpolator {
    override fun getInterpolation(input: Float): Float {
        // 애니메이션 타이밍을 위한 커스텀 로직 (예: 제곱 가속)
        return input * input
    }
}

animator.interpolator = CustomInterpolator()
```

- Interpolator 인터페이스를 확ㅈ앟고 getInterpolation() 메소드를 재정의하여 커스텀 Interpolator를 만들 수 있음

### 47. Window란 무엇인가요?

- Window는 화면에 표시되는 Activity 또는 다른 UI 컴포넌트의 모든 뷰를 담는 컴포넌트를 나타냄
- View 계층 구조의 최상위 요소이며 애플리케이션 UI와 디스플레이 간의 다리 역할을 함

#### Window의 주요 특징

- DecorView: Window는 계층 구조의 루트 뷰 역할을 하는 DecorView를 포함. 일반적으로 상태 표시(status bar), 내비게이션 바(navigation bar) 및 앱의 콘텐츠 영역을 포함
- 레이아웃 매개변수: Window는 크기, 위치, 가시성과 같은 레이아웃 매개변수를 사용하여 뷰가 어떻게 정렬되고 표시되는지 정의
- 입력 처리: Window는 입력 이벤트(가령, 터치 테스처, 키 누름)를 처리하고 이를 적절한 뷰로 전달
- 애니메이션 및 전환: Window는 화면 열기, 닫기 또는 화면 간 전환을 위한 애니메이션을 지원
- 시스템 UI 처리: Window는 상태 표시줄 및 네비게이션 바와 같은 시스템 UI 요소를 표시하거나 숨길 수 있음

#### Window 관리

- Window는 윈도우 추가, 제거 또는 업데이트를 담당하는 시스템 서비스인 WindowManager에 의해 관리

#### Window의 사용 사례

1. Activity Window 커스텀: getWindow() 메소드를 사용하여 Activity의 윈도우 동작을 수정할 수 있음. 가령, 상태 표시줄을 숨기거나 또는 배경색상을 변경할 수 있음

```kotlin
// 전체 화면 모드 설정 (상태 표시줄 숨김)
window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_FULLSCREEN
// 배경을 검은색으로 설정
window.setBackgroundDrawable(ColorDrawable(Color.BLACK))
```

2. Dialog 생성: Dialog는 새로운 윈도우를 사용하여 그 위에 구현되므로 다른 UI 요소 위에 떠 있을 수 있음
3. 오버레이 사용: TYPE_APPLICATION_OVERLAY를 통해 시스템 수준 기능이나 헤드업 알림과 같은 오버레이를 만드는 데 Window를 사용
4. 멀티 윈도우 모드 처리: 안드로이드는 분할 화면이나 PIP(Picture-in-Picture) 모드와 같은 기능을 활성화하기 위해 멀티 윈도우를 지원

#### 실전 질문

Q) 단순한 레이아웃을 가진 Activity가 화면에 표시될 때 몇 개의 Window가 존재하며, 어느 부분에 필요한가요?

A) 일반적으로 단일 Activity에는 하나의 Window가 존재합니다. 이 Window는 DecorView를 포함하며, 상태 표시줄, 내비게이션 바 및 앱의 콘텐츠 영역을 포함합니다. 추가적인 Window는 Dialog나 오버레이와 같은 특정 UI 요소를 표시할 때 생성될 수 있습니다.

#### Pro Tips for Mastery: WindowManager란 무엇인가요?

- WindowManager는 화면에서 윈도우의 배치, 크기 모양을 관리하는 안드로이드 시스템 서비스
- 안드로이드의 Window는 전체 화면 Activity부터 Floating Overlay까지 무엇이든 될 수 있음

##### WidnowManager의 주요 책임

- WindowManager는 시스템의 윈도우 계층 구조를 관리하는 역할을 함

##### 일반적인 사용 사례

- 커스텀 View 추가: WindowManager를 사용하여 플로팅 위젯이나 시스템 오버레이와 같은 앱의 표준 Activity 외부에 커스텀 뷰를 표시할 수 있음
- 기존 Window 수정: 애플리케이션은 크기 조절, 위치 변경 또는 투명도 변경과 같이 기존 윈도우의 속성을 업데이트할 수 있음
- Window 제거: removeView() 메소드를 사용하여 프로그래밍 방식으로 윈도우를 제거할 수 있음 

##### WindowManager 작업하기

- WindowManager 서비스는 Context.getSystemService(Context.WINDOW_SERVICE)를 통해 접근

```kotlin
val windowManager = context.getSystemService(Context.WINDOW_SERVICE)
val floatingView = LayoutInflater.from(context).inflate(R.layout.floating_view, null)

val params = WindowManager.LayoutParams(
    WindowManager.LayoutParams.WRAP_CONTENT,
    WindowManager.LayoutParams.WRAP_CONTENT,
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
    } else {
        WindowManager.LayoutParams.TYPE_PHONE
    },
    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
    PixelFormat.TRANSLUCENT
)

params.gravity = Gravity.TOP or Gravity.START
params.x = 0
params.y = 0

windowManager.addView(floatingView, params)
```

- TYPE_APPLICATION_OVERLAY는 뷰가 다른 앱 위에 표시되도록 허용 (권한 필요)
- FLAG_NOT_FOCUSABLE과 같은 플래그는 뷰가 포커스를 받지 않도록 설정

##### 제한 사항 및 권한

- 시스템 오버레이와 같은 특정 유형의 윈도우에는 SYSTEM_ALERT_WINDOW 권한이 필요
- 안드로이드 8.0 (API 26)부터 시스템은 보안상의 이유로 오버레이 윈도우에 대해 더 엄격한 제한을 부과

#### Pro Tips for Mastery: PopupWindow란 무엇인가요?

PopupWindow는 기존 레이아웃 위에 떠 있는 팝업 뷰를 표시하는 데 사용되는 UI 컴포넌트

- 레이아웃 위에 존재하는 어떠한 뷰든 해당 뷰 위에 콘텐츠를 표시할 수 있음
- 팝업 외 영역 화면을 어둡게 하거나 사용자 인터랙션을 차단할 필요가 없는 시나리오에서 팝업 뒤의 다른 UI 컴포넌트와 상호작용할 수 있음
- 커스텀 레이아웃, 애니메이션 및 해제 동작을 구현할 수 있음
- 원활한 사용자 경험을 위해 터치 기반 해제 및 포커스 제어를 지원

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var popupWindow: PopupWindow

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        val popupView = layoutInflater.inflate(R.layout.popup_layout, null)
        val popupWindow = PopupWindow(
            popupView,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            true // 포커스 가능 여부 설정
        )
        
        popupWindow.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
        popupWindow.isOutsideTouchable = true

        val button: Button = findViewById(R.id.button)
        button.setOnClickListener { anchorView ->
            popupWindow.showAsDropDown(anchorView)
        }
    }
}
```

- PopupWindow는 Window를 상속하지 않고 PopupWindow라는 독립적인 클래스로 존재
- 내부에서는 WindowManager를 통해 Window를 화면에 추가하고 제거

### 48. 웹 페이지를 어떻게 렌더링하나요?

- WebView는 앱 내에서 직접 웹 콘텐츠를 표시하고 상호 작용할 수 있는 유용한 안드로이드 컴포넌트
- 앱이 실행 중인 기기에서 최신 WebView 기능을 안전하게 활용하려면 AndroidX Webkit 라이브러리를 사용해야 함

#### WebView 초기화하기

```xml
<!-- activity_main.xml -->
<WebView
    android:id="@+id/webview"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/>
```

```kotlin
val webView = WebView(this)
setContentView(webView)
```

#### 웹 페이지 로드하기

```kotlin
val webView: WebView = findViewById(R.id.webView)
webView.loadUrl("https://www.example.com")
```

인터넷 접근을 허용하기 위해서는 AndroidManifest.xml에 다음 권한 추가

```xml
<uses-permission android:name="android.permission.INTERNET"/>
```
#### JavaScript 활성화하기

```kotlin
val webSettings = webView.settings
webSettings.javaScriptEnabled = true
```

#### WebView 동작 커스텀하기

- 페이지 내베기이션 가로채기: 외부 브라우저에서 열지 않고 WebView 내에서 페이지 내비게이션을 처리하려면 WebViewClient를 사용

```kotlin
webView.webViewClient = object : WebViewClient() {
    // API 24 미만 버전 호환성
    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
        url?.let { view?.loadUrl(it) }
        return true // URL 로딩을 WebView에서 처리
    }
    
    // API 24 이상 버전
    override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {
        request?.url?.toString()?.let { view?.loadUrl(it.toString()) }
        return true
    }
}
```

- 다운로드 처리하기: WebView를 통해 다운로드되는 파일을 관리하려면 DownlaodListener를 활용

```kotlin
webView.setDownlaodListener { url, userAgent, contentDisposition, mimeType, contentLength ->}
    val request = DownloadManager.Request(Uri.parse(url))
    request.setMimeType(mimeType)
    val cookies = CookieManager.getInstance().getCookie(url)
    request.addRequestHeader("cookie", cookies)
    request.addRequestHeader("User-Agent", userAgent)
    request.setDescription("Downloading file...")
    request.setTitle(URLUtil.guessFileName(url, contentDisposition, mimeType))
    request.allowScanningByMediaScanner()
    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
    request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, URLUtil.guessFileName(url, contentDisposition, mimeType))
    
    val downloadManager = getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    downloadManager.enqueue(request)
}
```

- WebView에서 JavaScript 실행하기: evaluateJavascript 또는 loadUrl("javascript:...")을 사용하여 JavaScript 코드를 주입

```kotlin
// API 19 이상 권장 방식
webView.evaluateJavascript("document.body.style.backgroundColor = 'red';") { result ->
    Log.d("WebView", "JavaScript result: $result")
}
```

#### JavaScript를 안드로이드 코드에 바인디앟기 위한 포괄적인 가이드

- addJavascriptInterface() 메소드를 사용하여 JavaScript와 안드로이드 코드를 바인딩

```kotlin
// WebView와 통신할 인터페이스 클래스 정의
class WebAppInterface(private val context: Context) {
    
    // JavaScript에서 호출할 수 있도록 @JavascriptInterface 어노테이션 추가
    @JavascriptInterface
    fun showToast(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
}

// WebView 설정 및 인터페이스 바인딩
val webView: WebView = findViewById(R.id.webView)
webView.settings.javaScriptEnabled = true
// "Android"라는 이름으로 인터페이스 객체 등록
webView.addJavascriptInterface(WebAppInterface(this), "Android")
```

```html
<!DOCTYPE html>
<html>
<head>
    <title>WebView Example</title>
</head>
<body>
    <button onClick="callAndroidFunction()">Click Me</button>
    <script type="text/javascript">
        function callAndroidFunction() {
            // "Android" 인터페이스의 showToast 메소드 호출
            Android.showToast("Hello from JavaScript!");
        }
    </script>
</body>
</html>
```

- addJavascriptInterface()는 유용하지만 한편으로 상당한 보안 위험이 따름
- WebView가 신뢰할 수 없거나 동적인 HTML 콘텐츠를 로드하는 경우 공격자가 악의적인 JavaScript를 주입하여 노출된 인터페이스를 악용하고 의도하지 않은 안드로이드 코드를 잠재적으로 실행할 수 있음

#### 보안 고려 사항

- 필요하지 않은 한 JavaScript를 활성화하지 않는 것이 좋음
- 파일에 대한 무단 접근을 방지하기 위해 setAllowFileAccess() 및 setAllowFileAccessFromFileURLs()를 신중하게 사용하는 것이 좋음
- 교차 사이트 스크립팅(XSS) 또는 URL 스푸핑과 같은 공격을 방지하기 위해 항상 사용자 입력을 검증하고 URL을 정제해야 함
- @JavascriptInterface를 통해 노출된 메소드가 보안 취약점을 유발하지 않는지 확인해야 함

#### 실전 질문

Q) 외부 링크를 클릭할 때 사용자가 앱을 벗어나는 것을 방지하기 위해 WebView 내비게이션을 효과적으로 처리하는 방법에는 무엇이 있는지 설명해 주세요

A) WebViewClient를 사용하여 shouldOverrideUrlLoading() 메소드를 재정의함으로써 외부 링크 클릭 시 WebView 내에서 페이지를 로드하도록 할 수 있습니다. 이 메소드에서 URL을 검사하고, 필요에 따라 WebView에 로드하거나 다른 처리를 수행할 수 있습니다. 이렇게 하면 사용자가 앱을 벗어나지 않고도 웹 콘텐츠를 탐색할 수 있습니다.

### 49. AppCompat 라이브러리란 무엇인가요?

- AppCompat 라이브러리는 개발자가 하위 버전의 안드로이드와의 호환성을 유지하는 데 도움이 되도록 설계된 Android Jetpack 제품군의 일부
- UI 컴포넌트 하위 호환성: AppCompat 라이브러리는 FragmentActivity를 확장하고 하위 버전의 안드로이드와의 호환성을 보장하는 AppCompatActivity와 같은 최신 UI 컴포넌트를 제공
- Material Design 지원: AppCompat을 사용하면 개발자는 하위 안드로이드 버전을 실행하는 기기에 Material Design 원칙을 통합할 수 있음. AppCompatButton, AppCompatTextView 등 기기의 API 레벨에 따라 모양과 동작을 자동으로 조정하는 위젯이 제공
- 테마 및 스타일링 지원: AppCompat을 사용하면 Theme.AppCompat과 같은 테마를 사용하여 모든 API 레벨에서 일관된 UI를 보장. 이러한 테마는 Vector Drawable과 같은 최신 스타일링 기능을 하위 안드로이드 버전에 제공
- 동적 기능 지원: AppCompat 라이브러리는 동적 리소스 로딩 및 Vector Drawable 지원을 제공하여 하위 호환성을 유지하면서 최신 디자인 요소를 효율적으로 구현하기 쉽게 만듦

#### AppCompat을 사용하는 이유

- 최신 안드로이드 기능과 UI 컴포넌트가 지원되는 모든 API 레벨에서 일관되게 작동하도록 보장
- 하위 버전의 안드로이드 기기에서 호환성을 유지하기 위한 복잡성을 줄여줌

#### AppCompatActivity 사용 예제

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
```

- AppCompatActivity는 Activity가 하위 안드로이드 버전을 실행하는 기기에서 액션 바와 같은 기능을 사용할 수 있도록 보장

#### 실전 질문

Q) AppCompat 라이브러리는 하위 안드로이드 버전에서 Material Design 지원을 어떻게 가능하게 하며, 이와 같은 동작을 기반으로 하는 주요 UI 컴포넌트에는 무엇이 있나요?

A) AppCompat 라이브러리는 하위 안드로이드 버전에서 Material Design 지원을 가능하게 하기 위해 AppCompat 위젯을 제공. 이러한 위젯은 기기의 API 레벨에 따라 모양과 동작을 자동으로 조정. 주요 UI 컴포넌트에는 AppCompatButton, AppCompatTextView, AppCompatImageView, AppCompatEditText 등이 포함되며, 이들은 최신 디자인 요소를 하위 버전에서도 일관되게 구현할 수 있도록 지원

### 50. Material Design Components (MDC)란 무엇인가요?

- Material Design Components (MDC)는 Google의 Material Design 가이드라인을 기반으로 하는 커스텀 가능한 UI 위젯 및 컴포넌트 집합

#### Material Design Components의 주요 특징

1. Material Theming: MDC는 Material Theming을 지원하여 개발자가 타이포그래피, 모양 및 색상을 전역적으로 또는 컴포넌트 수준에서 커스텀할 수 있도록 함
2. 미리 빌드된 UI 컴포넌트: MCD는 버튼, 카드, 앱 바, 내비게이션 드로어, 칩 등과 같이 즉시 사용할 수 있는 광범위한 UI 컴포넌트를 제공
3. 애니메이션 지원: MDC는 공유 요소 전환 (shared element transitions), 리플 효과 및 시각적 피드백과 같은 애니메이션에 대한 내장 지원이 포함되어 사용자 상호 자용을 향상시킴
4. 다크 모드 지원: 다크 모드를 쉽게 구현할 수 있는 API가 포함되어 있어 개발자가 시각적 일관성을 보장하면서 라이트 및 다크 모드에 대한 테마를 정의
5. 접근성: 더 큰 터치 대상, 접근성을 위한 sematic 레이블 및 적절한 포커스 관리와 같은 기능을 제공하여 접근성 표준을 준수하여 모든 사용자를 위한 포괄적인 UI를 보장

#### Material Button 사용 예제

```xml
<com.google.android.material.button.MaterialButton
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Click Me"
    app:cornerRadius="8dp"
    app:icon="@drawable/ic_example"
    app:iconGravity="start"
    app:iconPadding="8dp"/>
```

#### 실전 질문

Q) MDC의 Material Theming은 앱 전체에서 디자인 일관성을 유지하는 데 어떻게 도움이 되나요?

A) Material Theming은 색상, 타이포그래피 및 모양과 같은 디자인 요소를 전역적으로 또는 컴포넌트 수준에서 커스텀할 수 있는 기능을 제공. 이를 통해 개발자는 브랜드 아이덴티티에 맞는 일관된 시각적 스타일을 유지하면서도 다양한 UI 컴포넌트에 동일한 디자인 언어를 적용할 수 있음. 결과적으로 앱 전체에서 통일된 사용자 경험을 제공

### 51. ViewBinding를 사용하면 어떤 장점이 있나요?

ViewBinding은 수동으로 findViewById()를 호출하지 않아도 되고, 뷰에 접근하는 type-safe 방식을 제공하여 보일러 플레이트 코드를 줄이고 잠재적인 런타임 오류를 최소화

#### ViewBinding 작동 방식

- 프로젝트에서 ViewBinding을 활성화하면 각 XML 레이아웃 파일에 대해 바인딩 클래스가 생성
- 생성된 바인딩 클래스의 이름 레이아웃 파일 이름에서 파생되며, 각 밑줄(_)은 카멜 케이스(camel case)로 변환되고 이름 끝에 Bindingdl cnrk

```kotlin
class MainActivity : AppCompatActivity() {
    // 바인딩 클래스 인스턴스 선언
    private lateinit var binding: ActivityMainBinding
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 바인딩 클래스 인스턴스 초기화
        binding = ActivityMainBinding.inflate(layoutInflater)
        // 루트 뷰를 설정
        setContentView(binding.root)
        
        // 바인딩 객체를 사용하여 뷰에 접근
        binding.textView.text = "Hello, ViewBinding!"
        binding.button.setOnClickListener {
            // 버튼 클릭 시 동작
        }
    }
}
```

- inflate() 메소드는 바인딩 클래스의 인스턴스를 생성하는 데 사용되고, binding.root는 레이아웃을 설정하기 위해 setContentView()에 전달

#### ViewBinding의 장점

- 타입 안전성(Type Safety): 캐스팅할 필요 없이 뷰에 직접 접근하여 타입 불일치로 인한 런타임 오류를 제거
- 더 깔끔한 코드: findViewById()를 호출할 필요가 없어지고 보일러 플레이트 코드가 줄얻름
- Null 안전성(Null Safety): nullable 타입의 뷰를 자동으로 처리하여 선택적 UI 컴포넌트와 상호 작용할 때 더 안전한 코드 보장
- 성능: DataBinding과 달리 ViewBinding은 바인딩 표현식이나 추가 XML 파싱을 사용하지 않으므로 런타임 오버헤드가 최소화

#### DataBinding과의 비교

- DataBinding은 바인딩 표현식 및 양방향 데이터 바인딩과 같은 기능을 제공하지만 런타임 오버헤드를 유발
- 반면 ViewBinding은 단순히 뷰에 대한 타입 안전한 참조를 제공하는 데 중점

#### ViewBinding 활성화하기

```gradle
// build.gradle (app 수준)
android {
    ...
    buildFeatures {
        viewBinding = true
    }
}
```

#### 실전 질문

Q) ViewBinding은 findViewById()와 비교하여 타입 안전성과 null 안전성을 어떻게 개선하며, 해당 접근 방식의 이점은 무엇인가요?

A) ViewBinding은 각 뷰에 대한 타입 안전한 참조를 제공하여 findViewById()에서 발생할 수 있는 캐스팅 오류를 제거. 또한, nullable 뷰를 자동으로 처리하여 null 안전성을 향상시킴. 이러한 접근 방식은 런타임 오류를 줄이고, 코드의 가독성과 유지보수성을 높이며, 개발자가 UI 컴포넌트와 상호 작용할 때 더 안전한 코드를 작성할 수 있도록 지원